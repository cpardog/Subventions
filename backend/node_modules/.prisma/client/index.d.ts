
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model Usuario
 * 
 */
export type Usuario = $Result.DefaultSelection<Prisma.$UsuarioPayload>
/**
 * Model PasswordHistorial
 * 
 */
export type PasswordHistorial = $Result.DefaultSelection<Prisma.$PasswordHistorialPayload>
/**
 * Model TokenRecuperacion
 * 
 */
export type TokenRecuperacion = $Result.DefaultSelection<Prisma.$TokenRecuperacionPayload>
/**
 * Model Sesion
 * 
 */
export type Sesion = $Result.DefaultSelection<Prisma.$SesionPayload>
/**
 * Model CambioRol
 * 
 */
export type CambioRol = $Result.DefaultSelection<Prisma.$CambioRolPayload>
/**
 * Model CatalogoDocumento
 * 
 */
export type CatalogoDocumento = $Result.DefaultSelection<Prisma.$CatalogoDocumentoPayload>
/**
 * Model Proceso
 * 
 */
export type Proceso = $Result.DefaultSelection<Prisma.$ProcesoPayload>
/**
 * Model Documento
 * 
 */
export type Documento = $Result.DefaultSelection<Prisma.$DocumentoPayload>
/**
 * Model RegistroDescarga
 * 
 */
export type RegistroDescarga = $Result.DefaultSelection<Prisma.$RegistroDescargaPayload>
/**
 * Model HistorialPdf
 * 
 */
export type HistorialPdf = $Result.DefaultSelection<Prisma.$HistorialPdfPayload>
/**
 * Model Decision
 * 
 */
export type Decision = $Result.DefaultSelection<Prisma.$DecisionPayload>
/**
 * Model EventoAuditoria
 * 
 */
export type EventoAuditoria = $Result.DefaultSelection<Prisma.$EventoAuditoriaPayload>
/**
 * Model Configuracion
 * 
 */
export type Configuracion = $Result.DefaultSelection<Prisma.$ConfiguracionPayload>
/**
 * Model Convocatoria
 * 
 */
export type Convocatoria = $Result.DefaultSelection<Prisma.$ConvocatoriaPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const Rol: {
  BENEFICIARIO: 'BENEFICIARIO',
  ARRENDADOR: 'ARRENDADOR',
  DIGER: 'DIGER',
  DIRECTORA: 'DIRECTORA',
  ORDENADOR_GASTO: 'ORDENADOR_GASTO',
  CRI: 'CRI'
};

export type Rol = (typeof Rol)[keyof typeof Rol]


export const EstadoUsuario: {
  ACTIVO: 'ACTIVO',
  INACTIVO: 'INACTIVO',
  BLOQUEADO: 'BLOQUEADO'
};

export type EstadoUsuario = (typeof EstadoUsuario)[keyof typeof EstadoUsuario]


export const TipoDocumento: {
  CEDULA_IDENTIDAD: 'CEDULA_IDENTIDAD',
  CONTRATO_ARRENDAMIENTO: 'CONTRATO_ARRENDAMIENTO',
  CERTIFICADO_RESIDENCIA: 'CERTIFICADO_RESIDENCIA',
  RECIBO_SERVICIO: 'RECIBO_SERVICIO',
  CERTIFICADO_INGRESOS: 'CERTIFICADO_INGRESOS',
  DECLARACION_JURADA: 'DECLARACION_JURADA',
  OTRO: 'OTRO'
};

export type TipoDocumento = (typeof TipoDocumento)[keyof typeof TipoDocumento]


export const EstadoProceso: {
  BORRADOR: 'BORRADOR',
  ENVIADA: 'ENVIADA',
  DOCUMENTOS_EN_VALIDACION: 'DOCUMENTOS_EN_VALIDACION',
  REQUIERE_CORRECCION: 'REQUIERE_CORRECCION',
  VALIDADA_DIGER: 'VALIDADA_DIGER',
  REVISION_DIRECTORA: 'REVISION_DIRECTORA',
  REVISION_ORDENADOR: 'REVISION_ORDENADOR',
  FIRMADA: 'FIRMADA',
  FINALIZADA: 'FINALIZADA',
  RECHAZADA: 'RECHAZADA'
};

export type EstadoProceso = (typeof EstadoProceso)[keyof typeof EstadoProceso]


export const EstadoDocumento: {
  PENDIENTE: 'PENDIENTE',
  APROBADO: 'APROBADO',
  RECHAZADO: 'RECHAZADO'
};

export type EstadoDocumento = (typeof EstadoDocumento)[keyof typeof EstadoDocumento]


export const TipoEvento: {
  CREACION: 'CREACION',
  EDICION: 'EDICION',
  ENVIO: 'ENVIO',
  VALIDACION: 'VALIDACION',
  APROBACION: 'APROBACION',
  RECHAZO: 'RECHAZO',
  CORRECCION_SOLICITADA: 'CORRECCION_SOLICITADA',
  CORRECCION_ENVIADA: 'CORRECCION_ENVIADA',
  FIRMA: 'FIRMA',
  CIERRE: 'CIERRE',
  CAMBIO_ESTADO: 'CAMBIO_ESTADO'
};

export type TipoEvento = (typeof TipoEvento)[keyof typeof TipoEvento]

}

export type Rol = $Enums.Rol

export const Rol: typeof $Enums.Rol

export type EstadoUsuario = $Enums.EstadoUsuario

export const EstadoUsuario: typeof $Enums.EstadoUsuario

export type TipoDocumento = $Enums.TipoDocumento

export const TipoDocumento: typeof $Enums.TipoDocumento

export type EstadoProceso = $Enums.EstadoProceso

export const EstadoProceso: typeof $Enums.EstadoProceso

export type EstadoDocumento = $Enums.EstadoDocumento

export const EstadoDocumento: typeof $Enums.EstadoDocumento

export type TipoEvento = $Enums.TipoEvento

export const TipoEvento: typeof $Enums.TipoEvento

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Usuarios
 * const usuarios = await prisma.usuario.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Usuarios
   * const usuarios = await prisma.usuario.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.usuario`: Exposes CRUD operations for the **Usuario** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Usuarios
    * const usuarios = await prisma.usuario.findMany()
    * ```
    */
  get usuario(): Prisma.UsuarioDelegate<ExtArgs>;

  /**
   * `prisma.passwordHistorial`: Exposes CRUD operations for the **PasswordHistorial** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PasswordHistorials
    * const passwordHistorials = await prisma.passwordHistorial.findMany()
    * ```
    */
  get passwordHistorial(): Prisma.PasswordHistorialDelegate<ExtArgs>;

  /**
   * `prisma.tokenRecuperacion`: Exposes CRUD operations for the **TokenRecuperacion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TokenRecuperacions
    * const tokenRecuperacions = await prisma.tokenRecuperacion.findMany()
    * ```
    */
  get tokenRecuperacion(): Prisma.TokenRecuperacionDelegate<ExtArgs>;

  /**
   * `prisma.sesion`: Exposes CRUD operations for the **Sesion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Sesions
    * const sesions = await prisma.sesion.findMany()
    * ```
    */
  get sesion(): Prisma.SesionDelegate<ExtArgs>;

  /**
   * `prisma.cambioRol`: Exposes CRUD operations for the **CambioRol** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CambioRols
    * const cambioRols = await prisma.cambioRol.findMany()
    * ```
    */
  get cambioRol(): Prisma.CambioRolDelegate<ExtArgs>;

  /**
   * `prisma.catalogoDocumento`: Exposes CRUD operations for the **CatalogoDocumento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more CatalogoDocumentos
    * const catalogoDocumentos = await prisma.catalogoDocumento.findMany()
    * ```
    */
  get catalogoDocumento(): Prisma.CatalogoDocumentoDelegate<ExtArgs>;

  /**
   * `prisma.proceso`: Exposes CRUD operations for the **Proceso** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Procesos
    * const procesos = await prisma.proceso.findMany()
    * ```
    */
  get proceso(): Prisma.ProcesoDelegate<ExtArgs>;

  /**
   * `prisma.documento`: Exposes CRUD operations for the **Documento** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Documentos
    * const documentos = await prisma.documento.findMany()
    * ```
    */
  get documento(): Prisma.DocumentoDelegate<ExtArgs>;

  /**
   * `prisma.registroDescarga`: Exposes CRUD operations for the **RegistroDescarga** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RegistroDescargas
    * const registroDescargas = await prisma.registroDescarga.findMany()
    * ```
    */
  get registroDescarga(): Prisma.RegistroDescargaDelegate<ExtArgs>;

  /**
   * `prisma.historialPdf`: Exposes CRUD operations for the **HistorialPdf** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more HistorialPdfs
    * const historialPdfs = await prisma.historialPdf.findMany()
    * ```
    */
  get historialPdf(): Prisma.HistorialPdfDelegate<ExtArgs>;

  /**
   * `prisma.decision`: Exposes CRUD operations for the **Decision** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Decisions
    * const decisions = await prisma.decision.findMany()
    * ```
    */
  get decision(): Prisma.DecisionDelegate<ExtArgs>;

  /**
   * `prisma.eventoAuditoria`: Exposes CRUD operations for the **EventoAuditoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventoAuditorias
    * const eventoAuditorias = await prisma.eventoAuditoria.findMany()
    * ```
    */
  get eventoAuditoria(): Prisma.EventoAuditoriaDelegate<ExtArgs>;

  /**
   * `prisma.configuracion`: Exposes CRUD operations for the **Configuracion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Configuracions
    * const configuracions = await prisma.configuracion.findMany()
    * ```
    */
  get configuracion(): Prisma.ConfiguracionDelegate<ExtArgs>;

  /**
   * `prisma.convocatoria`: Exposes CRUD operations for the **Convocatoria** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Convocatorias
    * const convocatorias = await prisma.convocatoria.findMany()
    * ```
    */
  get convocatoria(): Prisma.ConvocatoriaDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    Usuario: 'Usuario',
    PasswordHistorial: 'PasswordHistorial',
    TokenRecuperacion: 'TokenRecuperacion',
    Sesion: 'Sesion',
    CambioRol: 'CambioRol',
    CatalogoDocumento: 'CatalogoDocumento',
    Proceso: 'Proceso',
    Documento: 'Documento',
    RegistroDescarga: 'RegistroDescarga',
    HistorialPdf: 'HistorialPdf',
    Decision: 'Decision',
    EventoAuditoria: 'EventoAuditoria',
    Configuracion: 'Configuracion',
    Convocatoria: 'Convocatoria'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "usuario" | "passwordHistorial" | "tokenRecuperacion" | "sesion" | "cambioRol" | "catalogoDocumento" | "proceso" | "documento" | "registroDescarga" | "historialPdf" | "decision" | "eventoAuditoria" | "configuracion" | "convocatoria"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      Usuario: {
        payload: Prisma.$UsuarioPayload<ExtArgs>
        fields: Prisma.UsuarioFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UsuarioFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UsuarioFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findFirst: {
            args: Prisma.UsuarioFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UsuarioFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          findMany: {
            args: Prisma.UsuarioFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          create: {
            args: Prisma.UsuarioCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          createMany: {
            args: Prisma.UsuarioCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UsuarioCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>[]
          }
          delete: {
            args: Prisma.UsuarioDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          update: {
            args: Prisma.UsuarioUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          deleteMany: {
            args: Prisma.UsuarioDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UsuarioUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UsuarioUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UsuarioPayload>
          }
          aggregate: {
            args: Prisma.UsuarioAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsuario>
          }
          groupBy: {
            args: Prisma.UsuarioGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsuarioGroupByOutputType>[]
          }
          count: {
            args: Prisma.UsuarioCountArgs<ExtArgs>
            result: $Utils.Optional<UsuarioCountAggregateOutputType> | number
          }
        }
      }
      PasswordHistorial: {
        payload: Prisma.$PasswordHistorialPayload<ExtArgs>
        fields: Prisma.PasswordHistorialFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PasswordHistorialFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistorialPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PasswordHistorialFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistorialPayload>
          }
          findFirst: {
            args: Prisma.PasswordHistorialFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistorialPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PasswordHistorialFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistorialPayload>
          }
          findMany: {
            args: Prisma.PasswordHistorialFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistorialPayload>[]
          }
          create: {
            args: Prisma.PasswordHistorialCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistorialPayload>
          }
          createMany: {
            args: Prisma.PasswordHistorialCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PasswordHistorialCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistorialPayload>[]
          }
          delete: {
            args: Prisma.PasswordHistorialDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistorialPayload>
          }
          update: {
            args: Prisma.PasswordHistorialUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistorialPayload>
          }
          deleteMany: {
            args: Prisma.PasswordHistorialDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PasswordHistorialUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PasswordHistorialUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PasswordHistorialPayload>
          }
          aggregate: {
            args: Prisma.PasswordHistorialAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePasswordHistorial>
          }
          groupBy: {
            args: Prisma.PasswordHistorialGroupByArgs<ExtArgs>
            result: $Utils.Optional<PasswordHistorialGroupByOutputType>[]
          }
          count: {
            args: Prisma.PasswordHistorialCountArgs<ExtArgs>
            result: $Utils.Optional<PasswordHistorialCountAggregateOutputType> | number
          }
        }
      }
      TokenRecuperacion: {
        payload: Prisma.$TokenRecuperacionPayload<ExtArgs>
        fields: Prisma.TokenRecuperacionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TokenRecuperacionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRecuperacionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TokenRecuperacionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRecuperacionPayload>
          }
          findFirst: {
            args: Prisma.TokenRecuperacionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRecuperacionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TokenRecuperacionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRecuperacionPayload>
          }
          findMany: {
            args: Prisma.TokenRecuperacionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRecuperacionPayload>[]
          }
          create: {
            args: Prisma.TokenRecuperacionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRecuperacionPayload>
          }
          createMany: {
            args: Prisma.TokenRecuperacionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TokenRecuperacionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRecuperacionPayload>[]
          }
          delete: {
            args: Prisma.TokenRecuperacionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRecuperacionPayload>
          }
          update: {
            args: Prisma.TokenRecuperacionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRecuperacionPayload>
          }
          deleteMany: {
            args: Prisma.TokenRecuperacionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TokenRecuperacionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TokenRecuperacionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TokenRecuperacionPayload>
          }
          aggregate: {
            args: Prisma.TokenRecuperacionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTokenRecuperacion>
          }
          groupBy: {
            args: Prisma.TokenRecuperacionGroupByArgs<ExtArgs>
            result: $Utils.Optional<TokenRecuperacionGroupByOutputType>[]
          }
          count: {
            args: Prisma.TokenRecuperacionCountArgs<ExtArgs>
            result: $Utils.Optional<TokenRecuperacionCountAggregateOutputType> | number
          }
        }
      }
      Sesion: {
        payload: Prisma.$SesionPayload<ExtArgs>
        fields: Prisma.SesionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SesionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SesionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>
          }
          findFirst: {
            args: Prisma.SesionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SesionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>
          }
          findMany: {
            args: Prisma.SesionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>[]
          }
          create: {
            args: Prisma.SesionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>
          }
          createMany: {
            args: Prisma.SesionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SesionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>[]
          }
          delete: {
            args: Prisma.SesionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>
          }
          update: {
            args: Prisma.SesionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>
          }
          deleteMany: {
            args: Prisma.SesionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SesionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SesionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SesionPayload>
          }
          aggregate: {
            args: Prisma.SesionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSesion>
          }
          groupBy: {
            args: Prisma.SesionGroupByArgs<ExtArgs>
            result: $Utils.Optional<SesionGroupByOutputType>[]
          }
          count: {
            args: Prisma.SesionCountArgs<ExtArgs>
            result: $Utils.Optional<SesionCountAggregateOutputType> | number
          }
        }
      }
      CambioRol: {
        payload: Prisma.$CambioRolPayload<ExtArgs>
        fields: Prisma.CambioRolFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CambioRolFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CambioRolPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CambioRolFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CambioRolPayload>
          }
          findFirst: {
            args: Prisma.CambioRolFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CambioRolPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CambioRolFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CambioRolPayload>
          }
          findMany: {
            args: Prisma.CambioRolFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CambioRolPayload>[]
          }
          create: {
            args: Prisma.CambioRolCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CambioRolPayload>
          }
          createMany: {
            args: Prisma.CambioRolCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CambioRolCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CambioRolPayload>[]
          }
          delete: {
            args: Prisma.CambioRolDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CambioRolPayload>
          }
          update: {
            args: Prisma.CambioRolUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CambioRolPayload>
          }
          deleteMany: {
            args: Prisma.CambioRolDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CambioRolUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CambioRolUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CambioRolPayload>
          }
          aggregate: {
            args: Prisma.CambioRolAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCambioRol>
          }
          groupBy: {
            args: Prisma.CambioRolGroupByArgs<ExtArgs>
            result: $Utils.Optional<CambioRolGroupByOutputType>[]
          }
          count: {
            args: Prisma.CambioRolCountArgs<ExtArgs>
            result: $Utils.Optional<CambioRolCountAggregateOutputType> | number
          }
        }
      }
      CatalogoDocumento: {
        payload: Prisma.$CatalogoDocumentoPayload<ExtArgs>
        fields: Prisma.CatalogoDocumentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CatalogoDocumentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoDocumentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CatalogoDocumentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoDocumentoPayload>
          }
          findFirst: {
            args: Prisma.CatalogoDocumentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoDocumentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CatalogoDocumentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoDocumentoPayload>
          }
          findMany: {
            args: Prisma.CatalogoDocumentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoDocumentoPayload>[]
          }
          create: {
            args: Prisma.CatalogoDocumentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoDocumentoPayload>
          }
          createMany: {
            args: Prisma.CatalogoDocumentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.CatalogoDocumentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoDocumentoPayload>[]
          }
          delete: {
            args: Prisma.CatalogoDocumentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoDocumentoPayload>
          }
          update: {
            args: Prisma.CatalogoDocumentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoDocumentoPayload>
          }
          deleteMany: {
            args: Prisma.CatalogoDocumentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CatalogoDocumentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CatalogoDocumentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CatalogoDocumentoPayload>
          }
          aggregate: {
            args: Prisma.CatalogoDocumentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCatalogoDocumento>
          }
          groupBy: {
            args: Prisma.CatalogoDocumentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<CatalogoDocumentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.CatalogoDocumentoCountArgs<ExtArgs>
            result: $Utils.Optional<CatalogoDocumentoCountAggregateOutputType> | number
          }
        }
      }
      Proceso: {
        payload: Prisma.$ProcesoPayload<ExtArgs>
        fields: Prisma.ProcesoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ProcesoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ProcesoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>
          }
          findFirst: {
            args: Prisma.ProcesoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ProcesoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>
          }
          findMany: {
            args: Prisma.ProcesoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>[]
          }
          create: {
            args: Prisma.ProcesoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>
          }
          createMany: {
            args: Prisma.ProcesoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ProcesoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>[]
          }
          delete: {
            args: Prisma.ProcesoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>
          }
          update: {
            args: Prisma.ProcesoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>
          }
          deleteMany: {
            args: Prisma.ProcesoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ProcesoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ProcesoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ProcesoPayload>
          }
          aggregate: {
            args: Prisma.ProcesoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProceso>
          }
          groupBy: {
            args: Prisma.ProcesoGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProcesoGroupByOutputType>[]
          }
          count: {
            args: Prisma.ProcesoCountArgs<ExtArgs>
            result: $Utils.Optional<ProcesoCountAggregateOutputType> | number
          }
        }
      }
      Documento: {
        payload: Prisma.$DocumentoPayload<ExtArgs>
        fields: Prisma.DocumentoFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DocumentoFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DocumentoFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>
          }
          findFirst: {
            args: Prisma.DocumentoFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DocumentoFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>
          }
          findMany: {
            args: Prisma.DocumentoFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>[]
          }
          create: {
            args: Prisma.DocumentoCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>
          }
          createMany: {
            args: Prisma.DocumentoCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DocumentoCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>[]
          }
          delete: {
            args: Prisma.DocumentoDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>
          }
          update: {
            args: Prisma.DocumentoUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>
          }
          deleteMany: {
            args: Prisma.DocumentoDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DocumentoUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DocumentoUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DocumentoPayload>
          }
          aggregate: {
            args: Prisma.DocumentoAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDocumento>
          }
          groupBy: {
            args: Prisma.DocumentoGroupByArgs<ExtArgs>
            result: $Utils.Optional<DocumentoGroupByOutputType>[]
          }
          count: {
            args: Prisma.DocumentoCountArgs<ExtArgs>
            result: $Utils.Optional<DocumentoCountAggregateOutputType> | number
          }
        }
      }
      RegistroDescarga: {
        payload: Prisma.$RegistroDescargaPayload<ExtArgs>
        fields: Prisma.RegistroDescargaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RegistroDescargaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroDescargaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RegistroDescargaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroDescargaPayload>
          }
          findFirst: {
            args: Prisma.RegistroDescargaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroDescargaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RegistroDescargaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroDescargaPayload>
          }
          findMany: {
            args: Prisma.RegistroDescargaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroDescargaPayload>[]
          }
          create: {
            args: Prisma.RegistroDescargaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroDescargaPayload>
          }
          createMany: {
            args: Prisma.RegistroDescargaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.RegistroDescargaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroDescargaPayload>[]
          }
          delete: {
            args: Prisma.RegistroDescargaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroDescargaPayload>
          }
          update: {
            args: Prisma.RegistroDescargaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroDescargaPayload>
          }
          deleteMany: {
            args: Prisma.RegistroDescargaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RegistroDescargaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RegistroDescargaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RegistroDescargaPayload>
          }
          aggregate: {
            args: Prisma.RegistroDescargaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRegistroDescarga>
          }
          groupBy: {
            args: Prisma.RegistroDescargaGroupByArgs<ExtArgs>
            result: $Utils.Optional<RegistroDescargaGroupByOutputType>[]
          }
          count: {
            args: Prisma.RegistroDescargaCountArgs<ExtArgs>
            result: $Utils.Optional<RegistroDescargaCountAggregateOutputType> | number
          }
        }
      }
      HistorialPdf: {
        payload: Prisma.$HistorialPdfPayload<ExtArgs>
        fields: Prisma.HistorialPdfFieldRefs
        operations: {
          findUnique: {
            args: Prisma.HistorialPdfFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorialPdfPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.HistorialPdfFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorialPdfPayload>
          }
          findFirst: {
            args: Prisma.HistorialPdfFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorialPdfPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.HistorialPdfFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorialPdfPayload>
          }
          findMany: {
            args: Prisma.HistorialPdfFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorialPdfPayload>[]
          }
          create: {
            args: Prisma.HistorialPdfCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorialPdfPayload>
          }
          createMany: {
            args: Prisma.HistorialPdfCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.HistorialPdfCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorialPdfPayload>[]
          }
          delete: {
            args: Prisma.HistorialPdfDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorialPdfPayload>
          }
          update: {
            args: Prisma.HistorialPdfUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorialPdfPayload>
          }
          deleteMany: {
            args: Prisma.HistorialPdfDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.HistorialPdfUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.HistorialPdfUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$HistorialPdfPayload>
          }
          aggregate: {
            args: Prisma.HistorialPdfAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateHistorialPdf>
          }
          groupBy: {
            args: Prisma.HistorialPdfGroupByArgs<ExtArgs>
            result: $Utils.Optional<HistorialPdfGroupByOutputType>[]
          }
          count: {
            args: Prisma.HistorialPdfCountArgs<ExtArgs>
            result: $Utils.Optional<HistorialPdfCountAggregateOutputType> | number
          }
        }
      }
      Decision: {
        payload: Prisma.$DecisionPayload<ExtArgs>
        fields: Prisma.DecisionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DecisionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DecisionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionPayload>
          }
          findFirst: {
            args: Prisma.DecisionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DecisionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionPayload>
          }
          findMany: {
            args: Prisma.DecisionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionPayload>[]
          }
          create: {
            args: Prisma.DecisionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionPayload>
          }
          createMany: {
            args: Prisma.DecisionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DecisionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionPayload>[]
          }
          delete: {
            args: Prisma.DecisionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionPayload>
          }
          update: {
            args: Prisma.DecisionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionPayload>
          }
          deleteMany: {
            args: Prisma.DecisionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DecisionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DecisionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DecisionPayload>
          }
          aggregate: {
            args: Prisma.DecisionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDecision>
          }
          groupBy: {
            args: Prisma.DecisionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DecisionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DecisionCountArgs<ExtArgs>
            result: $Utils.Optional<DecisionCountAggregateOutputType> | number
          }
        }
      }
      EventoAuditoria: {
        payload: Prisma.$EventoAuditoriaPayload<ExtArgs>
        fields: Prisma.EventoAuditoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventoAuditoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAuditoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventoAuditoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAuditoriaPayload>
          }
          findFirst: {
            args: Prisma.EventoAuditoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAuditoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventoAuditoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAuditoriaPayload>
          }
          findMany: {
            args: Prisma.EventoAuditoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAuditoriaPayload>[]
          }
          create: {
            args: Prisma.EventoAuditoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAuditoriaPayload>
          }
          createMany: {
            args: Prisma.EventoAuditoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EventoAuditoriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAuditoriaPayload>[]
          }
          delete: {
            args: Prisma.EventoAuditoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAuditoriaPayload>
          }
          update: {
            args: Prisma.EventoAuditoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAuditoriaPayload>
          }
          deleteMany: {
            args: Prisma.EventoAuditoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventoAuditoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventoAuditoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventoAuditoriaPayload>
          }
          aggregate: {
            args: Prisma.EventoAuditoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventoAuditoria>
          }
          groupBy: {
            args: Prisma.EventoAuditoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventoAuditoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventoAuditoriaCountArgs<ExtArgs>
            result: $Utils.Optional<EventoAuditoriaCountAggregateOutputType> | number
          }
        }
      }
      Configuracion: {
        payload: Prisma.$ConfiguracionPayload<ExtArgs>
        fields: Prisma.ConfiguracionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConfiguracionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConfiguracionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPayload>
          }
          findFirst: {
            args: Prisma.ConfiguracionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConfiguracionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPayload>
          }
          findMany: {
            args: Prisma.ConfiguracionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPayload>[]
          }
          create: {
            args: Prisma.ConfiguracionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPayload>
          }
          createMany: {
            args: Prisma.ConfiguracionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConfiguracionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPayload>[]
          }
          delete: {
            args: Prisma.ConfiguracionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPayload>
          }
          update: {
            args: Prisma.ConfiguracionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPayload>
          }
          deleteMany: {
            args: Prisma.ConfiguracionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConfiguracionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConfiguracionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConfiguracionPayload>
          }
          aggregate: {
            args: Prisma.ConfiguracionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConfiguracion>
          }
          groupBy: {
            args: Prisma.ConfiguracionGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConfiguracionGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConfiguracionCountArgs<ExtArgs>
            result: $Utils.Optional<ConfiguracionCountAggregateOutputType> | number
          }
        }
      }
      Convocatoria: {
        payload: Prisma.$ConvocatoriaPayload<ExtArgs>
        fields: Prisma.ConvocatoriaFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ConvocatoriaFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ConvocatoriaFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload>
          }
          findFirst: {
            args: Prisma.ConvocatoriaFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ConvocatoriaFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload>
          }
          findMany: {
            args: Prisma.ConvocatoriaFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload>[]
          }
          create: {
            args: Prisma.ConvocatoriaCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload>
          }
          createMany: {
            args: Prisma.ConvocatoriaCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ConvocatoriaCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload>[]
          }
          delete: {
            args: Prisma.ConvocatoriaDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload>
          }
          update: {
            args: Prisma.ConvocatoriaUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload>
          }
          deleteMany: {
            args: Prisma.ConvocatoriaDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ConvocatoriaUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ConvocatoriaUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ConvocatoriaPayload>
          }
          aggregate: {
            args: Prisma.ConvocatoriaAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateConvocatoria>
          }
          groupBy: {
            args: Prisma.ConvocatoriaGroupByArgs<ExtArgs>
            result: $Utils.Optional<ConvocatoriaGroupByOutputType>[]
          }
          count: {
            args: Prisma.ConvocatoriaCountArgs<ExtArgs>
            result: $Utils.Optional<ConvocatoriaCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UsuarioCountOutputType
   */

  export type UsuarioCountOutputType = {
    usuariosCreados: number
    passwordHistorial: number
    sesiones: number
    procesosBeneficiario: number
    procesosArrendador: number
    documentosCargados: number
    documentosValidados: number
    eventosAuditoria: number
    decisiones: number
    tokenRecuperacion: number
    cambiosRol: number
  }

  export type UsuarioCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuariosCreados?: boolean | UsuarioCountOutputTypeCountUsuariosCreadosArgs
    passwordHistorial?: boolean | UsuarioCountOutputTypeCountPasswordHistorialArgs
    sesiones?: boolean | UsuarioCountOutputTypeCountSesionesArgs
    procesosBeneficiario?: boolean | UsuarioCountOutputTypeCountProcesosBeneficiarioArgs
    procesosArrendador?: boolean | UsuarioCountOutputTypeCountProcesosArrendadorArgs
    documentosCargados?: boolean | UsuarioCountOutputTypeCountDocumentosCargadosArgs
    documentosValidados?: boolean | UsuarioCountOutputTypeCountDocumentosValidadosArgs
    eventosAuditoria?: boolean | UsuarioCountOutputTypeCountEventosAuditoriaArgs
    decisiones?: boolean | UsuarioCountOutputTypeCountDecisionesArgs
    tokenRecuperacion?: boolean | UsuarioCountOutputTypeCountTokenRecuperacionArgs
    cambiosRol?: boolean | UsuarioCountOutputTypeCountCambiosRolArgs
  }

  // Custom InputTypes
  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UsuarioCountOutputType
     */
    select?: UsuarioCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountUsuariosCreadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountPasswordHistorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordHistorialWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountSesionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SesionWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountProcesosBeneficiarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcesoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountProcesosArrendadorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcesoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountDocumentosCargadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountDocumentosValidadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentoWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountEventosAuditoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventoAuditoriaWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountDecisionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DecisionWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountTokenRecuperacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenRecuperacionWhereInput
  }

  /**
   * UsuarioCountOutputType without action
   */
  export type UsuarioCountOutputTypeCountCambiosRolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CambioRolWhereInput
  }


  /**
   * Count Type CatalogoDocumentoCountOutputType
   */

  export type CatalogoDocumentoCountOutputType = {
    documentos: number
  }

  export type CatalogoDocumentoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentos?: boolean | CatalogoDocumentoCountOutputTypeCountDocumentosArgs
  }

  // Custom InputTypes
  /**
   * CatalogoDocumentoCountOutputType without action
   */
  export type CatalogoDocumentoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoDocumentoCountOutputType
     */
    select?: CatalogoDocumentoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CatalogoDocumentoCountOutputType without action
   */
  export type CatalogoDocumentoCountOutputTypeCountDocumentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentoWhereInput
  }


  /**
   * Count Type ProcesoCountOutputType
   */

  export type ProcesoCountOutputType = {
    documentos: number
    eventos: number
    decisiones: number
    historialPdf: number
  }

  export type ProcesoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentos?: boolean | ProcesoCountOutputTypeCountDocumentosArgs
    eventos?: boolean | ProcesoCountOutputTypeCountEventosArgs
    decisiones?: boolean | ProcesoCountOutputTypeCountDecisionesArgs
    historialPdf?: boolean | ProcesoCountOutputTypeCountHistorialPdfArgs
  }

  // Custom InputTypes
  /**
   * ProcesoCountOutputType without action
   */
  export type ProcesoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ProcesoCountOutputType
     */
    select?: ProcesoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ProcesoCountOutputType without action
   */
  export type ProcesoCountOutputTypeCountDocumentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentoWhereInput
  }

  /**
   * ProcesoCountOutputType without action
   */
  export type ProcesoCountOutputTypeCountEventosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventoAuditoriaWhereInput
  }

  /**
   * ProcesoCountOutputType without action
   */
  export type ProcesoCountOutputTypeCountDecisionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DecisionWhereInput
  }

  /**
   * ProcesoCountOutputType without action
   */
  export type ProcesoCountOutputTypeCountHistorialPdfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialPdfWhereInput
  }


  /**
   * Count Type DocumentoCountOutputType
   */

  export type DocumentoCountOutputType = {
    descargas: number
  }

  export type DocumentoCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    descargas?: boolean | DocumentoCountOutputTypeCountDescargasArgs
  }

  // Custom InputTypes
  /**
   * DocumentoCountOutputType without action
   */
  export type DocumentoCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DocumentoCountOutputType
     */
    select?: DocumentoCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DocumentoCountOutputType without action
   */
  export type DocumentoCountOutputTypeCountDescargasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegistroDescargaWhereInput
  }


  /**
   * Models
   */

  /**
   * Model Usuario
   */

  export type AggregateUsuario = {
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  export type UsuarioAvgAggregateOutputType = {
    intentosFallidos: number | null
  }

  export type UsuarioSumAggregateOutputType = {
    intentosFallidos: number | null
  }

  export type UsuarioMinAggregateOutputType = {
    id: string | null
    cedula: string | null
    email: string | null
    nombreCompleto: string | null
    passwordHash: string | null
    rol: $Enums.Rol | null
    estado: $Enums.EstadoUsuario | null
    mfaSecret: string | null
    mfaHabilitado: boolean | null
    intentosFallidos: number | null
    bloqueadoHasta: Date | null
    ultimoAcceso: Date | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    creadoPorId: string | null
  }

  export type UsuarioMaxAggregateOutputType = {
    id: string | null
    cedula: string | null
    email: string | null
    nombreCompleto: string | null
    passwordHash: string | null
    rol: $Enums.Rol | null
    estado: $Enums.EstadoUsuario | null
    mfaSecret: string | null
    mfaHabilitado: boolean | null
    intentosFallidos: number | null
    bloqueadoHasta: Date | null
    ultimoAcceso: Date | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    creadoPorId: string | null
  }

  export type UsuarioCountAggregateOutputType = {
    id: number
    cedula: number
    email: number
    nombreCompleto: number
    passwordHash: number
    rol: number
    estado: number
    mfaSecret: number
    mfaHabilitado: number
    intentosFallidos: number
    bloqueadoHasta: number
    ultimoAcceso: number
    creadoEn: number
    actualizadoEn: number
    creadoPorId: number
    _all: number
  }


  export type UsuarioAvgAggregateInputType = {
    intentosFallidos?: true
  }

  export type UsuarioSumAggregateInputType = {
    intentosFallidos?: true
  }

  export type UsuarioMinAggregateInputType = {
    id?: true
    cedula?: true
    email?: true
    nombreCompleto?: true
    passwordHash?: true
    rol?: true
    estado?: true
    mfaSecret?: true
    mfaHabilitado?: true
    intentosFallidos?: true
    bloqueadoHasta?: true
    ultimoAcceso?: true
    creadoEn?: true
    actualizadoEn?: true
    creadoPorId?: true
  }

  export type UsuarioMaxAggregateInputType = {
    id?: true
    cedula?: true
    email?: true
    nombreCompleto?: true
    passwordHash?: true
    rol?: true
    estado?: true
    mfaSecret?: true
    mfaHabilitado?: true
    intentosFallidos?: true
    bloqueadoHasta?: true
    ultimoAcceso?: true
    creadoEn?: true
    actualizadoEn?: true
    creadoPorId?: true
  }

  export type UsuarioCountAggregateInputType = {
    id?: true
    cedula?: true
    email?: true
    nombreCompleto?: true
    passwordHash?: true
    rol?: true
    estado?: true
    mfaSecret?: true
    mfaHabilitado?: true
    intentosFallidos?: true
    bloqueadoHasta?: true
    ultimoAcceso?: true
    creadoEn?: true
    actualizadoEn?: true
    creadoPorId?: true
    _all?: true
  }

  export type UsuarioAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuario to aggregate.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Usuarios
    **/
    _count?: true | UsuarioCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UsuarioAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UsuarioSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsuarioMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsuarioMaxAggregateInputType
  }

  export type GetUsuarioAggregateType<T extends UsuarioAggregateArgs> = {
        [P in keyof T & keyof AggregateUsuario]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsuario[P]>
      : GetScalarType<T[P], AggregateUsuario[P]>
  }




  export type UsuarioGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithAggregationInput | UsuarioOrderByWithAggregationInput[]
    by: UsuarioScalarFieldEnum[] | UsuarioScalarFieldEnum
    having?: UsuarioScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsuarioCountAggregateInputType | true
    _avg?: UsuarioAvgAggregateInputType
    _sum?: UsuarioSumAggregateInputType
    _min?: UsuarioMinAggregateInputType
    _max?: UsuarioMaxAggregateInputType
  }

  export type UsuarioGroupByOutputType = {
    id: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado: $Enums.EstadoUsuario
    mfaSecret: string | null
    mfaHabilitado: boolean
    intentosFallidos: number
    bloqueadoHasta: Date | null
    ultimoAcceso: Date | null
    creadoEn: Date
    actualizadoEn: Date
    creadoPorId: string | null
    _count: UsuarioCountAggregateOutputType | null
    _avg: UsuarioAvgAggregateOutputType | null
    _sum: UsuarioSumAggregateOutputType | null
    _min: UsuarioMinAggregateOutputType | null
    _max: UsuarioMaxAggregateOutputType | null
  }

  type GetUsuarioGroupByPayload<T extends UsuarioGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsuarioGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsuarioGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
            : GetScalarType<T[P], UsuarioGroupByOutputType[P]>
        }
      >
    >


  export type UsuarioSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cedula?: boolean
    email?: boolean
    nombreCompleto?: boolean
    passwordHash?: boolean
    rol?: boolean
    estado?: boolean
    mfaSecret?: boolean
    mfaHabilitado?: boolean
    intentosFallidos?: boolean
    bloqueadoHasta?: boolean
    ultimoAcceso?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    creadoPorId?: boolean
    creadoPor?: boolean | Usuario$creadoPorArgs<ExtArgs>
    usuariosCreados?: boolean | Usuario$usuariosCreadosArgs<ExtArgs>
    passwordHistorial?: boolean | Usuario$passwordHistorialArgs<ExtArgs>
    sesiones?: boolean | Usuario$sesionesArgs<ExtArgs>
    procesosBeneficiario?: boolean | Usuario$procesosBeneficiarioArgs<ExtArgs>
    procesosArrendador?: boolean | Usuario$procesosArrendadorArgs<ExtArgs>
    documentosCargados?: boolean | Usuario$documentosCargadosArgs<ExtArgs>
    documentosValidados?: boolean | Usuario$documentosValidadosArgs<ExtArgs>
    eventosAuditoria?: boolean | Usuario$eventosAuditoriaArgs<ExtArgs>
    decisiones?: boolean | Usuario$decisionesArgs<ExtArgs>
    tokenRecuperacion?: boolean | Usuario$tokenRecuperacionArgs<ExtArgs>
    cambiosRol?: boolean | Usuario$cambiosRolArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    cedula?: boolean
    email?: boolean
    nombreCompleto?: boolean
    passwordHash?: boolean
    rol?: boolean
    estado?: boolean
    mfaSecret?: boolean
    mfaHabilitado?: boolean
    intentosFallidos?: boolean
    bloqueadoHasta?: boolean
    ultimoAcceso?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    creadoPorId?: boolean
    creadoPor?: boolean | Usuario$creadoPorArgs<ExtArgs>
  }, ExtArgs["result"]["usuario"]>

  export type UsuarioSelectScalar = {
    id?: boolean
    cedula?: boolean
    email?: boolean
    nombreCompleto?: boolean
    passwordHash?: boolean
    rol?: boolean
    estado?: boolean
    mfaSecret?: boolean
    mfaHabilitado?: boolean
    intentosFallidos?: boolean
    bloqueadoHasta?: boolean
    ultimoAcceso?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    creadoPorId?: boolean
  }

  export type UsuarioInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creadoPor?: boolean | Usuario$creadoPorArgs<ExtArgs>
    usuariosCreados?: boolean | Usuario$usuariosCreadosArgs<ExtArgs>
    passwordHistorial?: boolean | Usuario$passwordHistorialArgs<ExtArgs>
    sesiones?: boolean | Usuario$sesionesArgs<ExtArgs>
    procesosBeneficiario?: boolean | Usuario$procesosBeneficiarioArgs<ExtArgs>
    procesosArrendador?: boolean | Usuario$procesosArrendadorArgs<ExtArgs>
    documentosCargados?: boolean | Usuario$documentosCargadosArgs<ExtArgs>
    documentosValidados?: boolean | Usuario$documentosValidadosArgs<ExtArgs>
    eventosAuditoria?: boolean | Usuario$eventosAuditoriaArgs<ExtArgs>
    decisiones?: boolean | Usuario$decisionesArgs<ExtArgs>
    tokenRecuperacion?: boolean | Usuario$tokenRecuperacionArgs<ExtArgs>
    cambiosRol?: boolean | Usuario$cambiosRolArgs<ExtArgs>
    _count?: boolean | UsuarioCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UsuarioIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creadoPor?: boolean | Usuario$creadoPorArgs<ExtArgs>
  }

  export type $UsuarioPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Usuario"
    objects: {
      creadoPor: Prisma.$UsuarioPayload<ExtArgs> | null
      usuariosCreados: Prisma.$UsuarioPayload<ExtArgs>[]
      passwordHistorial: Prisma.$PasswordHistorialPayload<ExtArgs>[]
      sesiones: Prisma.$SesionPayload<ExtArgs>[]
      procesosBeneficiario: Prisma.$ProcesoPayload<ExtArgs>[]
      procesosArrendador: Prisma.$ProcesoPayload<ExtArgs>[]
      documentosCargados: Prisma.$DocumentoPayload<ExtArgs>[]
      documentosValidados: Prisma.$DocumentoPayload<ExtArgs>[]
      eventosAuditoria: Prisma.$EventoAuditoriaPayload<ExtArgs>[]
      decisiones: Prisma.$DecisionPayload<ExtArgs>[]
      tokenRecuperacion: Prisma.$TokenRecuperacionPayload<ExtArgs>[]
      cambiosRol: Prisma.$CambioRolPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      cedula: string
      email: string
      nombreCompleto: string
      passwordHash: string
      rol: $Enums.Rol
      estado: $Enums.EstadoUsuario
      mfaSecret: string | null
      mfaHabilitado: boolean
      intentosFallidos: number
      bloqueadoHasta: Date | null
      ultimoAcceso: Date | null
      creadoEn: Date
      actualizadoEn: Date
      creadoPorId: string | null
    }, ExtArgs["result"]["usuario"]>
    composites: {}
  }

  type UsuarioGetPayload<S extends boolean | null | undefined | UsuarioDefaultArgs> = $Result.GetResult<Prisma.$UsuarioPayload, S>

  type UsuarioCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UsuarioFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UsuarioCountAggregateInputType | true
    }

  export interface UsuarioDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Usuario'], meta: { name: 'Usuario' } }
    /**
     * Find zero or one Usuario that matches the filter.
     * @param {UsuarioFindUniqueArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UsuarioFindUniqueArgs>(args: SelectSubset<T, UsuarioFindUniqueArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Usuario that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UsuarioFindUniqueOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UsuarioFindUniqueOrThrowArgs>(args: SelectSubset<T, UsuarioFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Usuario that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UsuarioFindFirstArgs>(args?: SelectSubset<T, UsuarioFindFirstArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Usuario that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindFirstOrThrowArgs} args - Arguments to find a Usuario
     * @example
     * // Get one Usuario
     * const usuario = await prisma.usuario.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UsuarioFindFirstOrThrowArgs>(args?: SelectSubset<T, UsuarioFindFirstOrThrowArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Usuarios that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Usuarios
     * const usuarios = await prisma.usuario.findMany()
     * 
     * // Get first 10 Usuarios
     * const usuarios = await prisma.usuario.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usuarioWithIdOnly = await prisma.usuario.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UsuarioFindManyArgs>(args?: SelectSubset<T, UsuarioFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Usuario.
     * @param {UsuarioCreateArgs} args - Arguments to create a Usuario.
     * @example
     * // Create one Usuario
     * const Usuario = await prisma.usuario.create({
     *   data: {
     *     // ... data to create a Usuario
     *   }
     * })
     * 
     */
    create<T extends UsuarioCreateArgs>(args: SelectSubset<T, UsuarioCreateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Usuarios.
     * @param {UsuarioCreateManyArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UsuarioCreateManyArgs>(args?: SelectSubset<T, UsuarioCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Usuarios and returns the data saved in the database.
     * @param {UsuarioCreateManyAndReturnArgs} args - Arguments to create many Usuarios.
     * @example
     * // Create many Usuarios
     * const usuario = await prisma.usuario.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Usuarios and only return the `id`
     * const usuarioWithIdOnly = await prisma.usuario.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UsuarioCreateManyAndReturnArgs>(args?: SelectSubset<T, UsuarioCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Usuario.
     * @param {UsuarioDeleteArgs} args - Arguments to delete one Usuario.
     * @example
     * // Delete one Usuario
     * const Usuario = await prisma.usuario.delete({
     *   where: {
     *     // ... filter to delete one Usuario
     *   }
     * })
     * 
     */
    delete<T extends UsuarioDeleteArgs>(args: SelectSubset<T, UsuarioDeleteArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Usuario.
     * @param {UsuarioUpdateArgs} args - Arguments to update one Usuario.
     * @example
     * // Update one Usuario
     * const usuario = await prisma.usuario.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UsuarioUpdateArgs>(args: SelectSubset<T, UsuarioUpdateArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Usuarios.
     * @param {UsuarioDeleteManyArgs} args - Arguments to filter Usuarios to delete.
     * @example
     * // Delete a few Usuarios
     * const { count } = await prisma.usuario.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UsuarioDeleteManyArgs>(args?: SelectSubset<T, UsuarioDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Usuarios
     * const usuario = await prisma.usuario.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UsuarioUpdateManyArgs>(args: SelectSubset<T, UsuarioUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Usuario.
     * @param {UsuarioUpsertArgs} args - Arguments to update or create a Usuario.
     * @example
     * // Update or create a Usuario
     * const usuario = await prisma.usuario.upsert({
     *   create: {
     *     // ... data to create a Usuario
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Usuario we want to update
     *   }
     * })
     */
    upsert<T extends UsuarioUpsertArgs>(args: SelectSubset<T, UsuarioUpsertArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Usuarios.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioCountArgs} args - Arguments to filter Usuarios to count.
     * @example
     * // Count the number of Usuarios
     * const count = await prisma.usuario.count({
     *   where: {
     *     // ... the filter for the Usuarios we want to count
     *   }
     * })
    **/
    count<T extends UsuarioCountArgs>(
      args?: Subset<T, UsuarioCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsuarioCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsuarioAggregateArgs>(args: Subset<T, UsuarioAggregateArgs>): Prisma.PrismaPromise<GetUsuarioAggregateType<T>>

    /**
     * Group by Usuario.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsuarioGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UsuarioGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UsuarioGroupByArgs['orderBy'] }
        : { orderBy?: UsuarioGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UsuarioGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsuarioGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Usuario model
   */
  readonly fields: UsuarioFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Usuario.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UsuarioClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creadoPor<T extends Usuario$creadoPorArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$creadoPorArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    usuariosCreados<T extends Usuario$usuariosCreadosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$usuariosCreadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findMany"> | Null>
    passwordHistorial<T extends Usuario$passwordHistorialArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$passwordHistorialArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordHistorialPayload<ExtArgs>, T, "findMany"> | Null>
    sesiones<T extends Usuario$sesionesArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$sesionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "findMany"> | Null>
    procesosBeneficiario<T extends Usuario$procesosBeneficiarioArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$procesosBeneficiarioArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findMany"> | Null>
    procesosArrendador<T extends Usuario$procesosArrendadorArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$procesosArrendadorArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findMany"> | Null>
    documentosCargados<T extends Usuario$documentosCargadosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$documentosCargadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findMany"> | Null>
    documentosValidados<T extends Usuario$documentosValidadosArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$documentosValidadosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findMany"> | Null>
    eventosAuditoria<T extends Usuario$eventosAuditoriaArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$eventosAuditoriaArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoAuditoriaPayload<ExtArgs>, T, "findMany"> | Null>
    decisiones<T extends Usuario$decisionesArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$decisionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionPayload<ExtArgs>, T, "findMany"> | Null>
    tokenRecuperacion<T extends Usuario$tokenRecuperacionArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$tokenRecuperacionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenRecuperacionPayload<ExtArgs>, T, "findMany"> | Null>
    cambiosRol<T extends Usuario$cambiosRolArgs<ExtArgs> = {}>(args?: Subset<T, Usuario$cambiosRolArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CambioRolPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Usuario model
   */ 
  interface UsuarioFieldRefs {
    readonly id: FieldRef<"Usuario", 'String'>
    readonly cedula: FieldRef<"Usuario", 'String'>
    readonly email: FieldRef<"Usuario", 'String'>
    readonly nombreCompleto: FieldRef<"Usuario", 'String'>
    readonly passwordHash: FieldRef<"Usuario", 'String'>
    readonly rol: FieldRef<"Usuario", 'Rol'>
    readonly estado: FieldRef<"Usuario", 'EstadoUsuario'>
    readonly mfaSecret: FieldRef<"Usuario", 'String'>
    readonly mfaHabilitado: FieldRef<"Usuario", 'Boolean'>
    readonly intentosFallidos: FieldRef<"Usuario", 'Int'>
    readonly bloqueadoHasta: FieldRef<"Usuario", 'DateTime'>
    readonly ultimoAcceso: FieldRef<"Usuario", 'DateTime'>
    readonly creadoEn: FieldRef<"Usuario", 'DateTime'>
    readonly actualizadoEn: FieldRef<"Usuario", 'DateTime'>
    readonly creadoPorId: FieldRef<"Usuario", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Usuario findUnique
   */
  export type UsuarioFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findUniqueOrThrow
   */
  export type UsuarioFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario findFirst
   */
  export type UsuarioFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findFirstOrThrow
   */
  export type UsuarioFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuario to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Usuarios.
     */
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario findMany
   */
  export type UsuarioFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter, which Usuarios to fetch.
     */
    where?: UsuarioWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Usuarios to fetch.
     */
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Usuarios.
     */
    cursor?: UsuarioWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Usuarios from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Usuarios.
     */
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario create
   */
  export type UsuarioCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to create a Usuario.
     */
    data: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
  }

  /**
   * Usuario createMany
   */
  export type UsuarioCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Usuario createManyAndReturn
   */
  export type UsuarioCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Usuarios.
     */
    data: UsuarioCreateManyInput | UsuarioCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Usuario update
   */
  export type UsuarioUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The data needed to update a Usuario.
     */
    data: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
    /**
     * Choose, which Usuario to update.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario updateMany
   */
  export type UsuarioUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Usuarios.
     */
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyInput>
    /**
     * Filter which Usuarios to update
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario upsert
   */
  export type UsuarioUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * The filter to search for the Usuario to update in case it exists.
     */
    where: UsuarioWhereUniqueInput
    /**
     * In case the Usuario found by the `where` argument doesn't exist, create a new Usuario with this data.
     */
    create: XOR<UsuarioCreateInput, UsuarioUncheckedCreateInput>
    /**
     * In case the Usuario was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UsuarioUpdateInput, UsuarioUncheckedUpdateInput>
  }

  /**
   * Usuario delete
   */
  export type UsuarioDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    /**
     * Filter which Usuario to delete.
     */
    where: UsuarioWhereUniqueInput
  }

  /**
   * Usuario deleteMany
   */
  export type UsuarioDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Usuarios to delete
     */
    where?: UsuarioWhereInput
  }

  /**
   * Usuario.creadoPor
   */
  export type Usuario$creadoPorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
  }

  /**
   * Usuario.usuariosCreados
   */
  export type Usuario$usuariosCreadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
    orderBy?: UsuarioOrderByWithRelationInput | UsuarioOrderByWithRelationInput[]
    cursor?: UsuarioWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UsuarioScalarFieldEnum | UsuarioScalarFieldEnum[]
  }

  /**
   * Usuario.passwordHistorial
   */
  export type Usuario$passwordHistorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistorial
     */
    select?: PasswordHistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistorialInclude<ExtArgs> | null
    where?: PasswordHistorialWhereInput
    orderBy?: PasswordHistorialOrderByWithRelationInput | PasswordHistorialOrderByWithRelationInput[]
    cursor?: PasswordHistorialWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PasswordHistorialScalarFieldEnum | PasswordHistorialScalarFieldEnum[]
  }

  /**
   * Usuario.sesiones
   */
  export type Usuario$sesionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    where?: SesionWhereInput
    orderBy?: SesionOrderByWithRelationInput | SesionOrderByWithRelationInput[]
    cursor?: SesionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SesionScalarFieldEnum | SesionScalarFieldEnum[]
  }

  /**
   * Usuario.procesosBeneficiario
   */
  export type Usuario$procesosBeneficiarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    where?: ProcesoWhereInput
    orderBy?: ProcesoOrderByWithRelationInput | ProcesoOrderByWithRelationInput[]
    cursor?: ProcesoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcesoScalarFieldEnum | ProcesoScalarFieldEnum[]
  }

  /**
   * Usuario.procesosArrendador
   */
  export type Usuario$procesosArrendadorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    where?: ProcesoWhereInput
    orderBy?: ProcesoOrderByWithRelationInput | ProcesoOrderByWithRelationInput[]
    cursor?: ProcesoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProcesoScalarFieldEnum | ProcesoScalarFieldEnum[]
  }

  /**
   * Usuario.documentosCargados
   */
  export type Usuario$documentosCargadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    where?: DocumentoWhereInput
    orderBy?: DocumentoOrderByWithRelationInput | DocumentoOrderByWithRelationInput[]
    cursor?: DocumentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentoScalarFieldEnum | DocumentoScalarFieldEnum[]
  }

  /**
   * Usuario.documentosValidados
   */
  export type Usuario$documentosValidadosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    where?: DocumentoWhereInput
    orderBy?: DocumentoOrderByWithRelationInput | DocumentoOrderByWithRelationInput[]
    cursor?: DocumentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentoScalarFieldEnum | DocumentoScalarFieldEnum[]
  }

  /**
   * Usuario.eventosAuditoria
   */
  export type Usuario$eventosAuditoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAuditoria
     */
    select?: EventoAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAuditoriaInclude<ExtArgs> | null
    where?: EventoAuditoriaWhereInput
    orderBy?: EventoAuditoriaOrderByWithRelationInput | EventoAuditoriaOrderByWithRelationInput[]
    cursor?: EventoAuditoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventoAuditoriaScalarFieldEnum | EventoAuditoriaScalarFieldEnum[]
  }

  /**
   * Usuario.decisiones
   */
  export type Usuario$decisionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decision
     */
    select?: DecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionInclude<ExtArgs> | null
    where?: DecisionWhereInput
    orderBy?: DecisionOrderByWithRelationInput | DecisionOrderByWithRelationInput[]
    cursor?: DecisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DecisionScalarFieldEnum | DecisionScalarFieldEnum[]
  }

  /**
   * Usuario.tokenRecuperacion
   */
  export type Usuario$tokenRecuperacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRecuperacion
     */
    select?: TokenRecuperacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenRecuperacionInclude<ExtArgs> | null
    where?: TokenRecuperacionWhereInput
    orderBy?: TokenRecuperacionOrderByWithRelationInput | TokenRecuperacionOrderByWithRelationInput[]
    cursor?: TokenRecuperacionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TokenRecuperacionScalarFieldEnum | TokenRecuperacionScalarFieldEnum[]
  }

  /**
   * Usuario.cambiosRol
   */
  export type Usuario$cambiosRolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CambioRol
     */
    select?: CambioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CambioRolInclude<ExtArgs> | null
    where?: CambioRolWhereInput
    orderBy?: CambioRolOrderByWithRelationInput | CambioRolOrderByWithRelationInput[]
    cursor?: CambioRolWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CambioRolScalarFieldEnum | CambioRolScalarFieldEnum[]
  }

  /**
   * Usuario without action
   */
  export type UsuarioDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
  }


  /**
   * Model PasswordHistorial
   */

  export type AggregatePasswordHistorial = {
    _count: PasswordHistorialCountAggregateOutputType | null
    _min: PasswordHistorialMinAggregateOutputType | null
    _max: PasswordHistorialMaxAggregateOutputType | null
  }

  export type PasswordHistorialMinAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    passwordHash: string | null
    creadoEn: Date | null
  }

  export type PasswordHistorialMaxAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    passwordHash: string | null
    creadoEn: Date | null
  }

  export type PasswordHistorialCountAggregateOutputType = {
    id: number
    usuarioId: number
    passwordHash: number
    creadoEn: number
    _all: number
  }


  export type PasswordHistorialMinAggregateInputType = {
    id?: true
    usuarioId?: true
    passwordHash?: true
    creadoEn?: true
  }

  export type PasswordHistorialMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    passwordHash?: true
    creadoEn?: true
  }

  export type PasswordHistorialCountAggregateInputType = {
    id?: true
    usuarioId?: true
    passwordHash?: true
    creadoEn?: true
    _all?: true
  }

  export type PasswordHistorialAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordHistorial to aggregate.
     */
    where?: PasswordHistorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordHistorials to fetch.
     */
    orderBy?: PasswordHistorialOrderByWithRelationInput | PasswordHistorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PasswordHistorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordHistorials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordHistorials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PasswordHistorials
    **/
    _count?: true | PasswordHistorialCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PasswordHistorialMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PasswordHistorialMaxAggregateInputType
  }

  export type GetPasswordHistorialAggregateType<T extends PasswordHistorialAggregateArgs> = {
        [P in keyof T & keyof AggregatePasswordHistorial]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePasswordHistorial[P]>
      : GetScalarType<T[P], AggregatePasswordHistorial[P]>
  }




  export type PasswordHistorialGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PasswordHistorialWhereInput
    orderBy?: PasswordHistorialOrderByWithAggregationInput | PasswordHistorialOrderByWithAggregationInput[]
    by: PasswordHistorialScalarFieldEnum[] | PasswordHistorialScalarFieldEnum
    having?: PasswordHistorialScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PasswordHistorialCountAggregateInputType | true
    _min?: PasswordHistorialMinAggregateInputType
    _max?: PasswordHistorialMaxAggregateInputType
  }

  export type PasswordHistorialGroupByOutputType = {
    id: string
    usuarioId: string
    passwordHash: string
    creadoEn: Date
    _count: PasswordHistorialCountAggregateOutputType | null
    _min: PasswordHistorialMinAggregateOutputType | null
    _max: PasswordHistorialMaxAggregateOutputType | null
  }

  type GetPasswordHistorialGroupByPayload<T extends PasswordHistorialGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PasswordHistorialGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PasswordHistorialGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PasswordHistorialGroupByOutputType[P]>
            : GetScalarType<T[P], PasswordHistorialGroupByOutputType[P]>
        }
      >
    >


  export type PasswordHistorialSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    passwordHash?: boolean
    creadoEn?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordHistorial"]>

  export type PasswordHistorialSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    passwordHash?: boolean
    creadoEn?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["passwordHistorial"]>

  export type PasswordHistorialSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    passwordHash?: boolean
    creadoEn?: boolean
  }

  export type PasswordHistorialInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type PasswordHistorialIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $PasswordHistorialPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PasswordHistorial"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usuarioId: string
      passwordHash: string
      creadoEn: Date
    }, ExtArgs["result"]["passwordHistorial"]>
    composites: {}
  }

  type PasswordHistorialGetPayload<S extends boolean | null | undefined | PasswordHistorialDefaultArgs> = $Result.GetResult<Prisma.$PasswordHistorialPayload, S>

  type PasswordHistorialCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PasswordHistorialFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PasswordHistorialCountAggregateInputType | true
    }

  export interface PasswordHistorialDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PasswordHistorial'], meta: { name: 'PasswordHistorial' } }
    /**
     * Find zero or one PasswordHistorial that matches the filter.
     * @param {PasswordHistorialFindUniqueArgs} args - Arguments to find a PasswordHistorial
     * @example
     * // Get one PasswordHistorial
     * const passwordHistorial = await prisma.passwordHistorial.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PasswordHistorialFindUniqueArgs>(args: SelectSubset<T, PasswordHistorialFindUniqueArgs<ExtArgs>>): Prisma__PasswordHistorialClient<$Result.GetResult<Prisma.$PasswordHistorialPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PasswordHistorial that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PasswordHistorialFindUniqueOrThrowArgs} args - Arguments to find a PasswordHistorial
     * @example
     * // Get one PasswordHistorial
     * const passwordHistorial = await prisma.passwordHistorial.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PasswordHistorialFindUniqueOrThrowArgs>(args: SelectSubset<T, PasswordHistorialFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PasswordHistorialClient<$Result.GetResult<Prisma.$PasswordHistorialPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PasswordHistorial that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistorialFindFirstArgs} args - Arguments to find a PasswordHistorial
     * @example
     * // Get one PasswordHistorial
     * const passwordHistorial = await prisma.passwordHistorial.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PasswordHistorialFindFirstArgs>(args?: SelectSubset<T, PasswordHistorialFindFirstArgs<ExtArgs>>): Prisma__PasswordHistorialClient<$Result.GetResult<Prisma.$PasswordHistorialPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PasswordHistorial that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistorialFindFirstOrThrowArgs} args - Arguments to find a PasswordHistorial
     * @example
     * // Get one PasswordHistorial
     * const passwordHistorial = await prisma.passwordHistorial.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PasswordHistorialFindFirstOrThrowArgs>(args?: SelectSubset<T, PasswordHistorialFindFirstOrThrowArgs<ExtArgs>>): Prisma__PasswordHistorialClient<$Result.GetResult<Prisma.$PasswordHistorialPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PasswordHistorials that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistorialFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PasswordHistorials
     * const passwordHistorials = await prisma.passwordHistorial.findMany()
     * 
     * // Get first 10 PasswordHistorials
     * const passwordHistorials = await prisma.passwordHistorial.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const passwordHistorialWithIdOnly = await prisma.passwordHistorial.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PasswordHistorialFindManyArgs>(args?: SelectSubset<T, PasswordHistorialFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordHistorialPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PasswordHistorial.
     * @param {PasswordHistorialCreateArgs} args - Arguments to create a PasswordHistorial.
     * @example
     * // Create one PasswordHistorial
     * const PasswordHistorial = await prisma.passwordHistorial.create({
     *   data: {
     *     // ... data to create a PasswordHistorial
     *   }
     * })
     * 
     */
    create<T extends PasswordHistorialCreateArgs>(args: SelectSubset<T, PasswordHistorialCreateArgs<ExtArgs>>): Prisma__PasswordHistorialClient<$Result.GetResult<Prisma.$PasswordHistorialPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PasswordHistorials.
     * @param {PasswordHistorialCreateManyArgs} args - Arguments to create many PasswordHistorials.
     * @example
     * // Create many PasswordHistorials
     * const passwordHistorial = await prisma.passwordHistorial.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PasswordHistorialCreateManyArgs>(args?: SelectSubset<T, PasswordHistorialCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PasswordHistorials and returns the data saved in the database.
     * @param {PasswordHistorialCreateManyAndReturnArgs} args - Arguments to create many PasswordHistorials.
     * @example
     * // Create many PasswordHistorials
     * const passwordHistorial = await prisma.passwordHistorial.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PasswordHistorials and only return the `id`
     * const passwordHistorialWithIdOnly = await prisma.passwordHistorial.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PasswordHistorialCreateManyAndReturnArgs>(args?: SelectSubset<T, PasswordHistorialCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PasswordHistorialPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PasswordHistorial.
     * @param {PasswordHistorialDeleteArgs} args - Arguments to delete one PasswordHistorial.
     * @example
     * // Delete one PasswordHistorial
     * const PasswordHistorial = await prisma.passwordHistorial.delete({
     *   where: {
     *     // ... filter to delete one PasswordHistorial
     *   }
     * })
     * 
     */
    delete<T extends PasswordHistorialDeleteArgs>(args: SelectSubset<T, PasswordHistorialDeleteArgs<ExtArgs>>): Prisma__PasswordHistorialClient<$Result.GetResult<Prisma.$PasswordHistorialPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PasswordHistorial.
     * @param {PasswordHistorialUpdateArgs} args - Arguments to update one PasswordHistorial.
     * @example
     * // Update one PasswordHistorial
     * const passwordHistorial = await prisma.passwordHistorial.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PasswordHistorialUpdateArgs>(args: SelectSubset<T, PasswordHistorialUpdateArgs<ExtArgs>>): Prisma__PasswordHistorialClient<$Result.GetResult<Prisma.$PasswordHistorialPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PasswordHistorials.
     * @param {PasswordHistorialDeleteManyArgs} args - Arguments to filter PasswordHistorials to delete.
     * @example
     * // Delete a few PasswordHistorials
     * const { count } = await prisma.passwordHistorial.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PasswordHistorialDeleteManyArgs>(args?: SelectSubset<T, PasswordHistorialDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PasswordHistorials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistorialUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PasswordHistorials
     * const passwordHistorial = await prisma.passwordHistorial.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PasswordHistorialUpdateManyArgs>(args: SelectSubset<T, PasswordHistorialUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PasswordHistorial.
     * @param {PasswordHistorialUpsertArgs} args - Arguments to update or create a PasswordHistorial.
     * @example
     * // Update or create a PasswordHistorial
     * const passwordHistorial = await prisma.passwordHistorial.upsert({
     *   create: {
     *     // ... data to create a PasswordHistorial
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PasswordHistorial we want to update
     *   }
     * })
     */
    upsert<T extends PasswordHistorialUpsertArgs>(args: SelectSubset<T, PasswordHistorialUpsertArgs<ExtArgs>>): Prisma__PasswordHistorialClient<$Result.GetResult<Prisma.$PasswordHistorialPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PasswordHistorials.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistorialCountArgs} args - Arguments to filter PasswordHistorials to count.
     * @example
     * // Count the number of PasswordHistorials
     * const count = await prisma.passwordHistorial.count({
     *   where: {
     *     // ... the filter for the PasswordHistorials we want to count
     *   }
     * })
    **/
    count<T extends PasswordHistorialCountArgs>(
      args?: Subset<T, PasswordHistorialCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PasswordHistorialCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PasswordHistorial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistorialAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PasswordHistorialAggregateArgs>(args: Subset<T, PasswordHistorialAggregateArgs>): Prisma.PrismaPromise<GetPasswordHistorialAggregateType<T>>

    /**
     * Group by PasswordHistorial.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PasswordHistorialGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PasswordHistorialGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PasswordHistorialGroupByArgs['orderBy'] }
        : { orderBy?: PasswordHistorialGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PasswordHistorialGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPasswordHistorialGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PasswordHistorial model
   */
  readonly fields: PasswordHistorialFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PasswordHistorial.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PasswordHistorialClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PasswordHistorial model
   */ 
  interface PasswordHistorialFieldRefs {
    readonly id: FieldRef<"PasswordHistorial", 'String'>
    readonly usuarioId: FieldRef<"PasswordHistorial", 'String'>
    readonly passwordHash: FieldRef<"PasswordHistorial", 'String'>
    readonly creadoEn: FieldRef<"PasswordHistorial", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PasswordHistorial findUnique
   */
  export type PasswordHistorialFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistorial
     */
    select?: PasswordHistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistorialInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistorial to fetch.
     */
    where: PasswordHistorialWhereUniqueInput
  }

  /**
   * PasswordHistorial findUniqueOrThrow
   */
  export type PasswordHistorialFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistorial
     */
    select?: PasswordHistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistorialInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistorial to fetch.
     */
    where: PasswordHistorialWhereUniqueInput
  }

  /**
   * PasswordHistorial findFirst
   */
  export type PasswordHistorialFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistorial
     */
    select?: PasswordHistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistorialInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistorial to fetch.
     */
    where?: PasswordHistorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordHistorials to fetch.
     */
    orderBy?: PasswordHistorialOrderByWithRelationInput | PasswordHistorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordHistorials.
     */
    cursor?: PasswordHistorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordHistorials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordHistorials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordHistorials.
     */
    distinct?: PasswordHistorialScalarFieldEnum | PasswordHistorialScalarFieldEnum[]
  }

  /**
   * PasswordHistorial findFirstOrThrow
   */
  export type PasswordHistorialFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistorial
     */
    select?: PasswordHistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistorialInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistorial to fetch.
     */
    where?: PasswordHistorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordHistorials to fetch.
     */
    orderBy?: PasswordHistorialOrderByWithRelationInput | PasswordHistorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PasswordHistorials.
     */
    cursor?: PasswordHistorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordHistorials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordHistorials.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PasswordHistorials.
     */
    distinct?: PasswordHistorialScalarFieldEnum | PasswordHistorialScalarFieldEnum[]
  }

  /**
   * PasswordHistorial findMany
   */
  export type PasswordHistorialFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistorial
     */
    select?: PasswordHistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistorialInclude<ExtArgs> | null
    /**
     * Filter, which PasswordHistorials to fetch.
     */
    where?: PasswordHistorialWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PasswordHistorials to fetch.
     */
    orderBy?: PasswordHistorialOrderByWithRelationInput | PasswordHistorialOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PasswordHistorials.
     */
    cursor?: PasswordHistorialWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PasswordHistorials from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PasswordHistorials.
     */
    skip?: number
    distinct?: PasswordHistorialScalarFieldEnum | PasswordHistorialScalarFieldEnum[]
  }

  /**
   * PasswordHistorial create
   */
  export type PasswordHistorialCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistorial
     */
    select?: PasswordHistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistorialInclude<ExtArgs> | null
    /**
     * The data needed to create a PasswordHistorial.
     */
    data: XOR<PasswordHistorialCreateInput, PasswordHistorialUncheckedCreateInput>
  }

  /**
   * PasswordHistorial createMany
   */
  export type PasswordHistorialCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PasswordHistorials.
     */
    data: PasswordHistorialCreateManyInput | PasswordHistorialCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PasswordHistorial createManyAndReturn
   */
  export type PasswordHistorialCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistorial
     */
    select?: PasswordHistorialSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PasswordHistorials.
     */
    data: PasswordHistorialCreateManyInput | PasswordHistorialCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistorialIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PasswordHistorial update
   */
  export type PasswordHistorialUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistorial
     */
    select?: PasswordHistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistorialInclude<ExtArgs> | null
    /**
     * The data needed to update a PasswordHistorial.
     */
    data: XOR<PasswordHistorialUpdateInput, PasswordHistorialUncheckedUpdateInput>
    /**
     * Choose, which PasswordHistorial to update.
     */
    where: PasswordHistorialWhereUniqueInput
  }

  /**
   * PasswordHistorial updateMany
   */
  export type PasswordHistorialUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PasswordHistorials.
     */
    data: XOR<PasswordHistorialUpdateManyMutationInput, PasswordHistorialUncheckedUpdateManyInput>
    /**
     * Filter which PasswordHistorials to update
     */
    where?: PasswordHistorialWhereInput
  }

  /**
   * PasswordHistorial upsert
   */
  export type PasswordHistorialUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistorial
     */
    select?: PasswordHistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistorialInclude<ExtArgs> | null
    /**
     * The filter to search for the PasswordHistorial to update in case it exists.
     */
    where: PasswordHistorialWhereUniqueInput
    /**
     * In case the PasswordHistorial found by the `where` argument doesn't exist, create a new PasswordHistorial with this data.
     */
    create: XOR<PasswordHistorialCreateInput, PasswordHistorialUncheckedCreateInput>
    /**
     * In case the PasswordHistorial was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PasswordHistorialUpdateInput, PasswordHistorialUncheckedUpdateInput>
  }

  /**
   * PasswordHistorial delete
   */
  export type PasswordHistorialDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistorial
     */
    select?: PasswordHistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistorialInclude<ExtArgs> | null
    /**
     * Filter which PasswordHistorial to delete.
     */
    where: PasswordHistorialWhereUniqueInput
  }

  /**
   * PasswordHistorial deleteMany
   */
  export type PasswordHistorialDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PasswordHistorials to delete
     */
    where?: PasswordHistorialWhereInput
  }

  /**
   * PasswordHistorial without action
   */
  export type PasswordHistorialDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PasswordHistorial
     */
    select?: PasswordHistorialSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PasswordHistorialInclude<ExtArgs> | null
  }


  /**
   * Model TokenRecuperacion
   */

  export type AggregateTokenRecuperacion = {
    _count: TokenRecuperacionCountAggregateOutputType | null
    _min: TokenRecuperacionMinAggregateOutputType | null
    _max: TokenRecuperacionMaxAggregateOutputType | null
  }

  export type TokenRecuperacionMinAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    token: string | null
    expiraEn: Date | null
    usado: boolean | null
    creadoEn: Date | null
  }

  export type TokenRecuperacionMaxAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    token: string | null
    expiraEn: Date | null
    usado: boolean | null
    creadoEn: Date | null
  }

  export type TokenRecuperacionCountAggregateOutputType = {
    id: number
    usuarioId: number
    token: number
    expiraEn: number
    usado: number
    creadoEn: number
    _all: number
  }


  export type TokenRecuperacionMinAggregateInputType = {
    id?: true
    usuarioId?: true
    token?: true
    expiraEn?: true
    usado?: true
    creadoEn?: true
  }

  export type TokenRecuperacionMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    token?: true
    expiraEn?: true
    usado?: true
    creadoEn?: true
  }

  export type TokenRecuperacionCountAggregateInputType = {
    id?: true
    usuarioId?: true
    token?: true
    expiraEn?: true
    usado?: true
    creadoEn?: true
    _all?: true
  }

  export type TokenRecuperacionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenRecuperacion to aggregate.
     */
    where?: TokenRecuperacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenRecuperacions to fetch.
     */
    orderBy?: TokenRecuperacionOrderByWithRelationInput | TokenRecuperacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TokenRecuperacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenRecuperacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenRecuperacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TokenRecuperacions
    **/
    _count?: true | TokenRecuperacionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TokenRecuperacionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TokenRecuperacionMaxAggregateInputType
  }

  export type GetTokenRecuperacionAggregateType<T extends TokenRecuperacionAggregateArgs> = {
        [P in keyof T & keyof AggregateTokenRecuperacion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTokenRecuperacion[P]>
      : GetScalarType<T[P], AggregateTokenRecuperacion[P]>
  }




  export type TokenRecuperacionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TokenRecuperacionWhereInput
    orderBy?: TokenRecuperacionOrderByWithAggregationInput | TokenRecuperacionOrderByWithAggregationInput[]
    by: TokenRecuperacionScalarFieldEnum[] | TokenRecuperacionScalarFieldEnum
    having?: TokenRecuperacionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TokenRecuperacionCountAggregateInputType | true
    _min?: TokenRecuperacionMinAggregateInputType
    _max?: TokenRecuperacionMaxAggregateInputType
  }

  export type TokenRecuperacionGroupByOutputType = {
    id: string
    usuarioId: string
    token: string
    expiraEn: Date
    usado: boolean
    creadoEn: Date
    _count: TokenRecuperacionCountAggregateOutputType | null
    _min: TokenRecuperacionMinAggregateOutputType | null
    _max: TokenRecuperacionMaxAggregateOutputType | null
  }

  type GetTokenRecuperacionGroupByPayload<T extends TokenRecuperacionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TokenRecuperacionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TokenRecuperacionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TokenRecuperacionGroupByOutputType[P]>
            : GetScalarType<T[P], TokenRecuperacionGroupByOutputType[P]>
        }
      >
    >


  export type TokenRecuperacionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    token?: boolean
    expiraEn?: boolean
    usado?: boolean
    creadoEn?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenRecuperacion"]>

  export type TokenRecuperacionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    token?: boolean
    expiraEn?: boolean
    usado?: boolean
    creadoEn?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["tokenRecuperacion"]>

  export type TokenRecuperacionSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    token?: boolean
    expiraEn?: boolean
    usado?: boolean
    creadoEn?: boolean
  }

  export type TokenRecuperacionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type TokenRecuperacionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $TokenRecuperacionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TokenRecuperacion"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usuarioId: string
      token: string
      expiraEn: Date
      usado: boolean
      creadoEn: Date
    }, ExtArgs["result"]["tokenRecuperacion"]>
    composites: {}
  }

  type TokenRecuperacionGetPayload<S extends boolean | null | undefined | TokenRecuperacionDefaultArgs> = $Result.GetResult<Prisma.$TokenRecuperacionPayload, S>

  type TokenRecuperacionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TokenRecuperacionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TokenRecuperacionCountAggregateInputType | true
    }

  export interface TokenRecuperacionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TokenRecuperacion'], meta: { name: 'TokenRecuperacion' } }
    /**
     * Find zero or one TokenRecuperacion that matches the filter.
     * @param {TokenRecuperacionFindUniqueArgs} args - Arguments to find a TokenRecuperacion
     * @example
     * // Get one TokenRecuperacion
     * const tokenRecuperacion = await prisma.tokenRecuperacion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TokenRecuperacionFindUniqueArgs>(args: SelectSubset<T, TokenRecuperacionFindUniqueArgs<ExtArgs>>): Prisma__TokenRecuperacionClient<$Result.GetResult<Prisma.$TokenRecuperacionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TokenRecuperacion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TokenRecuperacionFindUniqueOrThrowArgs} args - Arguments to find a TokenRecuperacion
     * @example
     * // Get one TokenRecuperacion
     * const tokenRecuperacion = await prisma.tokenRecuperacion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TokenRecuperacionFindUniqueOrThrowArgs>(args: SelectSubset<T, TokenRecuperacionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TokenRecuperacionClient<$Result.GetResult<Prisma.$TokenRecuperacionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TokenRecuperacion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRecuperacionFindFirstArgs} args - Arguments to find a TokenRecuperacion
     * @example
     * // Get one TokenRecuperacion
     * const tokenRecuperacion = await prisma.tokenRecuperacion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TokenRecuperacionFindFirstArgs>(args?: SelectSubset<T, TokenRecuperacionFindFirstArgs<ExtArgs>>): Prisma__TokenRecuperacionClient<$Result.GetResult<Prisma.$TokenRecuperacionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TokenRecuperacion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRecuperacionFindFirstOrThrowArgs} args - Arguments to find a TokenRecuperacion
     * @example
     * // Get one TokenRecuperacion
     * const tokenRecuperacion = await prisma.tokenRecuperacion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TokenRecuperacionFindFirstOrThrowArgs>(args?: SelectSubset<T, TokenRecuperacionFindFirstOrThrowArgs<ExtArgs>>): Prisma__TokenRecuperacionClient<$Result.GetResult<Prisma.$TokenRecuperacionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TokenRecuperacions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRecuperacionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TokenRecuperacions
     * const tokenRecuperacions = await prisma.tokenRecuperacion.findMany()
     * 
     * // Get first 10 TokenRecuperacions
     * const tokenRecuperacions = await prisma.tokenRecuperacion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const tokenRecuperacionWithIdOnly = await prisma.tokenRecuperacion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TokenRecuperacionFindManyArgs>(args?: SelectSubset<T, TokenRecuperacionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenRecuperacionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TokenRecuperacion.
     * @param {TokenRecuperacionCreateArgs} args - Arguments to create a TokenRecuperacion.
     * @example
     * // Create one TokenRecuperacion
     * const TokenRecuperacion = await prisma.tokenRecuperacion.create({
     *   data: {
     *     // ... data to create a TokenRecuperacion
     *   }
     * })
     * 
     */
    create<T extends TokenRecuperacionCreateArgs>(args: SelectSubset<T, TokenRecuperacionCreateArgs<ExtArgs>>): Prisma__TokenRecuperacionClient<$Result.GetResult<Prisma.$TokenRecuperacionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TokenRecuperacions.
     * @param {TokenRecuperacionCreateManyArgs} args - Arguments to create many TokenRecuperacions.
     * @example
     * // Create many TokenRecuperacions
     * const tokenRecuperacion = await prisma.tokenRecuperacion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TokenRecuperacionCreateManyArgs>(args?: SelectSubset<T, TokenRecuperacionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TokenRecuperacions and returns the data saved in the database.
     * @param {TokenRecuperacionCreateManyAndReturnArgs} args - Arguments to create many TokenRecuperacions.
     * @example
     * // Create many TokenRecuperacions
     * const tokenRecuperacion = await prisma.tokenRecuperacion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TokenRecuperacions and only return the `id`
     * const tokenRecuperacionWithIdOnly = await prisma.tokenRecuperacion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TokenRecuperacionCreateManyAndReturnArgs>(args?: SelectSubset<T, TokenRecuperacionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TokenRecuperacionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TokenRecuperacion.
     * @param {TokenRecuperacionDeleteArgs} args - Arguments to delete one TokenRecuperacion.
     * @example
     * // Delete one TokenRecuperacion
     * const TokenRecuperacion = await prisma.tokenRecuperacion.delete({
     *   where: {
     *     // ... filter to delete one TokenRecuperacion
     *   }
     * })
     * 
     */
    delete<T extends TokenRecuperacionDeleteArgs>(args: SelectSubset<T, TokenRecuperacionDeleteArgs<ExtArgs>>): Prisma__TokenRecuperacionClient<$Result.GetResult<Prisma.$TokenRecuperacionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TokenRecuperacion.
     * @param {TokenRecuperacionUpdateArgs} args - Arguments to update one TokenRecuperacion.
     * @example
     * // Update one TokenRecuperacion
     * const tokenRecuperacion = await prisma.tokenRecuperacion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TokenRecuperacionUpdateArgs>(args: SelectSubset<T, TokenRecuperacionUpdateArgs<ExtArgs>>): Prisma__TokenRecuperacionClient<$Result.GetResult<Prisma.$TokenRecuperacionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TokenRecuperacions.
     * @param {TokenRecuperacionDeleteManyArgs} args - Arguments to filter TokenRecuperacions to delete.
     * @example
     * // Delete a few TokenRecuperacions
     * const { count } = await prisma.tokenRecuperacion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TokenRecuperacionDeleteManyArgs>(args?: SelectSubset<T, TokenRecuperacionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TokenRecuperacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRecuperacionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TokenRecuperacions
     * const tokenRecuperacion = await prisma.tokenRecuperacion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TokenRecuperacionUpdateManyArgs>(args: SelectSubset<T, TokenRecuperacionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TokenRecuperacion.
     * @param {TokenRecuperacionUpsertArgs} args - Arguments to update or create a TokenRecuperacion.
     * @example
     * // Update or create a TokenRecuperacion
     * const tokenRecuperacion = await prisma.tokenRecuperacion.upsert({
     *   create: {
     *     // ... data to create a TokenRecuperacion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TokenRecuperacion we want to update
     *   }
     * })
     */
    upsert<T extends TokenRecuperacionUpsertArgs>(args: SelectSubset<T, TokenRecuperacionUpsertArgs<ExtArgs>>): Prisma__TokenRecuperacionClient<$Result.GetResult<Prisma.$TokenRecuperacionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TokenRecuperacions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRecuperacionCountArgs} args - Arguments to filter TokenRecuperacions to count.
     * @example
     * // Count the number of TokenRecuperacions
     * const count = await prisma.tokenRecuperacion.count({
     *   where: {
     *     // ... the filter for the TokenRecuperacions we want to count
     *   }
     * })
    **/
    count<T extends TokenRecuperacionCountArgs>(
      args?: Subset<T, TokenRecuperacionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TokenRecuperacionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TokenRecuperacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRecuperacionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TokenRecuperacionAggregateArgs>(args: Subset<T, TokenRecuperacionAggregateArgs>): Prisma.PrismaPromise<GetTokenRecuperacionAggregateType<T>>

    /**
     * Group by TokenRecuperacion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TokenRecuperacionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TokenRecuperacionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TokenRecuperacionGroupByArgs['orderBy'] }
        : { orderBy?: TokenRecuperacionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TokenRecuperacionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTokenRecuperacionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TokenRecuperacion model
   */
  readonly fields: TokenRecuperacionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TokenRecuperacion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TokenRecuperacionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TokenRecuperacion model
   */ 
  interface TokenRecuperacionFieldRefs {
    readonly id: FieldRef<"TokenRecuperacion", 'String'>
    readonly usuarioId: FieldRef<"TokenRecuperacion", 'String'>
    readonly token: FieldRef<"TokenRecuperacion", 'String'>
    readonly expiraEn: FieldRef<"TokenRecuperacion", 'DateTime'>
    readonly usado: FieldRef<"TokenRecuperacion", 'Boolean'>
    readonly creadoEn: FieldRef<"TokenRecuperacion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TokenRecuperacion findUnique
   */
  export type TokenRecuperacionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRecuperacion
     */
    select?: TokenRecuperacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenRecuperacionInclude<ExtArgs> | null
    /**
     * Filter, which TokenRecuperacion to fetch.
     */
    where: TokenRecuperacionWhereUniqueInput
  }

  /**
   * TokenRecuperacion findUniqueOrThrow
   */
  export type TokenRecuperacionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRecuperacion
     */
    select?: TokenRecuperacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenRecuperacionInclude<ExtArgs> | null
    /**
     * Filter, which TokenRecuperacion to fetch.
     */
    where: TokenRecuperacionWhereUniqueInput
  }

  /**
   * TokenRecuperacion findFirst
   */
  export type TokenRecuperacionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRecuperacion
     */
    select?: TokenRecuperacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenRecuperacionInclude<ExtArgs> | null
    /**
     * Filter, which TokenRecuperacion to fetch.
     */
    where?: TokenRecuperacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenRecuperacions to fetch.
     */
    orderBy?: TokenRecuperacionOrderByWithRelationInput | TokenRecuperacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenRecuperacions.
     */
    cursor?: TokenRecuperacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenRecuperacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenRecuperacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenRecuperacions.
     */
    distinct?: TokenRecuperacionScalarFieldEnum | TokenRecuperacionScalarFieldEnum[]
  }

  /**
   * TokenRecuperacion findFirstOrThrow
   */
  export type TokenRecuperacionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRecuperacion
     */
    select?: TokenRecuperacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenRecuperacionInclude<ExtArgs> | null
    /**
     * Filter, which TokenRecuperacion to fetch.
     */
    where?: TokenRecuperacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenRecuperacions to fetch.
     */
    orderBy?: TokenRecuperacionOrderByWithRelationInput | TokenRecuperacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TokenRecuperacions.
     */
    cursor?: TokenRecuperacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenRecuperacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenRecuperacions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TokenRecuperacions.
     */
    distinct?: TokenRecuperacionScalarFieldEnum | TokenRecuperacionScalarFieldEnum[]
  }

  /**
   * TokenRecuperacion findMany
   */
  export type TokenRecuperacionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRecuperacion
     */
    select?: TokenRecuperacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenRecuperacionInclude<ExtArgs> | null
    /**
     * Filter, which TokenRecuperacions to fetch.
     */
    where?: TokenRecuperacionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TokenRecuperacions to fetch.
     */
    orderBy?: TokenRecuperacionOrderByWithRelationInput | TokenRecuperacionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TokenRecuperacions.
     */
    cursor?: TokenRecuperacionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TokenRecuperacions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TokenRecuperacions.
     */
    skip?: number
    distinct?: TokenRecuperacionScalarFieldEnum | TokenRecuperacionScalarFieldEnum[]
  }

  /**
   * TokenRecuperacion create
   */
  export type TokenRecuperacionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRecuperacion
     */
    select?: TokenRecuperacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenRecuperacionInclude<ExtArgs> | null
    /**
     * The data needed to create a TokenRecuperacion.
     */
    data: XOR<TokenRecuperacionCreateInput, TokenRecuperacionUncheckedCreateInput>
  }

  /**
   * TokenRecuperacion createMany
   */
  export type TokenRecuperacionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TokenRecuperacions.
     */
    data: TokenRecuperacionCreateManyInput | TokenRecuperacionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TokenRecuperacion createManyAndReturn
   */
  export type TokenRecuperacionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRecuperacion
     */
    select?: TokenRecuperacionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TokenRecuperacions.
     */
    data: TokenRecuperacionCreateManyInput | TokenRecuperacionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenRecuperacionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TokenRecuperacion update
   */
  export type TokenRecuperacionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRecuperacion
     */
    select?: TokenRecuperacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenRecuperacionInclude<ExtArgs> | null
    /**
     * The data needed to update a TokenRecuperacion.
     */
    data: XOR<TokenRecuperacionUpdateInput, TokenRecuperacionUncheckedUpdateInput>
    /**
     * Choose, which TokenRecuperacion to update.
     */
    where: TokenRecuperacionWhereUniqueInput
  }

  /**
   * TokenRecuperacion updateMany
   */
  export type TokenRecuperacionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TokenRecuperacions.
     */
    data: XOR<TokenRecuperacionUpdateManyMutationInput, TokenRecuperacionUncheckedUpdateManyInput>
    /**
     * Filter which TokenRecuperacions to update
     */
    where?: TokenRecuperacionWhereInput
  }

  /**
   * TokenRecuperacion upsert
   */
  export type TokenRecuperacionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRecuperacion
     */
    select?: TokenRecuperacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenRecuperacionInclude<ExtArgs> | null
    /**
     * The filter to search for the TokenRecuperacion to update in case it exists.
     */
    where: TokenRecuperacionWhereUniqueInput
    /**
     * In case the TokenRecuperacion found by the `where` argument doesn't exist, create a new TokenRecuperacion with this data.
     */
    create: XOR<TokenRecuperacionCreateInput, TokenRecuperacionUncheckedCreateInput>
    /**
     * In case the TokenRecuperacion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TokenRecuperacionUpdateInput, TokenRecuperacionUncheckedUpdateInput>
  }

  /**
   * TokenRecuperacion delete
   */
  export type TokenRecuperacionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRecuperacion
     */
    select?: TokenRecuperacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenRecuperacionInclude<ExtArgs> | null
    /**
     * Filter which TokenRecuperacion to delete.
     */
    where: TokenRecuperacionWhereUniqueInput
  }

  /**
   * TokenRecuperacion deleteMany
   */
  export type TokenRecuperacionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TokenRecuperacions to delete
     */
    where?: TokenRecuperacionWhereInput
  }

  /**
   * TokenRecuperacion without action
   */
  export type TokenRecuperacionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TokenRecuperacion
     */
    select?: TokenRecuperacionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TokenRecuperacionInclude<ExtArgs> | null
  }


  /**
   * Model Sesion
   */

  export type AggregateSesion = {
    _count: SesionCountAggregateOutputType | null
    _min: SesionMinAggregateOutputType | null
    _max: SesionMaxAggregateOutputType | null
  }

  export type SesionMinAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    tokenHash: string | null
    ipAddress: string | null
    userAgent: string | null
    expiraEn: Date | null
    creadoEn: Date | null
    ultimaActividad: Date | null
  }

  export type SesionMaxAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    tokenHash: string | null
    ipAddress: string | null
    userAgent: string | null
    expiraEn: Date | null
    creadoEn: Date | null
    ultimaActividad: Date | null
  }

  export type SesionCountAggregateOutputType = {
    id: number
    usuarioId: number
    tokenHash: number
    ipAddress: number
    userAgent: number
    expiraEn: number
    creadoEn: number
    ultimaActividad: number
    _all: number
  }


  export type SesionMinAggregateInputType = {
    id?: true
    usuarioId?: true
    tokenHash?: true
    ipAddress?: true
    userAgent?: true
    expiraEn?: true
    creadoEn?: true
    ultimaActividad?: true
  }

  export type SesionMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    tokenHash?: true
    ipAddress?: true
    userAgent?: true
    expiraEn?: true
    creadoEn?: true
    ultimaActividad?: true
  }

  export type SesionCountAggregateInputType = {
    id?: true
    usuarioId?: true
    tokenHash?: true
    ipAddress?: true
    userAgent?: true
    expiraEn?: true
    creadoEn?: true
    ultimaActividad?: true
    _all?: true
  }

  export type SesionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sesion to aggregate.
     */
    where?: SesionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sesions to fetch.
     */
    orderBy?: SesionOrderByWithRelationInput | SesionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SesionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sesions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sesions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Sesions
    **/
    _count?: true | SesionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SesionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SesionMaxAggregateInputType
  }

  export type GetSesionAggregateType<T extends SesionAggregateArgs> = {
        [P in keyof T & keyof AggregateSesion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSesion[P]>
      : GetScalarType<T[P], AggregateSesion[P]>
  }




  export type SesionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SesionWhereInput
    orderBy?: SesionOrderByWithAggregationInput | SesionOrderByWithAggregationInput[]
    by: SesionScalarFieldEnum[] | SesionScalarFieldEnum
    having?: SesionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SesionCountAggregateInputType | true
    _min?: SesionMinAggregateInputType
    _max?: SesionMaxAggregateInputType
  }

  export type SesionGroupByOutputType = {
    id: string
    usuarioId: string
    tokenHash: string
    ipAddress: string
    userAgent: string
    expiraEn: Date
    creadoEn: Date
    ultimaActividad: Date
    _count: SesionCountAggregateOutputType | null
    _min: SesionMinAggregateOutputType | null
    _max: SesionMaxAggregateOutputType | null
  }

  type GetSesionGroupByPayload<T extends SesionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SesionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SesionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SesionGroupByOutputType[P]>
            : GetScalarType<T[P], SesionGroupByOutputType[P]>
        }
      >
    >


  export type SesionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    tokenHash?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiraEn?: boolean
    creadoEn?: boolean
    ultimaActividad?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sesion"]>

  export type SesionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    tokenHash?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiraEn?: boolean
    creadoEn?: boolean
    ultimaActividad?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sesion"]>

  export type SesionSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    tokenHash?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    expiraEn?: boolean
    creadoEn?: boolean
    ultimaActividad?: boolean
  }

  export type SesionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type SesionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $SesionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Sesion"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usuarioId: string
      tokenHash: string
      ipAddress: string
      userAgent: string
      expiraEn: Date
      creadoEn: Date
      ultimaActividad: Date
    }, ExtArgs["result"]["sesion"]>
    composites: {}
  }

  type SesionGetPayload<S extends boolean | null | undefined | SesionDefaultArgs> = $Result.GetResult<Prisma.$SesionPayload, S>

  type SesionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SesionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SesionCountAggregateInputType | true
    }

  export interface SesionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Sesion'], meta: { name: 'Sesion' } }
    /**
     * Find zero or one Sesion that matches the filter.
     * @param {SesionFindUniqueArgs} args - Arguments to find a Sesion
     * @example
     * // Get one Sesion
     * const sesion = await prisma.sesion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SesionFindUniqueArgs>(args: SelectSubset<T, SesionFindUniqueArgs<ExtArgs>>): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Sesion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SesionFindUniqueOrThrowArgs} args - Arguments to find a Sesion
     * @example
     * // Get one Sesion
     * const sesion = await prisma.sesion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SesionFindUniqueOrThrowArgs>(args: SelectSubset<T, SesionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Sesion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionFindFirstArgs} args - Arguments to find a Sesion
     * @example
     * // Get one Sesion
     * const sesion = await prisma.sesion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SesionFindFirstArgs>(args?: SelectSubset<T, SesionFindFirstArgs<ExtArgs>>): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Sesion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionFindFirstOrThrowArgs} args - Arguments to find a Sesion
     * @example
     * // Get one Sesion
     * const sesion = await prisma.sesion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SesionFindFirstOrThrowArgs>(args?: SelectSubset<T, SesionFindFirstOrThrowArgs<ExtArgs>>): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Sesions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Sesions
     * const sesions = await prisma.sesion.findMany()
     * 
     * // Get first 10 Sesions
     * const sesions = await prisma.sesion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sesionWithIdOnly = await prisma.sesion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SesionFindManyArgs>(args?: SelectSubset<T, SesionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Sesion.
     * @param {SesionCreateArgs} args - Arguments to create a Sesion.
     * @example
     * // Create one Sesion
     * const Sesion = await prisma.sesion.create({
     *   data: {
     *     // ... data to create a Sesion
     *   }
     * })
     * 
     */
    create<T extends SesionCreateArgs>(args: SelectSubset<T, SesionCreateArgs<ExtArgs>>): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Sesions.
     * @param {SesionCreateManyArgs} args - Arguments to create many Sesions.
     * @example
     * // Create many Sesions
     * const sesion = await prisma.sesion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SesionCreateManyArgs>(args?: SelectSubset<T, SesionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Sesions and returns the data saved in the database.
     * @param {SesionCreateManyAndReturnArgs} args - Arguments to create many Sesions.
     * @example
     * // Create many Sesions
     * const sesion = await prisma.sesion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Sesions and only return the `id`
     * const sesionWithIdOnly = await prisma.sesion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SesionCreateManyAndReturnArgs>(args?: SelectSubset<T, SesionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Sesion.
     * @param {SesionDeleteArgs} args - Arguments to delete one Sesion.
     * @example
     * // Delete one Sesion
     * const Sesion = await prisma.sesion.delete({
     *   where: {
     *     // ... filter to delete one Sesion
     *   }
     * })
     * 
     */
    delete<T extends SesionDeleteArgs>(args: SelectSubset<T, SesionDeleteArgs<ExtArgs>>): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Sesion.
     * @param {SesionUpdateArgs} args - Arguments to update one Sesion.
     * @example
     * // Update one Sesion
     * const sesion = await prisma.sesion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SesionUpdateArgs>(args: SelectSubset<T, SesionUpdateArgs<ExtArgs>>): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Sesions.
     * @param {SesionDeleteManyArgs} args - Arguments to filter Sesions to delete.
     * @example
     * // Delete a few Sesions
     * const { count } = await prisma.sesion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SesionDeleteManyArgs>(args?: SelectSubset<T, SesionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Sesions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Sesions
     * const sesion = await prisma.sesion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SesionUpdateManyArgs>(args: SelectSubset<T, SesionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Sesion.
     * @param {SesionUpsertArgs} args - Arguments to update or create a Sesion.
     * @example
     * // Update or create a Sesion
     * const sesion = await prisma.sesion.upsert({
     *   create: {
     *     // ... data to create a Sesion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Sesion we want to update
     *   }
     * })
     */
    upsert<T extends SesionUpsertArgs>(args: SelectSubset<T, SesionUpsertArgs<ExtArgs>>): Prisma__SesionClient<$Result.GetResult<Prisma.$SesionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Sesions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionCountArgs} args - Arguments to filter Sesions to count.
     * @example
     * // Count the number of Sesions
     * const count = await prisma.sesion.count({
     *   where: {
     *     // ... the filter for the Sesions we want to count
     *   }
     * })
    **/
    count<T extends SesionCountArgs>(
      args?: Subset<T, SesionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SesionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Sesion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SesionAggregateArgs>(args: Subset<T, SesionAggregateArgs>): Prisma.PrismaPromise<GetSesionAggregateType<T>>

    /**
     * Group by Sesion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SesionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SesionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SesionGroupByArgs['orderBy'] }
        : { orderBy?: SesionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SesionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSesionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Sesion model
   */
  readonly fields: SesionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Sesion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SesionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Sesion model
   */ 
  interface SesionFieldRefs {
    readonly id: FieldRef<"Sesion", 'String'>
    readonly usuarioId: FieldRef<"Sesion", 'String'>
    readonly tokenHash: FieldRef<"Sesion", 'String'>
    readonly ipAddress: FieldRef<"Sesion", 'String'>
    readonly userAgent: FieldRef<"Sesion", 'String'>
    readonly expiraEn: FieldRef<"Sesion", 'DateTime'>
    readonly creadoEn: FieldRef<"Sesion", 'DateTime'>
    readonly ultimaActividad: FieldRef<"Sesion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Sesion findUnique
   */
  export type SesionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    /**
     * Filter, which Sesion to fetch.
     */
    where: SesionWhereUniqueInput
  }

  /**
   * Sesion findUniqueOrThrow
   */
  export type SesionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    /**
     * Filter, which Sesion to fetch.
     */
    where: SesionWhereUniqueInput
  }

  /**
   * Sesion findFirst
   */
  export type SesionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    /**
     * Filter, which Sesion to fetch.
     */
    where?: SesionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sesions to fetch.
     */
    orderBy?: SesionOrderByWithRelationInput | SesionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sesions.
     */
    cursor?: SesionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sesions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sesions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sesions.
     */
    distinct?: SesionScalarFieldEnum | SesionScalarFieldEnum[]
  }

  /**
   * Sesion findFirstOrThrow
   */
  export type SesionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    /**
     * Filter, which Sesion to fetch.
     */
    where?: SesionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sesions to fetch.
     */
    orderBy?: SesionOrderByWithRelationInput | SesionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Sesions.
     */
    cursor?: SesionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sesions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sesions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Sesions.
     */
    distinct?: SesionScalarFieldEnum | SesionScalarFieldEnum[]
  }

  /**
   * Sesion findMany
   */
  export type SesionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    /**
     * Filter, which Sesions to fetch.
     */
    where?: SesionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Sesions to fetch.
     */
    orderBy?: SesionOrderByWithRelationInput | SesionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Sesions.
     */
    cursor?: SesionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Sesions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Sesions.
     */
    skip?: number
    distinct?: SesionScalarFieldEnum | SesionScalarFieldEnum[]
  }

  /**
   * Sesion create
   */
  export type SesionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    /**
     * The data needed to create a Sesion.
     */
    data: XOR<SesionCreateInput, SesionUncheckedCreateInput>
  }

  /**
   * Sesion createMany
   */
  export type SesionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Sesions.
     */
    data: SesionCreateManyInput | SesionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Sesion createManyAndReturn
   */
  export type SesionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Sesions.
     */
    data: SesionCreateManyInput | SesionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Sesion update
   */
  export type SesionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    /**
     * The data needed to update a Sesion.
     */
    data: XOR<SesionUpdateInput, SesionUncheckedUpdateInput>
    /**
     * Choose, which Sesion to update.
     */
    where: SesionWhereUniqueInput
  }

  /**
   * Sesion updateMany
   */
  export type SesionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Sesions.
     */
    data: XOR<SesionUpdateManyMutationInput, SesionUncheckedUpdateManyInput>
    /**
     * Filter which Sesions to update
     */
    where?: SesionWhereInput
  }

  /**
   * Sesion upsert
   */
  export type SesionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    /**
     * The filter to search for the Sesion to update in case it exists.
     */
    where: SesionWhereUniqueInput
    /**
     * In case the Sesion found by the `where` argument doesn't exist, create a new Sesion with this data.
     */
    create: XOR<SesionCreateInput, SesionUncheckedCreateInput>
    /**
     * In case the Sesion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SesionUpdateInput, SesionUncheckedUpdateInput>
  }

  /**
   * Sesion delete
   */
  export type SesionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
    /**
     * Filter which Sesion to delete.
     */
    where: SesionWhereUniqueInput
  }

  /**
   * Sesion deleteMany
   */
  export type SesionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Sesions to delete
     */
    where?: SesionWhereInput
  }

  /**
   * Sesion without action
   */
  export type SesionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Sesion
     */
    select?: SesionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SesionInclude<ExtArgs> | null
  }


  /**
   * Model CambioRol
   */

  export type AggregateCambioRol = {
    _count: CambioRolCountAggregateOutputType | null
    _min: CambioRolMinAggregateOutputType | null
    _max: CambioRolMaxAggregateOutputType | null
  }

  export type CambioRolMinAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    rolAnterior: $Enums.Rol | null
    rolNuevo: $Enums.Rol | null
    motivo: string | null
    cambiadoPorId: string | null
    creadoEn: Date | null
  }

  export type CambioRolMaxAggregateOutputType = {
    id: string | null
    usuarioId: string | null
    rolAnterior: $Enums.Rol | null
    rolNuevo: $Enums.Rol | null
    motivo: string | null
    cambiadoPorId: string | null
    creadoEn: Date | null
  }

  export type CambioRolCountAggregateOutputType = {
    id: number
    usuarioId: number
    rolAnterior: number
    rolNuevo: number
    motivo: number
    cambiadoPorId: number
    creadoEn: number
    _all: number
  }


  export type CambioRolMinAggregateInputType = {
    id?: true
    usuarioId?: true
    rolAnterior?: true
    rolNuevo?: true
    motivo?: true
    cambiadoPorId?: true
    creadoEn?: true
  }

  export type CambioRolMaxAggregateInputType = {
    id?: true
    usuarioId?: true
    rolAnterior?: true
    rolNuevo?: true
    motivo?: true
    cambiadoPorId?: true
    creadoEn?: true
  }

  export type CambioRolCountAggregateInputType = {
    id?: true
    usuarioId?: true
    rolAnterior?: true
    rolNuevo?: true
    motivo?: true
    cambiadoPorId?: true
    creadoEn?: true
    _all?: true
  }

  export type CambioRolAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CambioRol to aggregate.
     */
    where?: CambioRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CambioRols to fetch.
     */
    orderBy?: CambioRolOrderByWithRelationInput | CambioRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CambioRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CambioRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CambioRols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CambioRols
    **/
    _count?: true | CambioRolCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CambioRolMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CambioRolMaxAggregateInputType
  }

  export type GetCambioRolAggregateType<T extends CambioRolAggregateArgs> = {
        [P in keyof T & keyof AggregateCambioRol]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCambioRol[P]>
      : GetScalarType<T[P], AggregateCambioRol[P]>
  }




  export type CambioRolGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CambioRolWhereInput
    orderBy?: CambioRolOrderByWithAggregationInput | CambioRolOrderByWithAggregationInput[]
    by: CambioRolScalarFieldEnum[] | CambioRolScalarFieldEnum
    having?: CambioRolScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CambioRolCountAggregateInputType | true
    _min?: CambioRolMinAggregateInputType
    _max?: CambioRolMaxAggregateInputType
  }

  export type CambioRolGroupByOutputType = {
    id: string
    usuarioId: string
    rolAnterior: $Enums.Rol
    rolNuevo: $Enums.Rol
    motivo: string | null
    cambiadoPorId: string
    creadoEn: Date
    _count: CambioRolCountAggregateOutputType | null
    _min: CambioRolMinAggregateOutputType | null
    _max: CambioRolMaxAggregateOutputType | null
  }

  type GetCambioRolGroupByPayload<T extends CambioRolGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CambioRolGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CambioRolGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CambioRolGroupByOutputType[P]>
            : GetScalarType<T[P], CambioRolGroupByOutputType[P]>
        }
      >
    >


  export type CambioRolSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    rolAnterior?: boolean
    rolNuevo?: boolean
    motivo?: boolean
    cambiadoPorId?: boolean
    creadoEn?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cambioRol"]>

  export type CambioRolSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    usuarioId?: boolean
    rolAnterior?: boolean
    rolNuevo?: boolean
    motivo?: boolean
    cambiadoPorId?: boolean
    creadoEn?: boolean
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cambioRol"]>

  export type CambioRolSelectScalar = {
    id?: boolean
    usuarioId?: boolean
    rolAnterior?: boolean
    rolNuevo?: boolean
    motivo?: boolean
    cambiadoPorId?: boolean
    creadoEn?: boolean
  }

  export type CambioRolInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type CambioRolIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $CambioRolPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CambioRol"
    objects: {
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      usuarioId: string
      rolAnterior: $Enums.Rol
      rolNuevo: $Enums.Rol
      motivo: string | null
      cambiadoPorId: string
      creadoEn: Date
    }, ExtArgs["result"]["cambioRol"]>
    composites: {}
  }

  type CambioRolGetPayload<S extends boolean | null | undefined | CambioRolDefaultArgs> = $Result.GetResult<Prisma.$CambioRolPayload, S>

  type CambioRolCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CambioRolFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CambioRolCountAggregateInputType | true
    }

  export interface CambioRolDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CambioRol'], meta: { name: 'CambioRol' } }
    /**
     * Find zero or one CambioRol that matches the filter.
     * @param {CambioRolFindUniqueArgs} args - Arguments to find a CambioRol
     * @example
     * // Get one CambioRol
     * const cambioRol = await prisma.cambioRol.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CambioRolFindUniqueArgs>(args: SelectSubset<T, CambioRolFindUniqueArgs<ExtArgs>>): Prisma__CambioRolClient<$Result.GetResult<Prisma.$CambioRolPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CambioRol that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CambioRolFindUniqueOrThrowArgs} args - Arguments to find a CambioRol
     * @example
     * // Get one CambioRol
     * const cambioRol = await prisma.cambioRol.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CambioRolFindUniqueOrThrowArgs>(args: SelectSubset<T, CambioRolFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CambioRolClient<$Result.GetResult<Prisma.$CambioRolPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CambioRol that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CambioRolFindFirstArgs} args - Arguments to find a CambioRol
     * @example
     * // Get one CambioRol
     * const cambioRol = await prisma.cambioRol.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CambioRolFindFirstArgs>(args?: SelectSubset<T, CambioRolFindFirstArgs<ExtArgs>>): Prisma__CambioRolClient<$Result.GetResult<Prisma.$CambioRolPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CambioRol that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CambioRolFindFirstOrThrowArgs} args - Arguments to find a CambioRol
     * @example
     * // Get one CambioRol
     * const cambioRol = await prisma.cambioRol.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CambioRolFindFirstOrThrowArgs>(args?: SelectSubset<T, CambioRolFindFirstOrThrowArgs<ExtArgs>>): Prisma__CambioRolClient<$Result.GetResult<Prisma.$CambioRolPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CambioRols that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CambioRolFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CambioRols
     * const cambioRols = await prisma.cambioRol.findMany()
     * 
     * // Get first 10 CambioRols
     * const cambioRols = await prisma.cambioRol.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const cambioRolWithIdOnly = await prisma.cambioRol.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CambioRolFindManyArgs>(args?: SelectSubset<T, CambioRolFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CambioRolPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CambioRol.
     * @param {CambioRolCreateArgs} args - Arguments to create a CambioRol.
     * @example
     * // Create one CambioRol
     * const CambioRol = await prisma.cambioRol.create({
     *   data: {
     *     // ... data to create a CambioRol
     *   }
     * })
     * 
     */
    create<T extends CambioRolCreateArgs>(args: SelectSubset<T, CambioRolCreateArgs<ExtArgs>>): Prisma__CambioRolClient<$Result.GetResult<Prisma.$CambioRolPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CambioRols.
     * @param {CambioRolCreateManyArgs} args - Arguments to create many CambioRols.
     * @example
     * // Create many CambioRols
     * const cambioRol = await prisma.cambioRol.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CambioRolCreateManyArgs>(args?: SelectSubset<T, CambioRolCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CambioRols and returns the data saved in the database.
     * @param {CambioRolCreateManyAndReturnArgs} args - Arguments to create many CambioRols.
     * @example
     * // Create many CambioRols
     * const cambioRol = await prisma.cambioRol.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CambioRols and only return the `id`
     * const cambioRolWithIdOnly = await prisma.cambioRol.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CambioRolCreateManyAndReturnArgs>(args?: SelectSubset<T, CambioRolCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CambioRolPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CambioRol.
     * @param {CambioRolDeleteArgs} args - Arguments to delete one CambioRol.
     * @example
     * // Delete one CambioRol
     * const CambioRol = await prisma.cambioRol.delete({
     *   where: {
     *     // ... filter to delete one CambioRol
     *   }
     * })
     * 
     */
    delete<T extends CambioRolDeleteArgs>(args: SelectSubset<T, CambioRolDeleteArgs<ExtArgs>>): Prisma__CambioRolClient<$Result.GetResult<Prisma.$CambioRolPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CambioRol.
     * @param {CambioRolUpdateArgs} args - Arguments to update one CambioRol.
     * @example
     * // Update one CambioRol
     * const cambioRol = await prisma.cambioRol.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CambioRolUpdateArgs>(args: SelectSubset<T, CambioRolUpdateArgs<ExtArgs>>): Prisma__CambioRolClient<$Result.GetResult<Prisma.$CambioRolPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CambioRols.
     * @param {CambioRolDeleteManyArgs} args - Arguments to filter CambioRols to delete.
     * @example
     * // Delete a few CambioRols
     * const { count } = await prisma.cambioRol.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CambioRolDeleteManyArgs>(args?: SelectSubset<T, CambioRolDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CambioRols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CambioRolUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CambioRols
     * const cambioRol = await prisma.cambioRol.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CambioRolUpdateManyArgs>(args: SelectSubset<T, CambioRolUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CambioRol.
     * @param {CambioRolUpsertArgs} args - Arguments to update or create a CambioRol.
     * @example
     * // Update or create a CambioRol
     * const cambioRol = await prisma.cambioRol.upsert({
     *   create: {
     *     // ... data to create a CambioRol
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CambioRol we want to update
     *   }
     * })
     */
    upsert<T extends CambioRolUpsertArgs>(args: SelectSubset<T, CambioRolUpsertArgs<ExtArgs>>): Prisma__CambioRolClient<$Result.GetResult<Prisma.$CambioRolPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CambioRols.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CambioRolCountArgs} args - Arguments to filter CambioRols to count.
     * @example
     * // Count the number of CambioRols
     * const count = await prisma.cambioRol.count({
     *   where: {
     *     // ... the filter for the CambioRols we want to count
     *   }
     * })
    **/
    count<T extends CambioRolCountArgs>(
      args?: Subset<T, CambioRolCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CambioRolCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CambioRol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CambioRolAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CambioRolAggregateArgs>(args: Subset<T, CambioRolAggregateArgs>): Prisma.PrismaPromise<GetCambioRolAggregateType<T>>

    /**
     * Group by CambioRol.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CambioRolGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CambioRolGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CambioRolGroupByArgs['orderBy'] }
        : { orderBy?: CambioRolGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CambioRolGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCambioRolGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CambioRol model
   */
  readonly fields: CambioRolFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CambioRol.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CambioRolClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CambioRol model
   */ 
  interface CambioRolFieldRefs {
    readonly id: FieldRef<"CambioRol", 'String'>
    readonly usuarioId: FieldRef<"CambioRol", 'String'>
    readonly rolAnterior: FieldRef<"CambioRol", 'Rol'>
    readonly rolNuevo: FieldRef<"CambioRol", 'Rol'>
    readonly motivo: FieldRef<"CambioRol", 'String'>
    readonly cambiadoPorId: FieldRef<"CambioRol", 'String'>
    readonly creadoEn: FieldRef<"CambioRol", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CambioRol findUnique
   */
  export type CambioRolFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CambioRol
     */
    select?: CambioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CambioRolInclude<ExtArgs> | null
    /**
     * Filter, which CambioRol to fetch.
     */
    where: CambioRolWhereUniqueInput
  }

  /**
   * CambioRol findUniqueOrThrow
   */
  export type CambioRolFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CambioRol
     */
    select?: CambioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CambioRolInclude<ExtArgs> | null
    /**
     * Filter, which CambioRol to fetch.
     */
    where: CambioRolWhereUniqueInput
  }

  /**
   * CambioRol findFirst
   */
  export type CambioRolFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CambioRol
     */
    select?: CambioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CambioRolInclude<ExtArgs> | null
    /**
     * Filter, which CambioRol to fetch.
     */
    where?: CambioRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CambioRols to fetch.
     */
    orderBy?: CambioRolOrderByWithRelationInput | CambioRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CambioRols.
     */
    cursor?: CambioRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CambioRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CambioRols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CambioRols.
     */
    distinct?: CambioRolScalarFieldEnum | CambioRolScalarFieldEnum[]
  }

  /**
   * CambioRol findFirstOrThrow
   */
  export type CambioRolFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CambioRol
     */
    select?: CambioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CambioRolInclude<ExtArgs> | null
    /**
     * Filter, which CambioRol to fetch.
     */
    where?: CambioRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CambioRols to fetch.
     */
    orderBy?: CambioRolOrderByWithRelationInput | CambioRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CambioRols.
     */
    cursor?: CambioRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CambioRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CambioRols.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CambioRols.
     */
    distinct?: CambioRolScalarFieldEnum | CambioRolScalarFieldEnum[]
  }

  /**
   * CambioRol findMany
   */
  export type CambioRolFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CambioRol
     */
    select?: CambioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CambioRolInclude<ExtArgs> | null
    /**
     * Filter, which CambioRols to fetch.
     */
    where?: CambioRolWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CambioRols to fetch.
     */
    orderBy?: CambioRolOrderByWithRelationInput | CambioRolOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CambioRols.
     */
    cursor?: CambioRolWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CambioRols from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CambioRols.
     */
    skip?: number
    distinct?: CambioRolScalarFieldEnum | CambioRolScalarFieldEnum[]
  }

  /**
   * CambioRol create
   */
  export type CambioRolCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CambioRol
     */
    select?: CambioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CambioRolInclude<ExtArgs> | null
    /**
     * The data needed to create a CambioRol.
     */
    data: XOR<CambioRolCreateInput, CambioRolUncheckedCreateInput>
  }

  /**
   * CambioRol createMany
   */
  export type CambioRolCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CambioRols.
     */
    data: CambioRolCreateManyInput | CambioRolCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CambioRol createManyAndReturn
   */
  export type CambioRolCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CambioRol
     */
    select?: CambioRolSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CambioRols.
     */
    data: CambioRolCreateManyInput | CambioRolCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CambioRolIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * CambioRol update
   */
  export type CambioRolUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CambioRol
     */
    select?: CambioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CambioRolInclude<ExtArgs> | null
    /**
     * The data needed to update a CambioRol.
     */
    data: XOR<CambioRolUpdateInput, CambioRolUncheckedUpdateInput>
    /**
     * Choose, which CambioRol to update.
     */
    where: CambioRolWhereUniqueInput
  }

  /**
   * CambioRol updateMany
   */
  export type CambioRolUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CambioRols.
     */
    data: XOR<CambioRolUpdateManyMutationInput, CambioRolUncheckedUpdateManyInput>
    /**
     * Filter which CambioRols to update
     */
    where?: CambioRolWhereInput
  }

  /**
   * CambioRol upsert
   */
  export type CambioRolUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CambioRol
     */
    select?: CambioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CambioRolInclude<ExtArgs> | null
    /**
     * The filter to search for the CambioRol to update in case it exists.
     */
    where: CambioRolWhereUniqueInput
    /**
     * In case the CambioRol found by the `where` argument doesn't exist, create a new CambioRol with this data.
     */
    create: XOR<CambioRolCreateInput, CambioRolUncheckedCreateInput>
    /**
     * In case the CambioRol was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CambioRolUpdateInput, CambioRolUncheckedUpdateInput>
  }

  /**
   * CambioRol delete
   */
  export type CambioRolDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CambioRol
     */
    select?: CambioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CambioRolInclude<ExtArgs> | null
    /**
     * Filter which CambioRol to delete.
     */
    where: CambioRolWhereUniqueInput
  }

  /**
   * CambioRol deleteMany
   */
  export type CambioRolDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CambioRols to delete
     */
    where?: CambioRolWhereInput
  }

  /**
   * CambioRol without action
   */
  export type CambioRolDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CambioRol
     */
    select?: CambioRolSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CambioRolInclude<ExtArgs> | null
  }


  /**
   * Model CatalogoDocumento
   */

  export type AggregateCatalogoDocumento = {
    _count: CatalogoDocumentoCountAggregateOutputType | null
    _avg: CatalogoDocumentoAvgAggregateOutputType | null
    _sum: CatalogoDocumentoSumAggregateOutputType | null
    _min: CatalogoDocumentoMinAggregateOutputType | null
    _max: CatalogoDocumentoMaxAggregateOutputType | null
  }

  export type CatalogoDocumentoAvgAggregateOutputType = {
    tamanoMaximoMb: number | null
    vigenciaDias: number | null
    orden: number | null
  }

  export type CatalogoDocumentoSumAggregateOutputType = {
    tamanoMaximoMb: number | null
    vigenciaDias: number | null
    orden: number | null
  }

  export type CatalogoDocumentoMinAggregateOutputType = {
    id: string | null
    tipo: $Enums.TipoDocumento | null
    nombre: string | null
    descripcion: string | null
    obligatorio: boolean | null
    tamanoMaximoMb: number | null
    vigenciaDias: number | null
    activo: boolean | null
    orden: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type CatalogoDocumentoMaxAggregateOutputType = {
    id: string | null
    tipo: $Enums.TipoDocumento | null
    nombre: string | null
    descripcion: string | null
    obligatorio: boolean | null
    tamanoMaximoMb: number | null
    vigenciaDias: number | null
    activo: boolean | null
    orden: number | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type CatalogoDocumentoCountAggregateOutputType = {
    id: number
    tipo: number
    nombre: number
    descripcion: number
    obligatorio: number
    formatosPermitidos: number
    tamanoMaximoMb: number
    vigenciaDias: number
    activo: number
    orden: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type CatalogoDocumentoAvgAggregateInputType = {
    tamanoMaximoMb?: true
    vigenciaDias?: true
    orden?: true
  }

  export type CatalogoDocumentoSumAggregateInputType = {
    tamanoMaximoMb?: true
    vigenciaDias?: true
    orden?: true
  }

  export type CatalogoDocumentoMinAggregateInputType = {
    id?: true
    tipo?: true
    nombre?: true
    descripcion?: true
    obligatorio?: true
    tamanoMaximoMb?: true
    vigenciaDias?: true
    activo?: true
    orden?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type CatalogoDocumentoMaxAggregateInputType = {
    id?: true
    tipo?: true
    nombre?: true
    descripcion?: true
    obligatorio?: true
    tamanoMaximoMb?: true
    vigenciaDias?: true
    activo?: true
    orden?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type CatalogoDocumentoCountAggregateInputType = {
    id?: true
    tipo?: true
    nombre?: true
    descripcion?: true
    obligatorio?: true
    formatosPermitidos?: true
    tamanoMaximoMb?: true
    vigenciaDias?: true
    activo?: true
    orden?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type CatalogoDocumentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogoDocumento to aggregate.
     */
    where?: CatalogoDocumentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogoDocumentos to fetch.
     */
    orderBy?: CatalogoDocumentoOrderByWithRelationInput | CatalogoDocumentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CatalogoDocumentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogoDocumentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogoDocumentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned CatalogoDocumentos
    **/
    _count?: true | CatalogoDocumentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: CatalogoDocumentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: CatalogoDocumentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CatalogoDocumentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CatalogoDocumentoMaxAggregateInputType
  }

  export type GetCatalogoDocumentoAggregateType<T extends CatalogoDocumentoAggregateArgs> = {
        [P in keyof T & keyof AggregateCatalogoDocumento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCatalogoDocumento[P]>
      : GetScalarType<T[P], AggregateCatalogoDocumento[P]>
  }




  export type CatalogoDocumentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CatalogoDocumentoWhereInput
    orderBy?: CatalogoDocumentoOrderByWithAggregationInput | CatalogoDocumentoOrderByWithAggregationInput[]
    by: CatalogoDocumentoScalarFieldEnum[] | CatalogoDocumentoScalarFieldEnum
    having?: CatalogoDocumentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CatalogoDocumentoCountAggregateInputType | true
    _avg?: CatalogoDocumentoAvgAggregateInputType
    _sum?: CatalogoDocumentoSumAggregateInputType
    _min?: CatalogoDocumentoMinAggregateInputType
    _max?: CatalogoDocumentoMaxAggregateInputType
  }

  export type CatalogoDocumentoGroupByOutputType = {
    id: string
    tipo: $Enums.TipoDocumento
    nombre: string
    descripcion: string | null
    obligatorio: boolean
    formatosPermitidos: string[]
    tamanoMaximoMb: number
    vigenciaDias: number | null
    activo: boolean
    orden: number
    creadoEn: Date
    actualizadoEn: Date
    _count: CatalogoDocumentoCountAggregateOutputType | null
    _avg: CatalogoDocumentoAvgAggregateOutputType | null
    _sum: CatalogoDocumentoSumAggregateOutputType | null
    _min: CatalogoDocumentoMinAggregateOutputType | null
    _max: CatalogoDocumentoMaxAggregateOutputType | null
  }

  type GetCatalogoDocumentoGroupByPayload<T extends CatalogoDocumentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CatalogoDocumentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CatalogoDocumentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CatalogoDocumentoGroupByOutputType[P]>
            : GetScalarType<T[P], CatalogoDocumentoGroupByOutputType[P]>
        }
      >
    >


  export type CatalogoDocumentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    nombre?: boolean
    descripcion?: boolean
    obligatorio?: boolean
    formatosPermitidos?: boolean
    tamanoMaximoMb?: boolean
    vigenciaDias?: boolean
    activo?: boolean
    orden?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    documentos?: boolean | CatalogoDocumento$documentosArgs<ExtArgs>
    _count?: boolean | CatalogoDocumentoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["catalogoDocumento"]>

  export type CatalogoDocumentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    tipo?: boolean
    nombre?: boolean
    descripcion?: boolean
    obligatorio?: boolean
    formatosPermitidos?: boolean
    tamanoMaximoMb?: boolean
    vigenciaDias?: boolean
    activo?: boolean
    orden?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["catalogoDocumento"]>

  export type CatalogoDocumentoSelectScalar = {
    id?: boolean
    tipo?: boolean
    nombre?: boolean
    descripcion?: boolean
    obligatorio?: boolean
    formatosPermitidos?: boolean
    tamanoMaximoMb?: boolean
    vigenciaDias?: boolean
    activo?: boolean
    orden?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }

  export type CatalogoDocumentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documentos?: boolean | CatalogoDocumento$documentosArgs<ExtArgs>
    _count?: boolean | CatalogoDocumentoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type CatalogoDocumentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $CatalogoDocumentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "CatalogoDocumento"
    objects: {
      documentos: Prisma.$DocumentoPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      tipo: $Enums.TipoDocumento
      nombre: string
      descripcion: string | null
      obligatorio: boolean
      formatosPermitidos: string[]
      tamanoMaximoMb: number
      vigenciaDias: number | null
      activo: boolean
      orden: number
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["catalogoDocumento"]>
    composites: {}
  }

  type CatalogoDocumentoGetPayload<S extends boolean | null | undefined | CatalogoDocumentoDefaultArgs> = $Result.GetResult<Prisma.$CatalogoDocumentoPayload, S>

  type CatalogoDocumentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CatalogoDocumentoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CatalogoDocumentoCountAggregateInputType | true
    }

  export interface CatalogoDocumentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['CatalogoDocumento'], meta: { name: 'CatalogoDocumento' } }
    /**
     * Find zero or one CatalogoDocumento that matches the filter.
     * @param {CatalogoDocumentoFindUniqueArgs} args - Arguments to find a CatalogoDocumento
     * @example
     * // Get one CatalogoDocumento
     * const catalogoDocumento = await prisma.catalogoDocumento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CatalogoDocumentoFindUniqueArgs>(args: SelectSubset<T, CatalogoDocumentoFindUniqueArgs<ExtArgs>>): Prisma__CatalogoDocumentoClient<$Result.GetResult<Prisma.$CatalogoDocumentoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one CatalogoDocumento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CatalogoDocumentoFindUniqueOrThrowArgs} args - Arguments to find a CatalogoDocumento
     * @example
     * // Get one CatalogoDocumento
     * const catalogoDocumento = await prisma.catalogoDocumento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CatalogoDocumentoFindUniqueOrThrowArgs>(args: SelectSubset<T, CatalogoDocumentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CatalogoDocumentoClient<$Result.GetResult<Prisma.$CatalogoDocumentoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first CatalogoDocumento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoDocumentoFindFirstArgs} args - Arguments to find a CatalogoDocumento
     * @example
     * // Get one CatalogoDocumento
     * const catalogoDocumento = await prisma.catalogoDocumento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CatalogoDocumentoFindFirstArgs>(args?: SelectSubset<T, CatalogoDocumentoFindFirstArgs<ExtArgs>>): Prisma__CatalogoDocumentoClient<$Result.GetResult<Prisma.$CatalogoDocumentoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first CatalogoDocumento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoDocumentoFindFirstOrThrowArgs} args - Arguments to find a CatalogoDocumento
     * @example
     * // Get one CatalogoDocumento
     * const catalogoDocumento = await prisma.catalogoDocumento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CatalogoDocumentoFindFirstOrThrowArgs>(args?: SelectSubset<T, CatalogoDocumentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__CatalogoDocumentoClient<$Result.GetResult<Prisma.$CatalogoDocumentoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more CatalogoDocumentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoDocumentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all CatalogoDocumentos
     * const catalogoDocumentos = await prisma.catalogoDocumento.findMany()
     * 
     * // Get first 10 CatalogoDocumentos
     * const catalogoDocumentos = await prisma.catalogoDocumento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const catalogoDocumentoWithIdOnly = await prisma.catalogoDocumento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CatalogoDocumentoFindManyArgs>(args?: SelectSubset<T, CatalogoDocumentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogoDocumentoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a CatalogoDocumento.
     * @param {CatalogoDocumentoCreateArgs} args - Arguments to create a CatalogoDocumento.
     * @example
     * // Create one CatalogoDocumento
     * const CatalogoDocumento = await prisma.catalogoDocumento.create({
     *   data: {
     *     // ... data to create a CatalogoDocumento
     *   }
     * })
     * 
     */
    create<T extends CatalogoDocumentoCreateArgs>(args: SelectSubset<T, CatalogoDocumentoCreateArgs<ExtArgs>>): Prisma__CatalogoDocumentoClient<$Result.GetResult<Prisma.$CatalogoDocumentoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many CatalogoDocumentos.
     * @param {CatalogoDocumentoCreateManyArgs} args - Arguments to create many CatalogoDocumentos.
     * @example
     * // Create many CatalogoDocumentos
     * const catalogoDocumento = await prisma.catalogoDocumento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CatalogoDocumentoCreateManyArgs>(args?: SelectSubset<T, CatalogoDocumentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many CatalogoDocumentos and returns the data saved in the database.
     * @param {CatalogoDocumentoCreateManyAndReturnArgs} args - Arguments to create many CatalogoDocumentos.
     * @example
     * // Create many CatalogoDocumentos
     * const catalogoDocumento = await prisma.catalogoDocumento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many CatalogoDocumentos and only return the `id`
     * const catalogoDocumentoWithIdOnly = await prisma.catalogoDocumento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends CatalogoDocumentoCreateManyAndReturnArgs>(args?: SelectSubset<T, CatalogoDocumentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CatalogoDocumentoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a CatalogoDocumento.
     * @param {CatalogoDocumentoDeleteArgs} args - Arguments to delete one CatalogoDocumento.
     * @example
     * // Delete one CatalogoDocumento
     * const CatalogoDocumento = await prisma.catalogoDocumento.delete({
     *   where: {
     *     // ... filter to delete one CatalogoDocumento
     *   }
     * })
     * 
     */
    delete<T extends CatalogoDocumentoDeleteArgs>(args: SelectSubset<T, CatalogoDocumentoDeleteArgs<ExtArgs>>): Prisma__CatalogoDocumentoClient<$Result.GetResult<Prisma.$CatalogoDocumentoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one CatalogoDocumento.
     * @param {CatalogoDocumentoUpdateArgs} args - Arguments to update one CatalogoDocumento.
     * @example
     * // Update one CatalogoDocumento
     * const catalogoDocumento = await prisma.catalogoDocumento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CatalogoDocumentoUpdateArgs>(args: SelectSubset<T, CatalogoDocumentoUpdateArgs<ExtArgs>>): Prisma__CatalogoDocumentoClient<$Result.GetResult<Prisma.$CatalogoDocumentoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more CatalogoDocumentos.
     * @param {CatalogoDocumentoDeleteManyArgs} args - Arguments to filter CatalogoDocumentos to delete.
     * @example
     * // Delete a few CatalogoDocumentos
     * const { count } = await prisma.catalogoDocumento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CatalogoDocumentoDeleteManyArgs>(args?: SelectSubset<T, CatalogoDocumentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more CatalogoDocumentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoDocumentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many CatalogoDocumentos
     * const catalogoDocumento = await prisma.catalogoDocumento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CatalogoDocumentoUpdateManyArgs>(args: SelectSubset<T, CatalogoDocumentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one CatalogoDocumento.
     * @param {CatalogoDocumentoUpsertArgs} args - Arguments to update or create a CatalogoDocumento.
     * @example
     * // Update or create a CatalogoDocumento
     * const catalogoDocumento = await prisma.catalogoDocumento.upsert({
     *   create: {
     *     // ... data to create a CatalogoDocumento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the CatalogoDocumento we want to update
     *   }
     * })
     */
    upsert<T extends CatalogoDocumentoUpsertArgs>(args: SelectSubset<T, CatalogoDocumentoUpsertArgs<ExtArgs>>): Prisma__CatalogoDocumentoClient<$Result.GetResult<Prisma.$CatalogoDocumentoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of CatalogoDocumentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoDocumentoCountArgs} args - Arguments to filter CatalogoDocumentos to count.
     * @example
     * // Count the number of CatalogoDocumentos
     * const count = await prisma.catalogoDocumento.count({
     *   where: {
     *     // ... the filter for the CatalogoDocumentos we want to count
     *   }
     * })
    **/
    count<T extends CatalogoDocumentoCountArgs>(
      args?: Subset<T, CatalogoDocumentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CatalogoDocumentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a CatalogoDocumento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoDocumentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CatalogoDocumentoAggregateArgs>(args: Subset<T, CatalogoDocumentoAggregateArgs>): Prisma.PrismaPromise<GetCatalogoDocumentoAggregateType<T>>

    /**
     * Group by CatalogoDocumento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CatalogoDocumentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CatalogoDocumentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CatalogoDocumentoGroupByArgs['orderBy'] }
        : { orderBy?: CatalogoDocumentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CatalogoDocumentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCatalogoDocumentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the CatalogoDocumento model
   */
  readonly fields: CatalogoDocumentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for CatalogoDocumento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CatalogoDocumentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documentos<T extends CatalogoDocumento$documentosArgs<ExtArgs> = {}>(args?: Subset<T, CatalogoDocumento$documentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the CatalogoDocumento model
   */ 
  interface CatalogoDocumentoFieldRefs {
    readonly id: FieldRef<"CatalogoDocumento", 'String'>
    readonly tipo: FieldRef<"CatalogoDocumento", 'TipoDocumento'>
    readonly nombre: FieldRef<"CatalogoDocumento", 'String'>
    readonly descripcion: FieldRef<"CatalogoDocumento", 'String'>
    readonly obligatorio: FieldRef<"CatalogoDocumento", 'Boolean'>
    readonly formatosPermitidos: FieldRef<"CatalogoDocumento", 'String[]'>
    readonly tamanoMaximoMb: FieldRef<"CatalogoDocumento", 'Int'>
    readonly vigenciaDias: FieldRef<"CatalogoDocumento", 'Int'>
    readonly activo: FieldRef<"CatalogoDocumento", 'Boolean'>
    readonly orden: FieldRef<"CatalogoDocumento", 'Int'>
    readonly creadoEn: FieldRef<"CatalogoDocumento", 'DateTime'>
    readonly actualizadoEn: FieldRef<"CatalogoDocumento", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * CatalogoDocumento findUnique
   */
  export type CatalogoDocumentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoDocumento
     */
    select?: CatalogoDocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoDocumentoInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoDocumento to fetch.
     */
    where: CatalogoDocumentoWhereUniqueInput
  }

  /**
   * CatalogoDocumento findUniqueOrThrow
   */
  export type CatalogoDocumentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoDocumento
     */
    select?: CatalogoDocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoDocumentoInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoDocumento to fetch.
     */
    where: CatalogoDocumentoWhereUniqueInput
  }

  /**
   * CatalogoDocumento findFirst
   */
  export type CatalogoDocumentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoDocumento
     */
    select?: CatalogoDocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoDocumentoInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoDocumento to fetch.
     */
    where?: CatalogoDocumentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogoDocumentos to fetch.
     */
    orderBy?: CatalogoDocumentoOrderByWithRelationInput | CatalogoDocumentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogoDocumentos.
     */
    cursor?: CatalogoDocumentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogoDocumentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogoDocumentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogoDocumentos.
     */
    distinct?: CatalogoDocumentoScalarFieldEnum | CatalogoDocumentoScalarFieldEnum[]
  }

  /**
   * CatalogoDocumento findFirstOrThrow
   */
  export type CatalogoDocumentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoDocumento
     */
    select?: CatalogoDocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoDocumentoInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoDocumento to fetch.
     */
    where?: CatalogoDocumentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogoDocumentos to fetch.
     */
    orderBy?: CatalogoDocumentoOrderByWithRelationInput | CatalogoDocumentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for CatalogoDocumentos.
     */
    cursor?: CatalogoDocumentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogoDocumentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogoDocumentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of CatalogoDocumentos.
     */
    distinct?: CatalogoDocumentoScalarFieldEnum | CatalogoDocumentoScalarFieldEnum[]
  }

  /**
   * CatalogoDocumento findMany
   */
  export type CatalogoDocumentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoDocumento
     */
    select?: CatalogoDocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoDocumentoInclude<ExtArgs> | null
    /**
     * Filter, which CatalogoDocumentos to fetch.
     */
    where?: CatalogoDocumentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of CatalogoDocumentos to fetch.
     */
    orderBy?: CatalogoDocumentoOrderByWithRelationInput | CatalogoDocumentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing CatalogoDocumentos.
     */
    cursor?: CatalogoDocumentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` CatalogoDocumentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` CatalogoDocumentos.
     */
    skip?: number
    distinct?: CatalogoDocumentoScalarFieldEnum | CatalogoDocumentoScalarFieldEnum[]
  }

  /**
   * CatalogoDocumento create
   */
  export type CatalogoDocumentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoDocumento
     */
    select?: CatalogoDocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoDocumentoInclude<ExtArgs> | null
    /**
     * The data needed to create a CatalogoDocumento.
     */
    data: XOR<CatalogoDocumentoCreateInput, CatalogoDocumentoUncheckedCreateInput>
  }

  /**
   * CatalogoDocumento createMany
   */
  export type CatalogoDocumentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many CatalogoDocumentos.
     */
    data: CatalogoDocumentoCreateManyInput | CatalogoDocumentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogoDocumento createManyAndReturn
   */
  export type CatalogoDocumentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoDocumento
     */
    select?: CatalogoDocumentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many CatalogoDocumentos.
     */
    data: CatalogoDocumentoCreateManyInput | CatalogoDocumentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * CatalogoDocumento update
   */
  export type CatalogoDocumentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoDocumento
     */
    select?: CatalogoDocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoDocumentoInclude<ExtArgs> | null
    /**
     * The data needed to update a CatalogoDocumento.
     */
    data: XOR<CatalogoDocumentoUpdateInput, CatalogoDocumentoUncheckedUpdateInput>
    /**
     * Choose, which CatalogoDocumento to update.
     */
    where: CatalogoDocumentoWhereUniqueInput
  }

  /**
   * CatalogoDocumento updateMany
   */
  export type CatalogoDocumentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update CatalogoDocumentos.
     */
    data: XOR<CatalogoDocumentoUpdateManyMutationInput, CatalogoDocumentoUncheckedUpdateManyInput>
    /**
     * Filter which CatalogoDocumentos to update
     */
    where?: CatalogoDocumentoWhereInput
  }

  /**
   * CatalogoDocumento upsert
   */
  export type CatalogoDocumentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoDocumento
     */
    select?: CatalogoDocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoDocumentoInclude<ExtArgs> | null
    /**
     * The filter to search for the CatalogoDocumento to update in case it exists.
     */
    where: CatalogoDocumentoWhereUniqueInput
    /**
     * In case the CatalogoDocumento found by the `where` argument doesn't exist, create a new CatalogoDocumento with this data.
     */
    create: XOR<CatalogoDocumentoCreateInput, CatalogoDocumentoUncheckedCreateInput>
    /**
     * In case the CatalogoDocumento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CatalogoDocumentoUpdateInput, CatalogoDocumentoUncheckedUpdateInput>
  }

  /**
   * CatalogoDocumento delete
   */
  export type CatalogoDocumentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoDocumento
     */
    select?: CatalogoDocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoDocumentoInclude<ExtArgs> | null
    /**
     * Filter which CatalogoDocumento to delete.
     */
    where: CatalogoDocumentoWhereUniqueInput
  }

  /**
   * CatalogoDocumento deleteMany
   */
  export type CatalogoDocumentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which CatalogoDocumentos to delete
     */
    where?: CatalogoDocumentoWhereInput
  }

  /**
   * CatalogoDocumento.documentos
   */
  export type CatalogoDocumento$documentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    where?: DocumentoWhereInput
    orderBy?: DocumentoOrderByWithRelationInput | DocumentoOrderByWithRelationInput[]
    cursor?: DocumentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentoScalarFieldEnum | DocumentoScalarFieldEnum[]
  }

  /**
   * CatalogoDocumento without action
   */
  export type CatalogoDocumentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CatalogoDocumento
     */
    select?: CatalogoDocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CatalogoDocumentoInclude<ExtArgs> | null
  }


  /**
   * Model Proceso
   */

  export type AggregateProceso = {
    _count: ProcesoCountAggregateOutputType | null
    _avg: ProcesoAvgAggregateOutputType | null
    _sum: ProcesoSumAggregateOutputType | null
    _min: ProcesoMinAggregateOutputType | null
    _max: ProcesoMaxAggregateOutputType | null
  }

  export type ProcesoAvgAggregateOutputType = {
    pdfVersion: number | null
  }

  export type ProcesoSumAggregateOutputType = {
    pdfVersion: number | null
  }

  export type ProcesoMinAggregateOutputType = {
    id: string | null
    codigo: string | null
    beneficiarioId: string | null
    arrendadorId: string | null
    estado: $Enums.EstadoProceso | null
    pdfPath: string | null
    pdfHash: string | null
    pdfVersion: number | null
    firmado: boolean | null
    firmadoEn: Date | null
    firmadoPorId: string | null
    firmaHash: string | null
    firmaIp: string | null
    firmaUserAgent: string | null
    cerradoEn: Date | null
    cerradoPorId: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    enviadoEn: Date | null
  }

  export type ProcesoMaxAggregateOutputType = {
    id: string | null
    codigo: string | null
    beneficiarioId: string | null
    arrendadorId: string | null
    estado: $Enums.EstadoProceso | null
    pdfPath: string | null
    pdfHash: string | null
    pdfVersion: number | null
    firmado: boolean | null
    firmadoEn: Date | null
    firmadoPorId: string | null
    firmaHash: string | null
    firmaIp: string | null
    firmaUserAgent: string | null
    cerradoEn: Date | null
    cerradoPorId: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
    enviadoEn: Date | null
  }

  export type ProcesoCountAggregateOutputType = {
    id: number
    codigo: number
    beneficiarioId: number
    arrendadorId: number
    estado: number
    formulario: number
    pdfPath: number
    pdfHash: number
    pdfVersion: number
    firmado: number
    firmadoEn: number
    firmadoPorId: number
    firmaHash: number
    firmaIp: number
    firmaUserAgent: number
    cerradoEn: number
    cerradoPorId: number
    creadoEn: number
    actualizadoEn: number
    enviadoEn: number
    _all: number
  }


  export type ProcesoAvgAggregateInputType = {
    pdfVersion?: true
  }

  export type ProcesoSumAggregateInputType = {
    pdfVersion?: true
  }

  export type ProcesoMinAggregateInputType = {
    id?: true
    codigo?: true
    beneficiarioId?: true
    arrendadorId?: true
    estado?: true
    pdfPath?: true
    pdfHash?: true
    pdfVersion?: true
    firmado?: true
    firmadoEn?: true
    firmadoPorId?: true
    firmaHash?: true
    firmaIp?: true
    firmaUserAgent?: true
    cerradoEn?: true
    cerradoPorId?: true
    creadoEn?: true
    actualizadoEn?: true
    enviadoEn?: true
  }

  export type ProcesoMaxAggregateInputType = {
    id?: true
    codigo?: true
    beneficiarioId?: true
    arrendadorId?: true
    estado?: true
    pdfPath?: true
    pdfHash?: true
    pdfVersion?: true
    firmado?: true
    firmadoEn?: true
    firmadoPorId?: true
    firmaHash?: true
    firmaIp?: true
    firmaUserAgent?: true
    cerradoEn?: true
    cerradoPorId?: true
    creadoEn?: true
    actualizadoEn?: true
    enviadoEn?: true
  }

  export type ProcesoCountAggregateInputType = {
    id?: true
    codigo?: true
    beneficiarioId?: true
    arrendadorId?: true
    estado?: true
    formulario?: true
    pdfPath?: true
    pdfHash?: true
    pdfVersion?: true
    firmado?: true
    firmadoEn?: true
    firmadoPorId?: true
    firmaHash?: true
    firmaIp?: true
    firmaUserAgent?: true
    cerradoEn?: true
    cerradoPorId?: true
    creadoEn?: true
    actualizadoEn?: true
    enviadoEn?: true
    _all?: true
  }

  export type ProcesoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Proceso to aggregate.
     */
    where?: ProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procesos to fetch.
     */
    orderBy?: ProcesoOrderByWithRelationInput | ProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Procesos
    **/
    _count?: true | ProcesoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ProcesoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ProcesoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProcesoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProcesoMaxAggregateInputType
  }

  export type GetProcesoAggregateType<T extends ProcesoAggregateArgs> = {
        [P in keyof T & keyof AggregateProceso]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProceso[P]>
      : GetScalarType<T[P], AggregateProceso[P]>
  }




  export type ProcesoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ProcesoWhereInput
    orderBy?: ProcesoOrderByWithAggregationInput | ProcesoOrderByWithAggregationInput[]
    by: ProcesoScalarFieldEnum[] | ProcesoScalarFieldEnum
    having?: ProcesoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProcesoCountAggregateInputType | true
    _avg?: ProcesoAvgAggregateInputType
    _sum?: ProcesoSumAggregateInputType
    _min?: ProcesoMinAggregateInputType
    _max?: ProcesoMaxAggregateInputType
  }

  export type ProcesoGroupByOutputType = {
    id: string
    codigo: string
    beneficiarioId: string
    arrendadorId: string | null
    estado: $Enums.EstadoProceso
    formulario: JsonValue | null
    pdfPath: string | null
    pdfHash: string | null
    pdfVersion: number
    firmado: boolean
    firmadoEn: Date | null
    firmadoPorId: string | null
    firmaHash: string | null
    firmaIp: string | null
    firmaUserAgent: string | null
    cerradoEn: Date | null
    cerradoPorId: string | null
    creadoEn: Date
    actualizadoEn: Date
    enviadoEn: Date | null
    _count: ProcesoCountAggregateOutputType | null
    _avg: ProcesoAvgAggregateOutputType | null
    _sum: ProcesoSumAggregateOutputType | null
    _min: ProcesoMinAggregateOutputType | null
    _max: ProcesoMaxAggregateOutputType | null
  }

  type GetProcesoGroupByPayload<T extends ProcesoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProcesoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProcesoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProcesoGroupByOutputType[P]>
            : GetScalarType<T[P], ProcesoGroupByOutputType[P]>
        }
      >
    >


  export type ProcesoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    beneficiarioId?: boolean
    arrendadorId?: boolean
    estado?: boolean
    formulario?: boolean
    pdfPath?: boolean
    pdfHash?: boolean
    pdfVersion?: boolean
    firmado?: boolean
    firmadoEn?: boolean
    firmadoPorId?: boolean
    firmaHash?: boolean
    firmaIp?: boolean
    firmaUserAgent?: boolean
    cerradoEn?: boolean
    cerradoPorId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    enviadoEn?: boolean
    beneficiario?: boolean | UsuarioDefaultArgs<ExtArgs>
    arrendador?: boolean | Proceso$arrendadorArgs<ExtArgs>
    documentos?: boolean | Proceso$documentosArgs<ExtArgs>
    eventos?: boolean | Proceso$eventosArgs<ExtArgs>
    decisiones?: boolean | Proceso$decisionesArgs<ExtArgs>
    historialPdf?: boolean | Proceso$historialPdfArgs<ExtArgs>
    _count?: boolean | ProcesoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["proceso"]>

  export type ProcesoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    codigo?: boolean
    beneficiarioId?: boolean
    arrendadorId?: boolean
    estado?: boolean
    formulario?: boolean
    pdfPath?: boolean
    pdfHash?: boolean
    pdfVersion?: boolean
    firmado?: boolean
    firmadoEn?: boolean
    firmadoPorId?: boolean
    firmaHash?: boolean
    firmaIp?: boolean
    firmaUserAgent?: boolean
    cerradoEn?: boolean
    cerradoPorId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    enviadoEn?: boolean
    beneficiario?: boolean | UsuarioDefaultArgs<ExtArgs>
    arrendador?: boolean | Proceso$arrendadorArgs<ExtArgs>
  }, ExtArgs["result"]["proceso"]>

  export type ProcesoSelectScalar = {
    id?: boolean
    codigo?: boolean
    beneficiarioId?: boolean
    arrendadorId?: boolean
    estado?: boolean
    formulario?: boolean
    pdfPath?: boolean
    pdfHash?: boolean
    pdfVersion?: boolean
    firmado?: boolean
    firmadoEn?: boolean
    firmadoPorId?: boolean
    firmaHash?: boolean
    firmaIp?: boolean
    firmaUserAgent?: boolean
    cerradoEn?: boolean
    cerradoPorId?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
    enviadoEn?: boolean
  }

  export type ProcesoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    beneficiario?: boolean | UsuarioDefaultArgs<ExtArgs>
    arrendador?: boolean | Proceso$arrendadorArgs<ExtArgs>
    documentos?: boolean | Proceso$documentosArgs<ExtArgs>
    eventos?: boolean | Proceso$eventosArgs<ExtArgs>
    decisiones?: boolean | Proceso$decisionesArgs<ExtArgs>
    historialPdf?: boolean | Proceso$historialPdfArgs<ExtArgs>
    _count?: boolean | ProcesoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ProcesoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    beneficiario?: boolean | UsuarioDefaultArgs<ExtArgs>
    arrendador?: boolean | Proceso$arrendadorArgs<ExtArgs>
  }

  export type $ProcesoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Proceso"
    objects: {
      beneficiario: Prisma.$UsuarioPayload<ExtArgs>
      arrendador: Prisma.$UsuarioPayload<ExtArgs> | null
      documentos: Prisma.$DocumentoPayload<ExtArgs>[]
      eventos: Prisma.$EventoAuditoriaPayload<ExtArgs>[]
      decisiones: Prisma.$DecisionPayload<ExtArgs>[]
      historialPdf: Prisma.$HistorialPdfPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      codigo: string
      beneficiarioId: string
      arrendadorId: string | null
      estado: $Enums.EstadoProceso
      formulario: Prisma.JsonValue | null
      pdfPath: string | null
      pdfHash: string | null
      pdfVersion: number
      firmado: boolean
      firmadoEn: Date | null
      firmadoPorId: string | null
      firmaHash: string | null
      firmaIp: string | null
      firmaUserAgent: string | null
      cerradoEn: Date | null
      cerradoPorId: string | null
      creadoEn: Date
      actualizadoEn: Date
      enviadoEn: Date | null
    }, ExtArgs["result"]["proceso"]>
    composites: {}
  }

  type ProcesoGetPayload<S extends boolean | null | undefined | ProcesoDefaultArgs> = $Result.GetResult<Prisma.$ProcesoPayload, S>

  type ProcesoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ProcesoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ProcesoCountAggregateInputType | true
    }

  export interface ProcesoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Proceso'], meta: { name: 'Proceso' } }
    /**
     * Find zero or one Proceso that matches the filter.
     * @param {ProcesoFindUniqueArgs} args - Arguments to find a Proceso
     * @example
     * // Get one Proceso
     * const proceso = await prisma.proceso.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ProcesoFindUniqueArgs>(args: SelectSubset<T, ProcesoFindUniqueArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Proceso that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ProcesoFindUniqueOrThrowArgs} args - Arguments to find a Proceso
     * @example
     * // Get one Proceso
     * const proceso = await prisma.proceso.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ProcesoFindUniqueOrThrowArgs>(args: SelectSubset<T, ProcesoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Proceso that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoFindFirstArgs} args - Arguments to find a Proceso
     * @example
     * // Get one Proceso
     * const proceso = await prisma.proceso.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ProcesoFindFirstArgs>(args?: SelectSubset<T, ProcesoFindFirstArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Proceso that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoFindFirstOrThrowArgs} args - Arguments to find a Proceso
     * @example
     * // Get one Proceso
     * const proceso = await prisma.proceso.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ProcesoFindFirstOrThrowArgs>(args?: SelectSubset<T, ProcesoFindFirstOrThrowArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Procesos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Procesos
     * const procesos = await prisma.proceso.findMany()
     * 
     * // Get first 10 Procesos
     * const procesos = await prisma.proceso.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const procesoWithIdOnly = await prisma.proceso.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ProcesoFindManyArgs>(args?: SelectSubset<T, ProcesoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Proceso.
     * @param {ProcesoCreateArgs} args - Arguments to create a Proceso.
     * @example
     * // Create one Proceso
     * const Proceso = await prisma.proceso.create({
     *   data: {
     *     // ... data to create a Proceso
     *   }
     * })
     * 
     */
    create<T extends ProcesoCreateArgs>(args: SelectSubset<T, ProcesoCreateArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Procesos.
     * @param {ProcesoCreateManyArgs} args - Arguments to create many Procesos.
     * @example
     * // Create many Procesos
     * const proceso = await prisma.proceso.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ProcesoCreateManyArgs>(args?: SelectSubset<T, ProcesoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Procesos and returns the data saved in the database.
     * @param {ProcesoCreateManyAndReturnArgs} args - Arguments to create many Procesos.
     * @example
     * // Create many Procesos
     * const proceso = await prisma.proceso.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Procesos and only return the `id`
     * const procesoWithIdOnly = await prisma.proceso.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ProcesoCreateManyAndReturnArgs>(args?: SelectSubset<T, ProcesoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Proceso.
     * @param {ProcesoDeleteArgs} args - Arguments to delete one Proceso.
     * @example
     * // Delete one Proceso
     * const Proceso = await prisma.proceso.delete({
     *   where: {
     *     // ... filter to delete one Proceso
     *   }
     * })
     * 
     */
    delete<T extends ProcesoDeleteArgs>(args: SelectSubset<T, ProcesoDeleteArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Proceso.
     * @param {ProcesoUpdateArgs} args - Arguments to update one Proceso.
     * @example
     * // Update one Proceso
     * const proceso = await prisma.proceso.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ProcesoUpdateArgs>(args: SelectSubset<T, ProcesoUpdateArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Procesos.
     * @param {ProcesoDeleteManyArgs} args - Arguments to filter Procesos to delete.
     * @example
     * // Delete a few Procesos
     * const { count } = await prisma.proceso.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ProcesoDeleteManyArgs>(args?: SelectSubset<T, ProcesoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Procesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Procesos
     * const proceso = await prisma.proceso.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ProcesoUpdateManyArgs>(args: SelectSubset<T, ProcesoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Proceso.
     * @param {ProcesoUpsertArgs} args - Arguments to update or create a Proceso.
     * @example
     * // Update or create a Proceso
     * const proceso = await prisma.proceso.upsert({
     *   create: {
     *     // ... data to create a Proceso
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Proceso we want to update
     *   }
     * })
     */
    upsert<T extends ProcesoUpsertArgs>(args: SelectSubset<T, ProcesoUpsertArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Procesos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoCountArgs} args - Arguments to filter Procesos to count.
     * @example
     * // Count the number of Procesos
     * const count = await prisma.proceso.count({
     *   where: {
     *     // ... the filter for the Procesos we want to count
     *   }
     * })
    **/
    count<T extends ProcesoCountArgs>(
      args?: Subset<T, ProcesoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProcesoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Proceso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProcesoAggregateArgs>(args: Subset<T, ProcesoAggregateArgs>): Prisma.PrismaPromise<GetProcesoAggregateType<T>>

    /**
     * Group by Proceso.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProcesoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ProcesoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ProcesoGroupByArgs['orderBy'] }
        : { orderBy?: ProcesoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ProcesoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProcesoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Proceso model
   */
  readonly fields: ProcesoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Proceso.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ProcesoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    beneficiario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    arrendador<T extends Proceso$arrendadorArgs<ExtArgs> = {}>(args?: Subset<T, Proceso$arrendadorArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    documentos<T extends Proceso$documentosArgs<ExtArgs> = {}>(args?: Subset<T, Proceso$documentosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findMany"> | Null>
    eventos<T extends Proceso$eventosArgs<ExtArgs> = {}>(args?: Subset<T, Proceso$eventosArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoAuditoriaPayload<ExtArgs>, T, "findMany"> | Null>
    decisiones<T extends Proceso$decisionesArgs<ExtArgs> = {}>(args?: Subset<T, Proceso$decisionesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionPayload<ExtArgs>, T, "findMany"> | Null>
    historialPdf<T extends Proceso$historialPdfArgs<ExtArgs> = {}>(args?: Subset<T, Proceso$historialPdfArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialPdfPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Proceso model
   */ 
  interface ProcesoFieldRefs {
    readonly id: FieldRef<"Proceso", 'String'>
    readonly codigo: FieldRef<"Proceso", 'String'>
    readonly beneficiarioId: FieldRef<"Proceso", 'String'>
    readonly arrendadorId: FieldRef<"Proceso", 'String'>
    readonly estado: FieldRef<"Proceso", 'EstadoProceso'>
    readonly formulario: FieldRef<"Proceso", 'Json'>
    readonly pdfPath: FieldRef<"Proceso", 'String'>
    readonly pdfHash: FieldRef<"Proceso", 'String'>
    readonly pdfVersion: FieldRef<"Proceso", 'Int'>
    readonly firmado: FieldRef<"Proceso", 'Boolean'>
    readonly firmadoEn: FieldRef<"Proceso", 'DateTime'>
    readonly firmadoPorId: FieldRef<"Proceso", 'String'>
    readonly firmaHash: FieldRef<"Proceso", 'String'>
    readonly firmaIp: FieldRef<"Proceso", 'String'>
    readonly firmaUserAgent: FieldRef<"Proceso", 'String'>
    readonly cerradoEn: FieldRef<"Proceso", 'DateTime'>
    readonly cerradoPorId: FieldRef<"Proceso", 'String'>
    readonly creadoEn: FieldRef<"Proceso", 'DateTime'>
    readonly actualizadoEn: FieldRef<"Proceso", 'DateTime'>
    readonly enviadoEn: FieldRef<"Proceso", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Proceso findUnique
   */
  export type ProcesoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    /**
     * Filter, which Proceso to fetch.
     */
    where: ProcesoWhereUniqueInput
  }

  /**
   * Proceso findUniqueOrThrow
   */
  export type ProcesoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    /**
     * Filter, which Proceso to fetch.
     */
    where: ProcesoWhereUniqueInput
  }

  /**
   * Proceso findFirst
   */
  export type ProcesoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    /**
     * Filter, which Proceso to fetch.
     */
    where?: ProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procesos to fetch.
     */
    orderBy?: ProcesoOrderByWithRelationInput | ProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procesos.
     */
    cursor?: ProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procesos.
     */
    distinct?: ProcesoScalarFieldEnum | ProcesoScalarFieldEnum[]
  }

  /**
   * Proceso findFirstOrThrow
   */
  export type ProcesoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    /**
     * Filter, which Proceso to fetch.
     */
    where?: ProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procesos to fetch.
     */
    orderBy?: ProcesoOrderByWithRelationInput | ProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Procesos.
     */
    cursor?: ProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procesos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Procesos.
     */
    distinct?: ProcesoScalarFieldEnum | ProcesoScalarFieldEnum[]
  }

  /**
   * Proceso findMany
   */
  export type ProcesoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    /**
     * Filter, which Procesos to fetch.
     */
    where?: ProcesoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Procesos to fetch.
     */
    orderBy?: ProcesoOrderByWithRelationInput | ProcesoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Procesos.
     */
    cursor?: ProcesoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Procesos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Procesos.
     */
    skip?: number
    distinct?: ProcesoScalarFieldEnum | ProcesoScalarFieldEnum[]
  }

  /**
   * Proceso create
   */
  export type ProcesoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    /**
     * The data needed to create a Proceso.
     */
    data: XOR<ProcesoCreateInput, ProcesoUncheckedCreateInput>
  }

  /**
   * Proceso createMany
   */
  export type ProcesoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Procesos.
     */
    data: ProcesoCreateManyInput | ProcesoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Proceso createManyAndReturn
   */
  export type ProcesoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Procesos.
     */
    data: ProcesoCreateManyInput | ProcesoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Proceso update
   */
  export type ProcesoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    /**
     * The data needed to update a Proceso.
     */
    data: XOR<ProcesoUpdateInput, ProcesoUncheckedUpdateInput>
    /**
     * Choose, which Proceso to update.
     */
    where: ProcesoWhereUniqueInput
  }

  /**
   * Proceso updateMany
   */
  export type ProcesoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Procesos.
     */
    data: XOR<ProcesoUpdateManyMutationInput, ProcesoUncheckedUpdateManyInput>
    /**
     * Filter which Procesos to update
     */
    where?: ProcesoWhereInput
  }

  /**
   * Proceso upsert
   */
  export type ProcesoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    /**
     * The filter to search for the Proceso to update in case it exists.
     */
    where: ProcesoWhereUniqueInput
    /**
     * In case the Proceso found by the `where` argument doesn't exist, create a new Proceso with this data.
     */
    create: XOR<ProcesoCreateInput, ProcesoUncheckedCreateInput>
    /**
     * In case the Proceso was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ProcesoUpdateInput, ProcesoUncheckedUpdateInput>
  }

  /**
   * Proceso delete
   */
  export type ProcesoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    /**
     * Filter which Proceso to delete.
     */
    where: ProcesoWhereUniqueInput
  }

  /**
   * Proceso deleteMany
   */
  export type ProcesoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Procesos to delete
     */
    where?: ProcesoWhereInput
  }

  /**
   * Proceso.arrendador
   */
  export type Proceso$arrendadorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
  }

  /**
   * Proceso.documentos
   */
  export type Proceso$documentosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    where?: DocumentoWhereInput
    orderBy?: DocumentoOrderByWithRelationInput | DocumentoOrderByWithRelationInput[]
    cursor?: DocumentoWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DocumentoScalarFieldEnum | DocumentoScalarFieldEnum[]
  }

  /**
   * Proceso.eventos
   */
  export type Proceso$eventosArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAuditoria
     */
    select?: EventoAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAuditoriaInclude<ExtArgs> | null
    where?: EventoAuditoriaWhereInput
    orderBy?: EventoAuditoriaOrderByWithRelationInput | EventoAuditoriaOrderByWithRelationInput[]
    cursor?: EventoAuditoriaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventoAuditoriaScalarFieldEnum | EventoAuditoriaScalarFieldEnum[]
  }

  /**
   * Proceso.decisiones
   */
  export type Proceso$decisionesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decision
     */
    select?: DecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionInclude<ExtArgs> | null
    where?: DecisionWhereInput
    orderBy?: DecisionOrderByWithRelationInput | DecisionOrderByWithRelationInput[]
    cursor?: DecisionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DecisionScalarFieldEnum | DecisionScalarFieldEnum[]
  }

  /**
   * Proceso.historialPdf
   */
  export type Proceso$historialPdfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPdf
     */
    select?: HistorialPdfSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPdfInclude<ExtArgs> | null
    where?: HistorialPdfWhereInput
    orderBy?: HistorialPdfOrderByWithRelationInput | HistorialPdfOrderByWithRelationInput[]
    cursor?: HistorialPdfWhereUniqueInput
    take?: number
    skip?: number
    distinct?: HistorialPdfScalarFieldEnum | HistorialPdfScalarFieldEnum[]
  }

  /**
   * Proceso without action
   */
  export type ProcesoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
  }


  /**
   * Model Documento
   */

  export type AggregateDocumento = {
    _count: DocumentoCountAggregateOutputType | null
    _avg: DocumentoAvgAggregateOutputType | null
    _sum: DocumentoSumAggregateOutputType | null
    _min: DocumentoMinAggregateOutputType | null
    _max: DocumentoMaxAggregateOutputType | null
  }

  export type DocumentoAvgAggregateOutputType = {
    tamanoBytes: number | null
    version: number | null
  }

  export type DocumentoSumAggregateOutputType = {
    tamanoBytes: number | null
    version: number | null
  }

  export type DocumentoMinAggregateOutputType = {
    id: string | null
    procesoId: string | null
    catalogoId: string | null
    nombreOriginal: string | null
    nombreAlmacenado: string | null
    rutaArchivo: string | null
    mimeType: string | null
    tamanoBytes: number | null
    hashArchivo: string | null
    estado: $Enums.EstadoDocumento | null
    validadoPorId: string | null
    validadoEn: Date | null
    motivoRechazo: string | null
    version: number | null
    esActivo: boolean | null
    creadoEn: Date | null
    cargadoPorId: string | null
  }

  export type DocumentoMaxAggregateOutputType = {
    id: string | null
    procesoId: string | null
    catalogoId: string | null
    nombreOriginal: string | null
    nombreAlmacenado: string | null
    rutaArchivo: string | null
    mimeType: string | null
    tamanoBytes: number | null
    hashArchivo: string | null
    estado: $Enums.EstadoDocumento | null
    validadoPorId: string | null
    validadoEn: Date | null
    motivoRechazo: string | null
    version: number | null
    esActivo: boolean | null
    creadoEn: Date | null
    cargadoPorId: string | null
  }

  export type DocumentoCountAggregateOutputType = {
    id: number
    procesoId: number
    catalogoId: number
    nombreOriginal: number
    nombreAlmacenado: number
    rutaArchivo: number
    mimeType: number
    tamanoBytes: number
    hashArchivo: number
    estado: number
    validadoPorId: number
    validadoEn: number
    motivoRechazo: number
    version: number
    esActivo: number
    creadoEn: number
    cargadoPorId: number
    _all: number
  }


  export type DocumentoAvgAggregateInputType = {
    tamanoBytes?: true
    version?: true
  }

  export type DocumentoSumAggregateInputType = {
    tamanoBytes?: true
    version?: true
  }

  export type DocumentoMinAggregateInputType = {
    id?: true
    procesoId?: true
    catalogoId?: true
    nombreOriginal?: true
    nombreAlmacenado?: true
    rutaArchivo?: true
    mimeType?: true
    tamanoBytes?: true
    hashArchivo?: true
    estado?: true
    validadoPorId?: true
    validadoEn?: true
    motivoRechazo?: true
    version?: true
    esActivo?: true
    creadoEn?: true
    cargadoPorId?: true
  }

  export type DocumentoMaxAggregateInputType = {
    id?: true
    procesoId?: true
    catalogoId?: true
    nombreOriginal?: true
    nombreAlmacenado?: true
    rutaArchivo?: true
    mimeType?: true
    tamanoBytes?: true
    hashArchivo?: true
    estado?: true
    validadoPorId?: true
    validadoEn?: true
    motivoRechazo?: true
    version?: true
    esActivo?: true
    creadoEn?: true
    cargadoPorId?: true
  }

  export type DocumentoCountAggregateInputType = {
    id?: true
    procesoId?: true
    catalogoId?: true
    nombreOriginal?: true
    nombreAlmacenado?: true
    rutaArchivo?: true
    mimeType?: true
    tamanoBytes?: true
    hashArchivo?: true
    estado?: true
    validadoPorId?: true
    validadoEn?: true
    motivoRechazo?: true
    version?: true
    esActivo?: true
    creadoEn?: true
    cargadoPorId?: true
    _all?: true
  }

  export type DocumentoAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documento to aggregate.
     */
    where?: DocumentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentos to fetch.
     */
    orderBy?: DocumentoOrderByWithRelationInput | DocumentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DocumentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Documentos
    **/
    _count?: true | DocumentoCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DocumentoAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DocumentoSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DocumentoMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DocumentoMaxAggregateInputType
  }

  export type GetDocumentoAggregateType<T extends DocumentoAggregateArgs> = {
        [P in keyof T & keyof AggregateDocumento]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDocumento[P]>
      : GetScalarType<T[P], AggregateDocumento[P]>
  }




  export type DocumentoGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DocumentoWhereInput
    orderBy?: DocumentoOrderByWithAggregationInput | DocumentoOrderByWithAggregationInput[]
    by: DocumentoScalarFieldEnum[] | DocumentoScalarFieldEnum
    having?: DocumentoScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DocumentoCountAggregateInputType | true
    _avg?: DocumentoAvgAggregateInputType
    _sum?: DocumentoSumAggregateInputType
    _min?: DocumentoMinAggregateInputType
    _max?: DocumentoMaxAggregateInputType
  }

  export type DocumentoGroupByOutputType = {
    id: string
    procesoId: string
    catalogoId: string
    nombreOriginal: string
    nombreAlmacenado: string
    rutaArchivo: string
    mimeType: string
    tamanoBytes: number
    hashArchivo: string
    estado: $Enums.EstadoDocumento
    validadoPorId: string | null
    validadoEn: Date | null
    motivoRechazo: string | null
    version: number
    esActivo: boolean
    creadoEn: Date
    cargadoPorId: string
    _count: DocumentoCountAggregateOutputType | null
    _avg: DocumentoAvgAggregateOutputType | null
    _sum: DocumentoSumAggregateOutputType | null
    _min: DocumentoMinAggregateOutputType | null
    _max: DocumentoMaxAggregateOutputType | null
  }

  type GetDocumentoGroupByPayload<T extends DocumentoGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DocumentoGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DocumentoGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DocumentoGroupByOutputType[P]>
            : GetScalarType<T[P], DocumentoGroupByOutputType[P]>
        }
      >
    >


  export type DocumentoSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procesoId?: boolean
    catalogoId?: boolean
    nombreOriginal?: boolean
    nombreAlmacenado?: boolean
    rutaArchivo?: boolean
    mimeType?: boolean
    tamanoBytes?: boolean
    hashArchivo?: boolean
    estado?: boolean
    validadoPorId?: boolean
    validadoEn?: boolean
    motivoRechazo?: boolean
    version?: boolean
    esActivo?: boolean
    creadoEn?: boolean
    cargadoPorId?: boolean
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    catalogo?: boolean | CatalogoDocumentoDefaultArgs<ExtArgs>
    cargadoPor?: boolean | UsuarioDefaultArgs<ExtArgs>
    validadoPor?: boolean | Documento$validadoPorArgs<ExtArgs>
    descargas?: boolean | Documento$descargasArgs<ExtArgs>
    _count?: boolean | DocumentoCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["documento"]>

  export type DocumentoSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procesoId?: boolean
    catalogoId?: boolean
    nombreOriginal?: boolean
    nombreAlmacenado?: boolean
    rutaArchivo?: boolean
    mimeType?: boolean
    tamanoBytes?: boolean
    hashArchivo?: boolean
    estado?: boolean
    validadoPorId?: boolean
    validadoEn?: boolean
    motivoRechazo?: boolean
    version?: boolean
    esActivo?: boolean
    creadoEn?: boolean
    cargadoPorId?: boolean
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    catalogo?: boolean | CatalogoDocumentoDefaultArgs<ExtArgs>
    cargadoPor?: boolean | UsuarioDefaultArgs<ExtArgs>
    validadoPor?: boolean | Documento$validadoPorArgs<ExtArgs>
  }, ExtArgs["result"]["documento"]>

  export type DocumentoSelectScalar = {
    id?: boolean
    procesoId?: boolean
    catalogoId?: boolean
    nombreOriginal?: boolean
    nombreAlmacenado?: boolean
    rutaArchivo?: boolean
    mimeType?: boolean
    tamanoBytes?: boolean
    hashArchivo?: boolean
    estado?: boolean
    validadoPorId?: boolean
    validadoEn?: boolean
    motivoRechazo?: boolean
    version?: boolean
    esActivo?: boolean
    creadoEn?: boolean
    cargadoPorId?: boolean
  }

  export type DocumentoInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    catalogo?: boolean | CatalogoDocumentoDefaultArgs<ExtArgs>
    cargadoPor?: boolean | UsuarioDefaultArgs<ExtArgs>
    validadoPor?: boolean | Documento$validadoPorArgs<ExtArgs>
    descargas?: boolean | Documento$descargasArgs<ExtArgs>
    _count?: boolean | DocumentoCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DocumentoIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    catalogo?: boolean | CatalogoDocumentoDefaultArgs<ExtArgs>
    cargadoPor?: boolean | UsuarioDefaultArgs<ExtArgs>
    validadoPor?: boolean | Documento$validadoPorArgs<ExtArgs>
  }

  export type $DocumentoPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Documento"
    objects: {
      proceso: Prisma.$ProcesoPayload<ExtArgs>
      catalogo: Prisma.$CatalogoDocumentoPayload<ExtArgs>
      cargadoPor: Prisma.$UsuarioPayload<ExtArgs>
      validadoPor: Prisma.$UsuarioPayload<ExtArgs> | null
      descargas: Prisma.$RegistroDescargaPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      procesoId: string
      catalogoId: string
      nombreOriginal: string
      nombreAlmacenado: string
      rutaArchivo: string
      mimeType: string
      tamanoBytes: number
      hashArchivo: string
      estado: $Enums.EstadoDocumento
      validadoPorId: string | null
      validadoEn: Date | null
      motivoRechazo: string | null
      version: number
      esActivo: boolean
      creadoEn: Date
      cargadoPorId: string
    }, ExtArgs["result"]["documento"]>
    composites: {}
  }

  type DocumentoGetPayload<S extends boolean | null | undefined | DocumentoDefaultArgs> = $Result.GetResult<Prisma.$DocumentoPayload, S>

  type DocumentoCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DocumentoFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DocumentoCountAggregateInputType | true
    }

  export interface DocumentoDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Documento'], meta: { name: 'Documento' } }
    /**
     * Find zero or one Documento that matches the filter.
     * @param {DocumentoFindUniqueArgs} args - Arguments to find a Documento
     * @example
     * // Get one Documento
     * const documento = await prisma.documento.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DocumentoFindUniqueArgs>(args: SelectSubset<T, DocumentoFindUniqueArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Documento that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DocumentoFindUniqueOrThrowArgs} args - Arguments to find a Documento
     * @example
     * // Get one Documento
     * const documento = await prisma.documento.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DocumentoFindUniqueOrThrowArgs>(args: SelectSubset<T, DocumentoFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Documento that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoFindFirstArgs} args - Arguments to find a Documento
     * @example
     * // Get one Documento
     * const documento = await prisma.documento.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DocumentoFindFirstArgs>(args?: SelectSubset<T, DocumentoFindFirstArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Documento that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoFindFirstOrThrowArgs} args - Arguments to find a Documento
     * @example
     * // Get one Documento
     * const documento = await prisma.documento.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DocumentoFindFirstOrThrowArgs>(args?: SelectSubset<T, DocumentoFindFirstOrThrowArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Documentos that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Documentos
     * const documentos = await prisma.documento.findMany()
     * 
     * // Get first 10 Documentos
     * const documentos = await prisma.documento.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const documentoWithIdOnly = await prisma.documento.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DocumentoFindManyArgs>(args?: SelectSubset<T, DocumentoFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Documento.
     * @param {DocumentoCreateArgs} args - Arguments to create a Documento.
     * @example
     * // Create one Documento
     * const Documento = await prisma.documento.create({
     *   data: {
     *     // ... data to create a Documento
     *   }
     * })
     * 
     */
    create<T extends DocumentoCreateArgs>(args: SelectSubset<T, DocumentoCreateArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Documentos.
     * @param {DocumentoCreateManyArgs} args - Arguments to create many Documentos.
     * @example
     * // Create many Documentos
     * const documento = await prisma.documento.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DocumentoCreateManyArgs>(args?: SelectSubset<T, DocumentoCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Documentos and returns the data saved in the database.
     * @param {DocumentoCreateManyAndReturnArgs} args - Arguments to create many Documentos.
     * @example
     * // Create many Documentos
     * const documento = await prisma.documento.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Documentos and only return the `id`
     * const documentoWithIdOnly = await prisma.documento.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DocumentoCreateManyAndReturnArgs>(args?: SelectSubset<T, DocumentoCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Documento.
     * @param {DocumentoDeleteArgs} args - Arguments to delete one Documento.
     * @example
     * // Delete one Documento
     * const Documento = await prisma.documento.delete({
     *   where: {
     *     // ... filter to delete one Documento
     *   }
     * })
     * 
     */
    delete<T extends DocumentoDeleteArgs>(args: SelectSubset<T, DocumentoDeleteArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Documento.
     * @param {DocumentoUpdateArgs} args - Arguments to update one Documento.
     * @example
     * // Update one Documento
     * const documento = await prisma.documento.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DocumentoUpdateArgs>(args: SelectSubset<T, DocumentoUpdateArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Documentos.
     * @param {DocumentoDeleteManyArgs} args - Arguments to filter Documentos to delete.
     * @example
     * // Delete a few Documentos
     * const { count } = await prisma.documento.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DocumentoDeleteManyArgs>(args?: SelectSubset<T, DocumentoDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Documentos
     * const documento = await prisma.documento.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DocumentoUpdateManyArgs>(args: SelectSubset<T, DocumentoUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Documento.
     * @param {DocumentoUpsertArgs} args - Arguments to update or create a Documento.
     * @example
     * // Update or create a Documento
     * const documento = await prisma.documento.upsert({
     *   create: {
     *     // ... data to create a Documento
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Documento we want to update
     *   }
     * })
     */
    upsert<T extends DocumentoUpsertArgs>(args: SelectSubset<T, DocumentoUpsertArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Documentos.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoCountArgs} args - Arguments to filter Documentos to count.
     * @example
     * // Count the number of Documentos
     * const count = await prisma.documento.count({
     *   where: {
     *     // ... the filter for the Documentos we want to count
     *   }
     * })
    **/
    count<T extends DocumentoCountArgs>(
      args?: Subset<T, DocumentoCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DocumentoCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Documento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DocumentoAggregateArgs>(args: Subset<T, DocumentoAggregateArgs>): Prisma.PrismaPromise<GetDocumentoAggregateType<T>>

    /**
     * Group by Documento.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DocumentoGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DocumentoGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DocumentoGroupByArgs['orderBy'] }
        : { orderBy?: DocumentoGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DocumentoGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDocumentoGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Documento model
   */
  readonly fields: DocumentoFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Documento.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DocumentoClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proceso<T extends ProcesoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcesoDefaultArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    catalogo<T extends CatalogoDocumentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, CatalogoDocumentoDefaultArgs<ExtArgs>>): Prisma__CatalogoDocumentoClient<$Result.GetResult<Prisma.$CatalogoDocumentoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    cargadoPor<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    validadoPor<T extends Documento$validadoPorArgs<ExtArgs> = {}>(args?: Subset<T, Documento$validadoPorArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    descargas<T extends Documento$descargasArgs<ExtArgs> = {}>(args?: Subset<T, Documento$descargasArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistroDescargaPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Documento model
   */ 
  interface DocumentoFieldRefs {
    readonly id: FieldRef<"Documento", 'String'>
    readonly procesoId: FieldRef<"Documento", 'String'>
    readonly catalogoId: FieldRef<"Documento", 'String'>
    readonly nombreOriginal: FieldRef<"Documento", 'String'>
    readonly nombreAlmacenado: FieldRef<"Documento", 'String'>
    readonly rutaArchivo: FieldRef<"Documento", 'String'>
    readonly mimeType: FieldRef<"Documento", 'String'>
    readonly tamanoBytes: FieldRef<"Documento", 'Int'>
    readonly hashArchivo: FieldRef<"Documento", 'String'>
    readonly estado: FieldRef<"Documento", 'EstadoDocumento'>
    readonly validadoPorId: FieldRef<"Documento", 'String'>
    readonly validadoEn: FieldRef<"Documento", 'DateTime'>
    readonly motivoRechazo: FieldRef<"Documento", 'String'>
    readonly version: FieldRef<"Documento", 'Int'>
    readonly esActivo: FieldRef<"Documento", 'Boolean'>
    readonly creadoEn: FieldRef<"Documento", 'DateTime'>
    readonly cargadoPorId: FieldRef<"Documento", 'String'>
  }
    

  // Custom InputTypes
  /**
   * Documento findUnique
   */
  export type DocumentoFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * Filter, which Documento to fetch.
     */
    where: DocumentoWhereUniqueInput
  }

  /**
   * Documento findUniqueOrThrow
   */
  export type DocumentoFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * Filter, which Documento to fetch.
     */
    where: DocumentoWhereUniqueInput
  }

  /**
   * Documento findFirst
   */
  export type DocumentoFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * Filter, which Documento to fetch.
     */
    where?: DocumentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentos to fetch.
     */
    orderBy?: DocumentoOrderByWithRelationInput | DocumentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documentos.
     */
    cursor?: DocumentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documentos.
     */
    distinct?: DocumentoScalarFieldEnum | DocumentoScalarFieldEnum[]
  }

  /**
   * Documento findFirstOrThrow
   */
  export type DocumentoFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * Filter, which Documento to fetch.
     */
    where?: DocumentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentos to fetch.
     */
    orderBy?: DocumentoOrderByWithRelationInput | DocumentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Documentos.
     */
    cursor?: DocumentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentos.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Documentos.
     */
    distinct?: DocumentoScalarFieldEnum | DocumentoScalarFieldEnum[]
  }

  /**
   * Documento findMany
   */
  export type DocumentoFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * Filter, which Documentos to fetch.
     */
    where?: DocumentoWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Documentos to fetch.
     */
    orderBy?: DocumentoOrderByWithRelationInput | DocumentoOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Documentos.
     */
    cursor?: DocumentoWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Documentos from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Documentos.
     */
    skip?: number
    distinct?: DocumentoScalarFieldEnum | DocumentoScalarFieldEnum[]
  }

  /**
   * Documento create
   */
  export type DocumentoCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * The data needed to create a Documento.
     */
    data: XOR<DocumentoCreateInput, DocumentoUncheckedCreateInput>
  }

  /**
   * Documento createMany
   */
  export type DocumentoCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Documentos.
     */
    data: DocumentoCreateManyInput | DocumentoCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Documento createManyAndReturn
   */
  export type DocumentoCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Documentos.
     */
    data: DocumentoCreateManyInput | DocumentoCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Documento update
   */
  export type DocumentoUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * The data needed to update a Documento.
     */
    data: XOR<DocumentoUpdateInput, DocumentoUncheckedUpdateInput>
    /**
     * Choose, which Documento to update.
     */
    where: DocumentoWhereUniqueInput
  }

  /**
   * Documento updateMany
   */
  export type DocumentoUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Documentos.
     */
    data: XOR<DocumentoUpdateManyMutationInput, DocumentoUncheckedUpdateManyInput>
    /**
     * Filter which Documentos to update
     */
    where?: DocumentoWhereInput
  }

  /**
   * Documento upsert
   */
  export type DocumentoUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * The filter to search for the Documento to update in case it exists.
     */
    where: DocumentoWhereUniqueInput
    /**
     * In case the Documento found by the `where` argument doesn't exist, create a new Documento with this data.
     */
    create: XOR<DocumentoCreateInput, DocumentoUncheckedCreateInput>
    /**
     * In case the Documento was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DocumentoUpdateInput, DocumentoUncheckedUpdateInput>
  }

  /**
   * Documento delete
   */
  export type DocumentoDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
    /**
     * Filter which Documento to delete.
     */
    where: DocumentoWhereUniqueInput
  }

  /**
   * Documento deleteMany
   */
  export type DocumentoDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Documentos to delete
     */
    where?: DocumentoWhereInput
  }

  /**
   * Documento.validadoPor
   */
  export type Documento$validadoPorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
  }

  /**
   * Documento.descargas
   */
  export type Documento$descargasArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroDescarga
     */
    select?: RegistroDescargaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroDescargaInclude<ExtArgs> | null
    where?: RegistroDescargaWhereInput
    orderBy?: RegistroDescargaOrderByWithRelationInput | RegistroDescargaOrderByWithRelationInput[]
    cursor?: RegistroDescargaWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RegistroDescargaScalarFieldEnum | RegistroDescargaScalarFieldEnum[]
  }

  /**
   * Documento without action
   */
  export type DocumentoDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Documento
     */
    select?: DocumentoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DocumentoInclude<ExtArgs> | null
  }


  /**
   * Model RegistroDescarga
   */

  export type AggregateRegistroDescarga = {
    _count: RegistroDescargaCountAggregateOutputType | null
    _min: RegistroDescargaMinAggregateOutputType | null
    _max: RegistroDescargaMaxAggregateOutputType | null
  }

  export type RegistroDescargaMinAggregateOutputType = {
    id: string | null
    documentoId: string | null
    usuarioId: string | null
    ipAddress: string | null
    userAgent: string | null
    creadoEn: Date | null
  }

  export type RegistroDescargaMaxAggregateOutputType = {
    id: string | null
    documentoId: string | null
    usuarioId: string | null
    ipAddress: string | null
    userAgent: string | null
    creadoEn: Date | null
  }

  export type RegistroDescargaCountAggregateOutputType = {
    id: number
    documentoId: number
    usuarioId: number
    ipAddress: number
    userAgent: number
    creadoEn: number
    _all: number
  }


  export type RegistroDescargaMinAggregateInputType = {
    id?: true
    documentoId?: true
    usuarioId?: true
    ipAddress?: true
    userAgent?: true
    creadoEn?: true
  }

  export type RegistroDescargaMaxAggregateInputType = {
    id?: true
    documentoId?: true
    usuarioId?: true
    ipAddress?: true
    userAgent?: true
    creadoEn?: true
  }

  export type RegistroDescargaCountAggregateInputType = {
    id?: true
    documentoId?: true
    usuarioId?: true
    ipAddress?: true
    userAgent?: true
    creadoEn?: true
    _all?: true
  }

  export type RegistroDescargaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegistroDescarga to aggregate.
     */
    where?: RegistroDescargaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegistroDescargas to fetch.
     */
    orderBy?: RegistroDescargaOrderByWithRelationInput | RegistroDescargaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RegistroDescargaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegistroDescargas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegistroDescargas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RegistroDescargas
    **/
    _count?: true | RegistroDescargaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RegistroDescargaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RegistroDescargaMaxAggregateInputType
  }

  export type GetRegistroDescargaAggregateType<T extends RegistroDescargaAggregateArgs> = {
        [P in keyof T & keyof AggregateRegistroDescarga]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRegistroDescarga[P]>
      : GetScalarType<T[P], AggregateRegistroDescarga[P]>
  }




  export type RegistroDescargaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RegistroDescargaWhereInput
    orderBy?: RegistroDescargaOrderByWithAggregationInput | RegistroDescargaOrderByWithAggregationInput[]
    by: RegistroDescargaScalarFieldEnum[] | RegistroDescargaScalarFieldEnum
    having?: RegistroDescargaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RegistroDescargaCountAggregateInputType | true
    _min?: RegistroDescargaMinAggregateInputType
    _max?: RegistroDescargaMaxAggregateInputType
  }

  export type RegistroDescargaGroupByOutputType = {
    id: string
    documentoId: string
    usuarioId: string
    ipAddress: string
    userAgent: string
    creadoEn: Date
    _count: RegistroDescargaCountAggregateOutputType | null
    _min: RegistroDescargaMinAggregateOutputType | null
    _max: RegistroDescargaMaxAggregateOutputType | null
  }

  type GetRegistroDescargaGroupByPayload<T extends RegistroDescargaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RegistroDescargaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RegistroDescargaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RegistroDescargaGroupByOutputType[P]>
            : GetScalarType<T[P], RegistroDescargaGroupByOutputType[P]>
        }
      >
    >


  export type RegistroDescargaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentoId?: boolean
    usuarioId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    creadoEn?: boolean
    documento?: boolean | DocumentoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registroDescarga"]>

  export type RegistroDescargaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    documentoId?: boolean
    usuarioId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    creadoEn?: boolean
    documento?: boolean | DocumentoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["registroDescarga"]>

  export type RegistroDescargaSelectScalar = {
    id?: boolean
    documentoId?: boolean
    usuarioId?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    creadoEn?: boolean
  }

  export type RegistroDescargaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documento?: boolean | DocumentoDefaultArgs<ExtArgs>
  }
  export type RegistroDescargaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    documento?: boolean | DocumentoDefaultArgs<ExtArgs>
  }

  export type $RegistroDescargaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RegistroDescarga"
    objects: {
      documento: Prisma.$DocumentoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      documentoId: string
      usuarioId: string
      ipAddress: string
      userAgent: string
      creadoEn: Date
    }, ExtArgs["result"]["registroDescarga"]>
    composites: {}
  }

  type RegistroDescargaGetPayload<S extends boolean | null | undefined | RegistroDescargaDefaultArgs> = $Result.GetResult<Prisma.$RegistroDescargaPayload, S>

  type RegistroDescargaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RegistroDescargaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RegistroDescargaCountAggregateInputType | true
    }

  export interface RegistroDescargaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RegistroDescarga'], meta: { name: 'RegistroDescarga' } }
    /**
     * Find zero or one RegistroDescarga that matches the filter.
     * @param {RegistroDescargaFindUniqueArgs} args - Arguments to find a RegistroDescarga
     * @example
     * // Get one RegistroDescarga
     * const registroDescarga = await prisma.registroDescarga.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RegistroDescargaFindUniqueArgs>(args: SelectSubset<T, RegistroDescargaFindUniqueArgs<ExtArgs>>): Prisma__RegistroDescargaClient<$Result.GetResult<Prisma.$RegistroDescargaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RegistroDescarga that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RegistroDescargaFindUniqueOrThrowArgs} args - Arguments to find a RegistroDescarga
     * @example
     * // Get one RegistroDescarga
     * const registroDescarga = await prisma.registroDescarga.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RegistroDescargaFindUniqueOrThrowArgs>(args: SelectSubset<T, RegistroDescargaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RegistroDescargaClient<$Result.GetResult<Prisma.$RegistroDescargaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RegistroDescarga that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroDescargaFindFirstArgs} args - Arguments to find a RegistroDescarga
     * @example
     * // Get one RegistroDescarga
     * const registroDescarga = await prisma.registroDescarga.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RegistroDescargaFindFirstArgs>(args?: SelectSubset<T, RegistroDescargaFindFirstArgs<ExtArgs>>): Prisma__RegistroDescargaClient<$Result.GetResult<Prisma.$RegistroDescargaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RegistroDescarga that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroDescargaFindFirstOrThrowArgs} args - Arguments to find a RegistroDescarga
     * @example
     * // Get one RegistroDescarga
     * const registroDescarga = await prisma.registroDescarga.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RegistroDescargaFindFirstOrThrowArgs>(args?: SelectSubset<T, RegistroDescargaFindFirstOrThrowArgs<ExtArgs>>): Prisma__RegistroDescargaClient<$Result.GetResult<Prisma.$RegistroDescargaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RegistroDescargas that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroDescargaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RegistroDescargas
     * const registroDescargas = await prisma.registroDescarga.findMany()
     * 
     * // Get first 10 RegistroDescargas
     * const registroDescargas = await prisma.registroDescarga.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const registroDescargaWithIdOnly = await prisma.registroDescarga.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RegistroDescargaFindManyArgs>(args?: SelectSubset<T, RegistroDescargaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistroDescargaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RegistroDescarga.
     * @param {RegistroDescargaCreateArgs} args - Arguments to create a RegistroDescarga.
     * @example
     * // Create one RegistroDescarga
     * const RegistroDescarga = await prisma.registroDescarga.create({
     *   data: {
     *     // ... data to create a RegistroDescarga
     *   }
     * })
     * 
     */
    create<T extends RegistroDescargaCreateArgs>(args: SelectSubset<T, RegistroDescargaCreateArgs<ExtArgs>>): Prisma__RegistroDescargaClient<$Result.GetResult<Prisma.$RegistroDescargaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RegistroDescargas.
     * @param {RegistroDescargaCreateManyArgs} args - Arguments to create many RegistroDescargas.
     * @example
     * // Create many RegistroDescargas
     * const registroDescarga = await prisma.registroDescarga.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RegistroDescargaCreateManyArgs>(args?: SelectSubset<T, RegistroDescargaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many RegistroDescargas and returns the data saved in the database.
     * @param {RegistroDescargaCreateManyAndReturnArgs} args - Arguments to create many RegistroDescargas.
     * @example
     * // Create many RegistroDescargas
     * const registroDescarga = await prisma.registroDescarga.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many RegistroDescargas and only return the `id`
     * const registroDescargaWithIdOnly = await prisma.registroDescarga.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends RegistroDescargaCreateManyAndReturnArgs>(args?: SelectSubset<T, RegistroDescargaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RegistroDescargaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a RegistroDescarga.
     * @param {RegistroDescargaDeleteArgs} args - Arguments to delete one RegistroDescarga.
     * @example
     * // Delete one RegistroDescarga
     * const RegistroDescarga = await prisma.registroDescarga.delete({
     *   where: {
     *     // ... filter to delete one RegistroDescarga
     *   }
     * })
     * 
     */
    delete<T extends RegistroDescargaDeleteArgs>(args: SelectSubset<T, RegistroDescargaDeleteArgs<ExtArgs>>): Prisma__RegistroDescargaClient<$Result.GetResult<Prisma.$RegistroDescargaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RegistroDescarga.
     * @param {RegistroDescargaUpdateArgs} args - Arguments to update one RegistroDescarga.
     * @example
     * // Update one RegistroDescarga
     * const registroDescarga = await prisma.registroDescarga.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RegistroDescargaUpdateArgs>(args: SelectSubset<T, RegistroDescargaUpdateArgs<ExtArgs>>): Prisma__RegistroDescargaClient<$Result.GetResult<Prisma.$RegistroDescargaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RegistroDescargas.
     * @param {RegistroDescargaDeleteManyArgs} args - Arguments to filter RegistroDescargas to delete.
     * @example
     * // Delete a few RegistroDescargas
     * const { count } = await prisma.registroDescarga.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RegistroDescargaDeleteManyArgs>(args?: SelectSubset<T, RegistroDescargaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RegistroDescargas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroDescargaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RegistroDescargas
     * const registroDescarga = await prisma.registroDescarga.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RegistroDescargaUpdateManyArgs>(args: SelectSubset<T, RegistroDescargaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RegistroDescarga.
     * @param {RegistroDescargaUpsertArgs} args - Arguments to update or create a RegistroDescarga.
     * @example
     * // Update or create a RegistroDescarga
     * const registroDescarga = await prisma.registroDescarga.upsert({
     *   create: {
     *     // ... data to create a RegistroDescarga
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RegistroDescarga we want to update
     *   }
     * })
     */
    upsert<T extends RegistroDescargaUpsertArgs>(args: SelectSubset<T, RegistroDescargaUpsertArgs<ExtArgs>>): Prisma__RegistroDescargaClient<$Result.GetResult<Prisma.$RegistroDescargaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RegistroDescargas.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroDescargaCountArgs} args - Arguments to filter RegistroDescargas to count.
     * @example
     * // Count the number of RegistroDescargas
     * const count = await prisma.registroDescarga.count({
     *   where: {
     *     // ... the filter for the RegistroDescargas we want to count
     *   }
     * })
    **/
    count<T extends RegistroDescargaCountArgs>(
      args?: Subset<T, RegistroDescargaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RegistroDescargaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RegistroDescarga.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroDescargaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RegistroDescargaAggregateArgs>(args: Subset<T, RegistroDescargaAggregateArgs>): Prisma.PrismaPromise<GetRegistroDescargaAggregateType<T>>

    /**
     * Group by RegistroDescarga.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RegistroDescargaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RegistroDescargaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RegistroDescargaGroupByArgs['orderBy'] }
        : { orderBy?: RegistroDescargaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RegistroDescargaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRegistroDescargaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RegistroDescarga model
   */
  readonly fields: RegistroDescargaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RegistroDescarga.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RegistroDescargaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    documento<T extends DocumentoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DocumentoDefaultArgs<ExtArgs>>): Prisma__DocumentoClient<$Result.GetResult<Prisma.$DocumentoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RegistroDescarga model
   */ 
  interface RegistroDescargaFieldRefs {
    readonly id: FieldRef<"RegistroDescarga", 'String'>
    readonly documentoId: FieldRef<"RegistroDescarga", 'String'>
    readonly usuarioId: FieldRef<"RegistroDescarga", 'String'>
    readonly ipAddress: FieldRef<"RegistroDescarga", 'String'>
    readonly userAgent: FieldRef<"RegistroDescarga", 'String'>
    readonly creadoEn: FieldRef<"RegistroDescarga", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * RegistroDescarga findUnique
   */
  export type RegistroDescargaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroDescarga
     */
    select?: RegistroDescargaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroDescargaInclude<ExtArgs> | null
    /**
     * Filter, which RegistroDescarga to fetch.
     */
    where: RegistroDescargaWhereUniqueInput
  }

  /**
   * RegistroDescarga findUniqueOrThrow
   */
  export type RegistroDescargaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroDescarga
     */
    select?: RegistroDescargaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroDescargaInclude<ExtArgs> | null
    /**
     * Filter, which RegistroDescarga to fetch.
     */
    where: RegistroDescargaWhereUniqueInput
  }

  /**
   * RegistroDescarga findFirst
   */
  export type RegistroDescargaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroDescarga
     */
    select?: RegistroDescargaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroDescargaInclude<ExtArgs> | null
    /**
     * Filter, which RegistroDescarga to fetch.
     */
    where?: RegistroDescargaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegistroDescargas to fetch.
     */
    orderBy?: RegistroDescargaOrderByWithRelationInput | RegistroDescargaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegistroDescargas.
     */
    cursor?: RegistroDescargaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegistroDescargas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegistroDescargas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegistroDescargas.
     */
    distinct?: RegistroDescargaScalarFieldEnum | RegistroDescargaScalarFieldEnum[]
  }

  /**
   * RegistroDescarga findFirstOrThrow
   */
  export type RegistroDescargaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroDescarga
     */
    select?: RegistroDescargaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroDescargaInclude<ExtArgs> | null
    /**
     * Filter, which RegistroDescarga to fetch.
     */
    where?: RegistroDescargaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegistroDescargas to fetch.
     */
    orderBy?: RegistroDescargaOrderByWithRelationInput | RegistroDescargaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RegistroDescargas.
     */
    cursor?: RegistroDescargaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegistroDescargas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegistroDescargas.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RegistroDescargas.
     */
    distinct?: RegistroDescargaScalarFieldEnum | RegistroDescargaScalarFieldEnum[]
  }

  /**
   * RegistroDescarga findMany
   */
  export type RegistroDescargaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroDescarga
     */
    select?: RegistroDescargaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroDescargaInclude<ExtArgs> | null
    /**
     * Filter, which RegistroDescargas to fetch.
     */
    where?: RegistroDescargaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RegistroDescargas to fetch.
     */
    orderBy?: RegistroDescargaOrderByWithRelationInput | RegistroDescargaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RegistroDescargas.
     */
    cursor?: RegistroDescargaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RegistroDescargas from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RegistroDescargas.
     */
    skip?: number
    distinct?: RegistroDescargaScalarFieldEnum | RegistroDescargaScalarFieldEnum[]
  }

  /**
   * RegistroDescarga create
   */
  export type RegistroDescargaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroDescarga
     */
    select?: RegistroDescargaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroDescargaInclude<ExtArgs> | null
    /**
     * The data needed to create a RegistroDescarga.
     */
    data: XOR<RegistroDescargaCreateInput, RegistroDescargaUncheckedCreateInput>
  }

  /**
   * RegistroDescarga createMany
   */
  export type RegistroDescargaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RegistroDescargas.
     */
    data: RegistroDescargaCreateManyInput | RegistroDescargaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RegistroDescarga createManyAndReturn
   */
  export type RegistroDescargaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroDescarga
     */
    select?: RegistroDescargaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many RegistroDescargas.
     */
    data: RegistroDescargaCreateManyInput | RegistroDescargaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroDescargaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * RegistroDescarga update
   */
  export type RegistroDescargaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroDescarga
     */
    select?: RegistroDescargaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroDescargaInclude<ExtArgs> | null
    /**
     * The data needed to update a RegistroDescarga.
     */
    data: XOR<RegistroDescargaUpdateInput, RegistroDescargaUncheckedUpdateInput>
    /**
     * Choose, which RegistroDescarga to update.
     */
    where: RegistroDescargaWhereUniqueInput
  }

  /**
   * RegistroDescarga updateMany
   */
  export type RegistroDescargaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RegistroDescargas.
     */
    data: XOR<RegistroDescargaUpdateManyMutationInput, RegistroDescargaUncheckedUpdateManyInput>
    /**
     * Filter which RegistroDescargas to update
     */
    where?: RegistroDescargaWhereInput
  }

  /**
   * RegistroDescarga upsert
   */
  export type RegistroDescargaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroDescarga
     */
    select?: RegistroDescargaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroDescargaInclude<ExtArgs> | null
    /**
     * The filter to search for the RegistroDescarga to update in case it exists.
     */
    where: RegistroDescargaWhereUniqueInput
    /**
     * In case the RegistroDescarga found by the `where` argument doesn't exist, create a new RegistroDescarga with this data.
     */
    create: XOR<RegistroDescargaCreateInput, RegistroDescargaUncheckedCreateInput>
    /**
     * In case the RegistroDescarga was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RegistroDescargaUpdateInput, RegistroDescargaUncheckedUpdateInput>
  }

  /**
   * RegistroDescarga delete
   */
  export type RegistroDescargaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroDescarga
     */
    select?: RegistroDescargaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroDescargaInclude<ExtArgs> | null
    /**
     * Filter which RegistroDescarga to delete.
     */
    where: RegistroDescargaWhereUniqueInput
  }

  /**
   * RegistroDescarga deleteMany
   */
  export type RegistroDescargaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RegistroDescargas to delete
     */
    where?: RegistroDescargaWhereInput
  }

  /**
   * RegistroDescarga without action
   */
  export type RegistroDescargaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RegistroDescarga
     */
    select?: RegistroDescargaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RegistroDescargaInclude<ExtArgs> | null
  }


  /**
   * Model HistorialPdf
   */

  export type AggregateHistorialPdf = {
    _count: HistorialPdfCountAggregateOutputType | null
    _avg: HistorialPdfAvgAggregateOutputType | null
    _sum: HistorialPdfSumAggregateOutputType | null
    _min: HistorialPdfMinAggregateOutputType | null
    _max: HistorialPdfMaxAggregateOutputType | null
  }

  export type HistorialPdfAvgAggregateOutputType = {
    version: number | null
  }

  export type HistorialPdfSumAggregateOutputType = {
    version: number | null
  }

  export type HistorialPdfMinAggregateOutputType = {
    id: string | null
    procesoId: string | null
    version: number | null
    pdfPath: string | null
    pdfHash: string | null
    creadoEn: Date | null
  }

  export type HistorialPdfMaxAggregateOutputType = {
    id: string | null
    procesoId: string | null
    version: number | null
    pdfPath: string | null
    pdfHash: string | null
    creadoEn: Date | null
  }

  export type HistorialPdfCountAggregateOutputType = {
    id: number
    procesoId: number
    version: number
    pdfPath: number
    pdfHash: number
    creadoEn: number
    _all: number
  }


  export type HistorialPdfAvgAggregateInputType = {
    version?: true
  }

  export type HistorialPdfSumAggregateInputType = {
    version?: true
  }

  export type HistorialPdfMinAggregateInputType = {
    id?: true
    procesoId?: true
    version?: true
    pdfPath?: true
    pdfHash?: true
    creadoEn?: true
  }

  export type HistorialPdfMaxAggregateInputType = {
    id?: true
    procesoId?: true
    version?: true
    pdfPath?: true
    pdfHash?: true
    creadoEn?: true
  }

  export type HistorialPdfCountAggregateInputType = {
    id?: true
    procesoId?: true
    version?: true
    pdfPath?: true
    pdfHash?: true
    creadoEn?: true
    _all?: true
  }

  export type HistorialPdfAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistorialPdf to aggregate.
     */
    where?: HistorialPdfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialPdfs to fetch.
     */
    orderBy?: HistorialPdfOrderByWithRelationInput | HistorialPdfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: HistorialPdfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialPdfs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialPdfs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned HistorialPdfs
    **/
    _count?: true | HistorialPdfCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: HistorialPdfAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: HistorialPdfSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: HistorialPdfMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: HistorialPdfMaxAggregateInputType
  }

  export type GetHistorialPdfAggregateType<T extends HistorialPdfAggregateArgs> = {
        [P in keyof T & keyof AggregateHistorialPdf]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateHistorialPdf[P]>
      : GetScalarType<T[P], AggregateHistorialPdf[P]>
  }




  export type HistorialPdfGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: HistorialPdfWhereInput
    orderBy?: HistorialPdfOrderByWithAggregationInput | HistorialPdfOrderByWithAggregationInput[]
    by: HistorialPdfScalarFieldEnum[] | HistorialPdfScalarFieldEnum
    having?: HistorialPdfScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: HistorialPdfCountAggregateInputType | true
    _avg?: HistorialPdfAvgAggregateInputType
    _sum?: HistorialPdfSumAggregateInputType
    _min?: HistorialPdfMinAggregateInputType
    _max?: HistorialPdfMaxAggregateInputType
  }

  export type HistorialPdfGroupByOutputType = {
    id: string
    procesoId: string
    version: number
    pdfPath: string
    pdfHash: string
    creadoEn: Date
    _count: HistorialPdfCountAggregateOutputType | null
    _avg: HistorialPdfAvgAggregateOutputType | null
    _sum: HistorialPdfSumAggregateOutputType | null
    _min: HistorialPdfMinAggregateOutputType | null
    _max: HistorialPdfMaxAggregateOutputType | null
  }

  type GetHistorialPdfGroupByPayload<T extends HistorialPdfGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<HistorialPdfGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof HistorialPdfGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], HistorialPdfGroupByOutputType[P]>
            : GetScalarType<T[P], HistorialPdfGroupByOutputType[P]>
        }
      >
    >


  export type HistorialPdfSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procesoId?: boolean
    version?: boolean
    pdfPath?: boolean
    pdfHash?: boolean
    creadoEn?: boolean
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["historialPdf"]>

  export type HistorialPdfSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procesoId?: boolean
    version?: boolean
    pdfPath?: boolean
    pdfHash?: boolean
    creadoEn?: boolean
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["historialPdf"]>

  export type HistorialPdfSelectScalar = {
    id?: boolean
    procesoId?: boolean
    version?: boolean
    pdfPath?: boolean
    pdfHash?: boolean
    creadoEn?: boolean
  }

  export type HistorialPdfInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
  }
  export type HistorialPdfIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
  }

  export type $HistorialPdfPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "HistorialPdf"
    objects: {
      proceso: Prisma.$ProcesoPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      procesoId: string
      version: number
      pdfPath: string
      pdfHash: string
      creadoEn: Date
    }, ExtArgs["result"]["historialPdf"]>
    composites: {}
  }

  type HistorialPdfGetPayload<S extends boolean | null | undefined | HistorialPdfDefaultArgs> = $Result.GetResult<Prisma.$HistorialPdfPayload, S>

  type HistorialPdfCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<HistorialPdfFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: HistorialPdfCountAggregateInputType | true
    }

  export interface HistorialPdfDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['HistorialPdf'], meta: { name: 'HistorialPdf' } }
    /**
     * Find zero or one HistorialPdf that matches the filter.
     * @param {HistorialPdfFindUniqueArgs} args - Arguments to find a HistorialPdf
     * @example
     * // Get one HistorialPdf
     * const historialPdf = await prisma.historialPdf.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends HistorialPdfFindUniqueArgs>(args: SelectSubset<T, HistorialPdfFindUniqueArgs<ExtArgs>>): Prisma__HistorialPdfClient<$Result.GetResult<Prisma.$HistorialPdfPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one HistorialPdf that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {HistorialPdfFindUniqueOrThrowArgs} args - Arguments to find a HistorialPdf
     * @example
     * // Get one HistorialPdf
     * const historialPdf = await prisma.historialPdf.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends HistorialPdfFindUniqueOrThrowArgs>(args: SelectSubset<T, HistorialPdfFindUniqueOrThrowArgs<ExtArgs>>): Prisma__HistorialPdfClient<$Result.GetResult<Prisma.$HistorialPdfPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first HistorialPdf that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialPdfFindFirstArgs} args - Arguments to find a HistorialPdf
     * @example
     * // Get one HistorialPdf
     * const historialPdf = await prisma.historialPdf.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends HistorialPdfFindFirstArgs>(args?: SelectSubset<T, HistorialPdfFindFirstArgs<ExtArgs>>): Prisma__HistorialPdfClient<$Result.GetResult<Prisma.$HistorialPdfPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first HistorialPdf that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialPdfFindFirstOrThrowArgs} args - Arguments to find a HistorialPdf
     * @example
     * // Get one HistorialPdf
     * const historialPdf = await prisma.historialPdf.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends HistorialPdfFindFirstOrThrowArgs>(args?: SelectSubset<T, HistorialPdfFindFirstOrThrowArgs<ExtArgs>>): Prisma__HistorialPdfClient<$Result.GetResult<Prisma.$HistorialPdfPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more HistorialPdfs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialPdfFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all HistorialPdfs
     * const historialPdfs = await prisma.historialPdf.findMany()
     * 
     * // Get first 10 HistorialPdfs
     * const historialPdfs = await prisma.historialPdf.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const historialPdfWithIdOnly = await prisma.historialPdf.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends HistorialPdfFindManyArgs>(args?: SelectSubset<T, HistorialPdfFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialPdfPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a HistorialPdf.
     * @param {HistorialPdfCreateArgs} args - Arguments to create a HistorialPdf.
     * @example
     * // Create one HistorialPdf
     * const HistorialPdf = await prisma.historialPdf.create({
     *   data: {
     *     // ... data to create a HistorialPdf
     *   }
     * })
     * 
     */
    create<T extends HistorialPdfCreateArgs>(args: SelectSubset<T, HistorialPdfCreateArgs<ExtArgs>>): Prisma__HistorialPdfClient<$Result.GetResult<Prisma.$HistorialPdfPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many HistorialPdfs.
     * @param {HistorialPdfCreateManyArgs} args - Arguments to create many HistorialPdfs.
     * @example
     * // Create many HistorialPdfs
     * const historialPdf = await prisma.historialPdf.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends HistorialPdfCreateManyArgs>(args?: SelectSubset<T, HistorialPdfCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many HistorialPdfs and returns the data saved in the database.
     * @param {HistorialPdfCreateManyAndReturnArgs} args - Arguments to create many HistorialPdfs.
     * @example
     * // Create many HistorialPdfs
     * const historialPdf = await prisma.historialPdf.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many HistorialPdfs and only return the `id`
     * const historialPdfWithIdOnly = await prisma.historialPdf.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends HistorialPdfCreateManyAndReturnArgs>(args?: SelectSubset<T, HistorialPdfCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$HistorialPdfPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a HistorialPdf.
     * @param {HistorialPdfDeleteArgs} args - Arguments to delete one HistorialPdf.
     * @example
     * // Delete one HistorialPdf
     * const HistorialPdf = await prisma.historialPdf.delete({
     *   where: {
     *     // ... filter to delete one HistorialPdf
     *   }
     * })
     * 
     */
    delete<T extends HistorialPdfDeleteArgs>(args: SelectSubset<T, HistorialPdfDeleteArgs<ExtArgs>>): Prisma__HistorialPdfClient<$Result.GetResult<Prisma.$HistorialPdfPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one HistorialPdf.
     * @param {HistorialPdfUpdateArgs} args - Arguments to update one HistorialPdf.
     * @example
     * // Update one HistorialPdf
     * const historialPdf = await prisma.historialPdf.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends HistorialPdfUpdateArgs>(args: SelectSubset<T, HistorialPdfUpdateArgs<ExtArgs>>): Prisma__HistorialPdfClient<$Result.GetResult<Prisma.$HistorialPdfPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more HistorialPdfs.
     * @param {HistorialPdfDeleteManyArgs} args - Arguments to filter HistorialPdfs to delete.
     * @example
     * // Delete a few HistorialPdfs
     * const { count } = await prisma.historialPdf.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends HistorialPdfDeleteManyArgs>(args?: SelectSubset<T, HistorialPdfDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more HistorialPdfs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialPdfUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many HistorialPdfs
     * const historialPdf = await prisma.historialPdf.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends HistorialPdfUpdateManyArgs>(args: SelectSubset<T, HistorialPdfUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one HistorialPdf.
     * @param {HistorialPdfUpsertArgs} args - Arguments to update or create a HistorialPdf.
     * @example
     * // Update or create a HistorialPdf
     * const historialPdf = await prisma.historialPdf.upsert({
     *   create: {
     *     // ... data to create a HistorialPdf
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the HistorialPdf we want to update
     *   }
     * })
     */
    upsert<T extends HistorialPdfUpsertArgs>(args: SelectSubset<T, HistorialPdfUpsertArgs<ExtArgs>>): Prisma__HistorialPdfClient<$Result.GetResult<Prisma.$HistorialPdfPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of HistorialPdfs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialPdfCountArgs} args - Arguments to filter HistorialPdfs to count.
     * @example
     * // Count the number of HistorialPdfs
     * const count = await prisma.historialPdf.count({
     *   where: {
     *     // ... the filter for the HistorialPdfs we want to count
     *   }
     * })
    **/
    count<T extends HistorialPdfCountArgs>(
      args?: Subset<T, HistorialPdfCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], HistorialPdfCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a HistorialPdf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialPdfAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends HistorialPdfAggregateArgs>(args: Subset<T, HistorialPdfAggregateArgs>): Prisma.PrismaPromise<GetHistorialPdfAggregateType<T>>

    /**
     * Group by HistorialPdf.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {HistorialPdfGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends HistorialPdfGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: HistorialPdfGroupByArgs['orderBy'] }
        : { orderBy?: HistorialPdfGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, HistorialPdfGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetHistorialPdfGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the HistorialPdf model
   */
  readonly fields: HistorialPdfFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for HistorialPdf.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__HistorialPdfClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proceso<T extends ProcesoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcesoDefaultArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the HistorialPdf model
   */ 
  interface HistorialPdfFieldRefs {
    readonly id: FieldRef<"HistorialPdf", 'String'>
    readonly procesoId: FieldRef<"HistorialPdf", 'String'>
    readonly version: FieldRef<"HistorialPdf", 'Int'>
    readonly pdfPath: FieldRef<"HistorialPdf", 'String'>
    readonly pdfHash: FieldRef<"HistorialPdf", 'String'>
    readonly creadoEn: FieldRef<"HistorialPdf", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * HistorialPdf findUnique
   */
  export type HistorialPdfFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPdf
     */
    select?: HistorialPdfSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPdfInclude<ExtArgs> | null
    /**
     * Filter, which HistorialPdf to fetch.
     */
    where: HistorialPdfWhereUniqueInput
  }

  /**
   * HistorialPdf findUniqueOrThrow
   */
  export type HistorialPdfFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPdf
     */
    select?: HistorialPdfSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPdfInclude<ExtArgs> | null
    /**
     * Filter, which HistorialPdf to fetch.
     */
    where: HistorialPdfWhereUniqueInput
  }

  /**
   * HistorialPdf findFirst
   */
  export type HistorialPdfFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPdf
     */
    select?: HistorialPdfSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPdfInclude<ExtArgs> | null
    /**
     * Filter, which HistorialPdf to fetch.
     */
    where?: HistorialPdfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialPdfs to fetch.
     */
    orderBy?: HistorialPdfOrderByWithRelationInput | HistorialPdfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistorialPdfs.
     */
    cursor?: HistorialPdfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialPdfs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialPdfs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistorialPdfs.
     */
    distinct?: HistorialPdfScalarFieldEnum | HistorialPdfScalarFieldEnum[]
  }

  /**
   * HistorialPdf findFirstOrThrow
   */
  export type HistorialPdfFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPdf
     */
    select?: HistorialPdfSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPdfInclude<ExtArgs> | null
    /**
     * Filter, which HistorialPdf to fetch.
     */
    where?: HistorialPdfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialPdfs to fetch.
     */
    orderBy?: HistorialPdfOrderByWithRelationInput | HistorialPdfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for HistorialPdfs.
     */
    cursor?: HistorialPdfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialPdfs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialPdfs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of HistorialPdfs.
     */
    distinct?: HistorialPdfScalarFieldEnum | HistorialPdfScalarFieldEnum[]
  }

  /**
   * HistorialPdf findMany
   */
  export type HistorialPdfFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPdf
     */
    select?: HistorialPdfSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPdfInclude<ExtArgs> | null
    /**
     * Filter, which HistorialPdfs to fetch.
     */
    where?: HistorialPdfWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of HistorialPdfs to fetch.
     */
    orderBy?: HistorialPdfOrderByWithRelationInput | HistorialPdfOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing HistorialPdfs.
     */
    cursor?: HistorialPdfWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` HistorialPdfs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` HistorialPdfs.
     */
    skip?: number
    distinct?: HistorialPdfScalarFieldEnum | HistorialPdfScalarFieldEnum[]
  }

  /**
   * HistorialPdf create
   */
  export type HistorialPdfCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPdf
     */
    select?: HistorialPdfSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPdfInclude<ExtArgs> | null
    /**
     * The data needed to create a HistorialPdf.
     */
    data: XOR<HistorialPdfCreateInput, HistorialPdfUncheckedCreateInput>
  }

  /**
   * HistorialPdf createMany
   */
  export type HistorialPdfCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many HistorialPdfs.
     */
    data: HistorialPdfCreateManyInput | HistorialPdfCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * HistorialPdf createManyAndReturn
   */
  export type HistorialPdfCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPdf
     */
    select?: HistorialPdfSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many HistorialPdfs.
     */
    data: HistorialPdfCreateManyInput | HistorialPdfCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPdfIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * HistorialPdf update
   */
  export type HistorialPdfUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPdf
     */
    select?: HistorialPdfSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPdfInclude<ExtArgs> | null
    /**
     * The data needed to update a HistorialPdf.
     */
    data: XOR<HistorialPdfUpdateInput, HistorialPdfUncheckedUpdateInput>
    /**
     * Choose, which HistorialPdf to update.
     */
    where: HistorialPdfWhereUniqueInput
  }

  /**
   * HistorialPdf updateMany
   */
  export type HistorialPdfUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update HistorialPdfs.
     */
    data: XOR<HistorialPdfUpdateManyMutationInput, HistorialPdfUncheckedUpdateManyInput>
    /**
     * Filter which HistorialPdfs to update
     */
    where?: HistorialPdfWhereInput
  }

  /**
   * HistorialPdf upsert
   */
  export type HistorialPdfUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPdf
     */
    select?: HistorialPdfSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPdfInclude<ExtArgs> | null
    /**
     * The filter to search for the HistorialPdf to update in case it exists.
     */
    where: HistorialPdfWhereUniqueInput
    /**
     * In case the HistorialPdf found by the `where` argument doesn't exist, create a new HistorialPdf with this data.
     */
    create: XOR<HistorialPdfCreateInput, HistorialPdfUncheckedCreateInput>
    /**
     * In case the HistorialPdf was found with the provided `where` argument, update it with this data.
     */
    update: XOR<HistorialPdfUpdateInput, HistorialPdfUncheckedUpdateInput>
  }

  /**
   * HistorialPdf delete
   */
  export type HistorialPdfDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPdf
     */
    select?: HistorialPdfSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPdfInclude<ExtArgs> | null
    /**
     * Filter which HistorialPdf to delete.
     */
    where: HistorialPdfWhereUniqueInput
  }

  /**
   * HistorialPdf deleteMany
   */
  export type HistorialPdfDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which HistorialPdfs to delete
     */
    where?: HistorialPdfWhereInput
  }

  /**
   * HistorialPdf without action
   */
  export type HistorialPdfDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the HistorialPdf
     */
    select?: HistorialPdfSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: HistorialPdfInclude<ExtArgs> | null
  }


  /**
   * Model Decision
   */

  export type AggregateDecision = {
    _count: DecisionCountAggregateOutputType | null
    _min: DecisionMinAggregateOutputType | null
    _max: DecisionMaxAggregateOutputType | null
  }

  export type DecisionMinAggregateOutputType = {
    id: string | null
    procesoId: string | null
    estadoAnterior: $Enums.EstadoProceso | null
    estadoNuevo: $Enums.EstadoProceso | null
    aprobado: boolean | null
    motivo: string | null
    usuarioId: string | null
    rol: $Enums.Rol | null
    ipAddress: string | null
    userAgent: string | null
    creadoEn: Date | null
  }

  export type DecisionMaxAggregateOutputType = {
    id: string | null
    procesoId: string | null
    estadoAnterior: $Enums.EstadoProceso | null
    estadoNuevo: $Enums.EstadoProceso | null
    aprobado: boolean | null
    motivo: string | null
    usuarioId: string | null
    rol: $Enums.Rol | null
    ipAddress: string | null
    userAgent: string | null
    creadoEn: Date | null
  }

  export type DecisionCountAggregateOutputType = {
    id: number
    procesoId: number
    estadoAnterior: number
    estadoNuevo: number
    aprobado: number
    motivo: number
    usuarioId: number
    rol: number
    ipAddress: number
    userAgent: number
    creadoEn: number
    _all: number
  }


  export type DecisionMinAggregateInputType = {
    id?: true
    procesoId?: true
    estadoAnterior?: true
    estadoNuevo?: true
    aprobado?: true
    motivo?: true
    usuarioId?: true
    rol?: true
    ipAddress?: true
    userAgent?: true
    creadoEn?: true
  }

  export type DecisionMaxAggregateInputType = {
    id?: true
    procesoId?: true
    estadoAnterior?: true
    estadoNuevo?: true
    aprobado?: true
    motivo?: true
    usuarioId?: true
    rol?: true
    ipAddress?: true
    userAgent?: true
    creadoEn?: true
  }

  export type DecisionCountAggregateInputType = {
    id?: true
    procesoId?: true
    estadoAnterior?: true
    estadoNuevo?: true
    aprobado?: true
    motivo?: true
    usuarioId?: true
    rol?: true
    ipAddress?: true
    userAgent?: true
    creadoEn?: true
    _all?: true
  }

  export type DecisionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Decision to aggregate.
     */
    where?: DecisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Decisions to fetch.
     */
    orderBy?: DecisionOrderByWithRelationInput | DecisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DecisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Decisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Decisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Decisions
    **/
    _count?: true | DecisionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DecisionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DecisionMaxAggregateInputType
  }

  export type GetDecisionAggregateType<T extends DecisionAggregateArgs> = {
        [P in keyof T & keyof AggregateDecision]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDecision[P]>
      : GetScalarType<T[P], AggregateDecision[P]>
  }




  export type DecisionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DecisionWhereInput
    orderBy?: DecisionOrderByWithAggregationInput | DecisionOrderByWithAggregationInput[]
    by: DecisionScalarFieldEnum[] | DecisionScalarFieldEnum
    having?: DecisionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DecisionCountAggregateInputType | true
    _min?: DecisionMinAggregateInputType
    _max?: DecisionMaxAggregateInputType
  }

  export type DecisionGroupByOutputType = {
    id: string
    procesoId: string
    estadoAnterior: $Enums.EstadoProceso
    estadoNuevo: $Enums.EstadoProceso
    aprobado: boolean
    motivo: string
    usuarioId: string
    rol: $Enums.Rol
    ipAddress: string
    userAgent: string
    creadoEn: Date
    _count: DecisionCountAggregateOutputType | null
    _min: DecisionMinAggregateOutputType | null
    _max: DecisionMaxAggregateOutputType | null
  }

  type GetDecisionGroupByPayload<T extends DecisionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DecisionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DecisionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DecisionGroupByOutputType[P]>
            : GetScalarType<T[P], DecisionGroupByOutputType[P]>
        }
      >
    >


  export type DecisionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procesoId?: boolean
    estadoAnterior?: boolean
    estadoNuevo?: boolean
    aprobado?: boolean
    motivo?: boolean
    usuarioId?: boolean
    rol?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    creadoEn?: boolean
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["decision"]>

  export type DecisionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procesoId?: boolean
    estadoAnterior?: boolean
    estadoNuevo?: boolean
    aprobado?: boolean
    motivo?: boolean
    usuarioId?: boolean
    rol?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    creadoEn?: boolean
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["decision"]>

  export type DecisionSelectScalar = {
    id?: boolean
    procesoId?: boolean
    estadoAnterior?: boolean
    estadoNuevo?: boolean
    aprobado?: boolean
    motivo?: boolean
    usuarioId?: boolean
    rol?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    creadoEn?: boolean
  }

  export type DecisionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }
  export type DecisionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proceso?: boolean | ProcesoDefaultArgs<ExtArgs>
    usuario?: boolean | UsuarioDefaultArgs<ExtArgs>
  }

  export type $DecisionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Decision"
    objects: {
      proceso: Prisma.$ProcesoPayload<ExtArgs>
      usuario: Prisma.$UsuarioPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      procesoId: string
      estadoAnterior: $Enums.EstadoProceso
      estadoNuevo: $Enums.EstadoProceso
      aprobado: boolean
      motivo: string
      usuarioId: string
      rol: $Enums.Rol
      ipAddress: string
      userAgent: string
      creadoEn: Date
    }, ExtArgs["result"]["decision"]>
    composites: {}
  }

  type DecisionGetPayload<S extends boolean | null | undefined | DecisionDefaultArgs> = $Result.GetResult<Prisma.$DecisionPayload, S>

  type DecisionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DecisionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DecisionCountAggregateInputType | true
    }

  export interface DecisionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Decision'], meta: { name: 'Decision' } }
    /**
     * Find zero or one Decision that matches the filter.
     * @param {DecisionFindUniqueArgs} args - Arguments to find a Decision
     * @example
     * // Get one Decision
     * const decision = await prisma.decision.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DecisionFindUniqueArgs>(args: SelectSubset<T, DecisionFindUniqueArgs<ExtArgs>>): Prisma__DecisionClient<$Result.GetResult<Prisma.$DecisionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Decision that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DecisionFindUniqueOrThrowArgs} args - Arguments to find a Decision
     * @example
     * // Get one Decision
     * const decision = await prisma.decision.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DecisionFindUniqueOrThrowArgs>(args: SelectSubset<T, DecisionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DecisionClient<$Result.GetResult<Prisma.$DecisionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Decision that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionFindFirstArgs} args - Arguments to find a Decision
     * @example
     * // Get one Decision
     * const decision = await prisma.decision.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DecisionFindFirstArgs>(args?: SelectSubset<T, DecisionFindFirstArgs<ExtArgs>>): Prisma__DecisionClient<$Result.GetResult<Prisma.$DecisionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Decision that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionFindFirstOrThrowArgs} args - Arguments to find a Decision
     * @example
     * // Get one Decision
     * const decision = await prisma.decision.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DecisionFindFirstOrThrowArgs>(args?: SelectSubset<T, DecisionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DecisionClient<$Result.GetResult<Prisma.$DecisionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Decisions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Decisions
     * const decisions = await prisma.decision.findMany()
     * 
     * // Get first 10 Decisions
     * const decisions = await prisma.decision.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const decisionWithIdOnly = await prisma.decision.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DecisionFindManyArgs>(args?: SelectSubset<T, DecisionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Decision.
     * @param {DecisionCreateArgs} args - Arguments to create a Decision.
     * @example
     * // Create one Decision
     * const Decision = await prisma.decision.create({
     *   data: {
     *     // ... data to create a Decision
     *   }
     * })
     * 
     */
    create<T extends DecisionCreateArgs>(args: SelectSubset<T, DecisionCreateArgs<ExtArgs>>): Prisma__DecisionClient<$Result.GetResult<Prisma.$DecisionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Decisions.
     * @param {DecisionCreateManyArgs} args - Arguments to create many Decisions.
     * @example
     * // Create many Decisions
     * const decision = await prisma.decision.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DecisionCreateManyArgs>(args?: SelectSubset<T, DecisionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Decisions and returns the data saved in the database.
     * @param {DecisionCreateManyAndReturnArgs} args - Arguments to create many Decisions.
     * @example
     * // Create many Decisions
     * const decision = await prisma.decision.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Decisions and only return the `id`
     * const decisionWithIdOnly = await prisma.decision.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DecisionCreateManyAndReturnArgs>(args?: SelectSubset<T, DecisionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DecisionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Decision.
     * @param {DecisionDeleteArgs} args - Arguments to delete one Decision.
     * @example
     * // Delete one Decision
     * const Decision = await prisma.decision.delete({
     *   where: {
     *     // ... filter to delete one Decision
     *   }
     * })
     * 
     */
    delete<T extends DecisionDeleteArgs>(args: SelectSubset<T, DecisionDeleteArgs<ExtArgs>>): Prisma__DecisionClient<$Result.GetResult<Prisma.$DecisionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Decision.
     * @param {DecisionUpdateArgs} args - Arguments to update one Decision.
     * @example
     * // Update one Decision
     * const decision = await prisma.decision.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DecisionUpdateArgs>(args: SelectSubset<T, DecisionUpdateArgs<ExtArgs>>): Prisma__DecisionClient<$Result.GetResult<Prisma.$DecisionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Decisions.
     * @param {DecisionDeleteManyArgs} args - Arguments to filter Decisions to delete.
     * @example
     * // Delete a few Decisions
     * const { count } = await prisma.decision.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DecisionDeleteManyArgs>(args?: SelectSubset<T, DecisionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Decisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Decisions
     * const decision = await prisma.decision.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DecisionUpdateManyArgs>(args: SelectSubset<T, DecisionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Decision.
     * @param {DecisionUpsertArgs} args - Arguments to update or create a Decision.
     * @example
     * // Update or create a Decision
     * const decision = await prisma.decision.upsert({
     *   create: {
     *     // ... data to create a Decision
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Decision we want to update
     *   }
     * })
     */
    upsert<T extends DecisionUpsertArgs>(args: SelectSubset<T, DecisionUpsertArgs<ExtArgs>>): Prisma__DecisionClient<$Result.GetResult<Prisma.$DecisionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Decisions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionCountArgs} args - Arguments to filter Decisions to count.
     * @example
     * // Count the number of Decisions
     * const count = await prisma.decision.count({
     *   where: {
     *     // ... the filter for the Decisions we want to count
     *   }
     * })
    **/
    count<T extends DecisionCountArgs>(
      args?: Subset<T, DecisionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DecisionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Decision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DecisionAggregateArgs>(args: Subset<T, DecisionAggregateArgs>): Prisma.PrismaPromise<GetDecisionAggregateType<T>>

    /**
     * Group by Decision.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DecisionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DecisionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DecisionGroupByArgs['orderBy'] }
        : { orderBy?: DecisionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DecisionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDecisionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Decision model
   */
  readonly fields: DecisionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Decision.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DecisionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proceso<T extends ProcesoDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ProcesoDefaultArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    usuario<T extends UsuarioDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UsuarioDefaultArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Decision model
   */ 
  interface DecisionFieldRefs {
    readonly id: FieldRef<"Decision", 'String'>
    readonly procesoId: FieldRef<"Decision", 'String'>
    readonly estadoAnterior: FieldRef<"Decision", 'EstadoProceso'>
    readonly estadoNuevo: FieldRef<"Decision", 'EstadoProceso'>
    readonly aprobado: FieldRef<"Decision", 'Boolean'>
    readonly motivo: FieldRef<"Decision", 'String'>
    readonly usuarioId: FieldRef<"Decision", 'String'>
    readonly rol: FieldRef<"Decision", 'Rol'>
    readonly ipAddress: FieldRef<"Decision", 'String'>
    readonly userAgent: FieldRef<"Decision", 'String'>
    readonly creadoEn: FieldRef<"Decision", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Decision findUnique
   */
  export type DecisionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decision
     */
    select?: DecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionInclude<ExtArgs> | null
    /**
     * Filter, which Decision to fetch.
     */
    where: DecisionWhereUniqueInput
  }

  /**
   * Decision findUniqueOrThrow
   */
  export type DecisionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decision
     */
    select?: DecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionInclude<ExtArgs> | null
    /**
     * Filter, which Decision to fetch.
     */
    where: DecisionWhereUniqueInput
  }

  /**
   * Decision findFirst
   */
  export type DecisionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decision
     */
    select?: DecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionInclude<ExtArgs> | null
    /**
     * Filter, which Decision to fetch.
     */
    where?: DecisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Decisions to fetch.
     */
    orderBy?: DecisionOrderByWithRelationInput | DecisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Decisions.
     */
    cursor?: DecisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Decisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Decisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Decisions.
     */
    distinct?: DecisionScalarFieldEnum | DecisionScalarFieldEnum[]
  }

  /**
   * Decision findFirstOrThrow
   */
  export type DecisionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decision
     */
    select?: DecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionInclude<ExtArgs> | null
    /**
     * Filter, which Decision to fetch.
     */
    where?: DecisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Decisions to fetch.
     */
    orderBy?: DecisionOrderByWithRelationInput | DecisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Decisions.
     */
    cursor?: DecisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Decisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Decisions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Decisions.
     */
    distinct?: DecisionScalarFieldEnum | DecisionScalarFieldEnum[]
  }

  /**
   * Decision findMany
   */
  export type DecisionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decision
     */
    select?: DecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionInclude<ExtArgs> | null
    /**
     * Filter, which Decisions to fetch.
     */
    where?: DecisionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Decisions to fetch.
     */
    orderBy?: DecisionOrderByWithRelationInput | DecisionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Decisions.
     */
    cursor?: DecisionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Decisions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Decisions.
     */
    skip?: number
    distinct?: DecisionScalarFieldEnum | DecisionScalarFieldEnum[]
  }

  /**
   * Decision create
   */
  export type DecisionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decision
     */
    select?: DecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionInclude<ExtArgs> | null
    /**
     * The data needed to create a Decision.
     */
    data: XOR<DecisionCreateInput, DecisionUncheckedCreateInput>
  }

  /**
   * Decision createMany
   */
  export type DecisionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Decisions.
     */
    data: DecisionCreateManyInput | DecisionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Decision createManyAndReturn
   */
  export type DecisionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decision
     */
    select?: DecisionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Decisions.
     */
    data: DecisionCreateManyInput | DecisionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Decision update
   */
  export type DecisionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decision
     */
    select?: DecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionInclude<ExtArgs> | null
    /**
     * The data needed to update a Decision.
     */
    data: XOR<DecisionUpdateInput, DecisionUncheckedUpdateInput>
    /**
     * Choose, which Decision to update.
     */
    where: DecisionWhereUniqueInput
  }

  /**
   * Decision updateMany
   */
  export type DecisionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Decisions.
     */
    data: XOR<DecisionUpdateManyMutationInput, DecisionUncheckedUpdateManyInput>
    /**
     * Filter which Decisions to update
     */
    where?: DecisionWhereInput
  }

  /**
   * Decision upsert
   */
  export type DecisionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decision
     */
    select?: DecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionInclude<ExtArgs> | null
    /**
     * The filter to search for the Decision to update in case it exists.
     */
    where: DecisionWhereUniqueInput
    /**
     * In case the Decision found by the `where` argument doesn't exist, create a new Decision with this data.
     */
    create: XOR<DecisionCreateInput, DecisionUncheckedCreateInput>
    /**
     * In case the Decision was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DecisionUpdateInput, DecisionUncheckedUpdateInput>
  }

  /**
   * Decision delete
   */
  export type DecisionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decision
     */
    select?: DecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionInclude<ExtArgs> | null
    /**
     * Filter which Decision to delete.
     */
    where: DecisionWhereUniqueInput
  }

  /**
   * Decision deleteMany
   */
  export type DecisionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Decisions to delete
     */
    where?: DecisionWhereInput
  }

  /**
   * Decision without action
   */
  export type DecisionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Decision
     */
    select?: DecisionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DecisionInclude<ExtArgs> | null
  }


  /**
   * Model EventoAuditoria
   */

  export type AggregateEventoAuditoria = {
    _count: EventoAuditoriaCountAggregateOutputType | null
    _min: EventoAuditoriaMinAggregateOutputType | null
    _max: EventoAuditoriaMaxAggregateOutputType | null
  }

  export type EventoAuditoriaMinAggregateOutputType = {
    id: string | null
    procesoId: string | null
    usuarioId: string | null
    tipo: $Enums.TipoEvento | null
    descripcion: string | null
    ipAddress: string | null
    userAgent: string | null
    creadoEn: Date | null
  }

  export type EventoAuditoriaMaxAggregateOutputType = {
    id: string | null
    procesoId: string | null
    usuarioId: string | null
    tipo: $Enums.TipoEvento | null
    descripcion: string | null
    ipAddress: string | null
    userAgent: string | null
    creadoEn: Date | null
  }

  export type EventoAuditoriaCountAggregateOutputType = {
    id: number
    procesoId: number
    usuarioId: number
    tipo: number
    descripcion: number
    detalles: number
    ipAddress: number
    userAgent: number
    creadoEn: number
    _all: number
  }


  export type EventoAuditoriaMinAggregateInputType = {
    id?: true
    procesoId?: true
    usuarioId?: true
    tipo?: true
    descripcion?: true
    ipAddress?: true
    userAgent?: true
    creadoEn?: true
  }

  export type EventoAuditoriaMaxAggregateInputType = {
    id?: true
    procesoId?: true
    usuarioId?: true
    tipo?: true
    descripcion?: true
    ipAddress?: true
    userAgent?: true
    creadoEn?: true
  }

  export type EventoAuditoriaCountAggregateInputType = {
    id?: true
    procesoId?: true
    usuarioId?: true
    tipo?: true
    descripcion?: true
    detalles?: true
    ipAddress?: true
    userAgent?: true
    creadoEn?: true
    _all?: true
  }

  export type EventoAuditoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventoAuditoria to aggregate.
     */
    where?: EventoAuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventoAuditorias to fetch.
     */
    orderBy?: EventoAuditoriaOrderByWithRelationInput | EventoAuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventoAuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventoAuditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventoAuditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventoAuditorias
    **/
    _count?: true | EventoAuditoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventoAuditoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventoAuditoriaMaxAggregateInputType
  }

  export type GetEventoAuditoriaAggregateType<T extends EventoAuditoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateEventoAuditoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventoAuditoria[P]>
      : GetScalarType<T[P], AggregateEventoAuditoria[P]>
  }




  export type EventoAuditoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventoAuditoriaWhereInput
    orderBy?: EventoAuditoriaOrderByWithAggregationInput | EventoAuditoriaOrderByWithAggregationInput[]
    by: EventoAuditoriaScalarFieldEnum[] | EventoAuditoriaScalarFieldEnum
    having?: EventoAuditoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventoAuditoriaCountAggregateInputType | true
    _min?: EventoAuditoriaMinAggregateInputType
    _max?: EventoAuditoriaMaxAggregateInputType
  }

  export type EventoAuditoriaGroupByOutputType = {
    id: string
    procesoId: string | null
    usuarioId: string | null
    tipo: $Enums.TipoEvento
    descripcion: string
    detalles: JsonValue | null
    ipAddress: string
    userAgent: string
    creadoEn: Date
    _count: EventoAuditoriaCountAggregateOutputType | null
    _min: EventoAuditoriaMinAggregateOutputType | null
    _max: EventoAuditoriaMaxAggregateOutputType | null
  }

  type GetEventoAuditoriaGroupByPayload<T extends EventoAuditoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventoAuditoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventoAuditoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventoAuditoriaGroupByOutputType[P]>
            : GetScalarType<T[P], EventoAuditoriaGroupByOutputType[P]>
        }
      >
    >


  export type EventoAuditoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procesoId?: boolean
    usuarioId?: boolean
    tipo?: boolean
    descripcion?: boolean
    detalles?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    creadoEn?: boolean
    proceso?: boolean | EventoAuditoria$procesoArgs<ExtArgs>
    usuario?: boolean | EventoAuditoria$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["eventoAuditoria"]>

  export type EventoAuditoriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    procesoId?: boolean
    usuarioId?: boolean
    tipo?: boolean
    descripcion?: boolean
    detalles?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    creadoEn?: boolean
    proceso?: boolean | EventoAuditoria$procesoArgs<ExtArgs>
    usuario?: boolean | EventoAuditoria$usuarioArgs<ExtArgs>
  }, ExtArgs["result"]["eventoAuditoria"]>

  export type EventoAuditoriaSelectScalar = {
    id?: boolean
    procesoId?: boolean
    usuarioId?: boolean
    tipo?: boolean
    descripcion?: boolean
    detalles?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    creadoEn?: boolean
  }

  export type EventoAuditoriaInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proceso?: boolean | EventoAuditoria$procesoArgs<ExtArgs>
    usuario?: boolean | EventoAuditoria$usuarioArgs<ExtArgs>
  }
  export type EventoAuditoriaIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    proceso?: boolean | EventoAuditoria$procesoArgs<ExtArgs>
    usuario?: boolean | EventoAuditoria$usuarioArgs<ExtArgs>
  }

  export type $EventoAuditoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventoAuditoria"
    objects: {
      proceso: Prisma.$ProcesoPayload<ExtArgs> | null
      usuario: Prisma.$UsuarioPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      procesoId: string | null
      usuarioId: string | null
      tipo: $Enums.TipoEvento
      descripcion: string
      detalles: Prisma.JsonValue | null
      ipAddress: string
      userAgent: string
      creadoEn: Date
    }, ExtArgs["result"]["eventoAuditoria"]>
    composites: {}
  }

  type EventoAuditoriaGetPayload<S extends boolean | null | undefined | EventoAuditoriaDefaultArgs> = $Result.GetResult<Prisma.$EventoAuditoriaPayload, S>

  type EventoAuditoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventoAuditoriaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventoAuditoriaCountAggregateInputType | true
    }

  export interface EventoAuditoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventoAuditoria'], meta: { name: 'EventoAuditoria' } }
    /**
     * Find zero or one EventoAuditoria that matches the filter.
     * @param {EventoAuditoriaFindUniqueArgs} args - Arguments to find a EventoAuditoria
     * @example
     * // Get one EventoAuditoria
     * const eventoAuditoria = await prisma.eventoAuditoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventoAuditoriaFindUniqueArgs>(args: SelectSubset<T, EventoAuditoriaFindUniqueArgs<ExtArgs>>): Prisma__EventoAuditoriaClient<$Result.GetResult<Prisma.$EventoAuditoriaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventoAuditoria that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventoAuditoriaFindUniqueOrThrowArgs} args - Arguments to find a EventoAuditoria
     * @example
     * // Get one EventoAuditoria
     * const eventoAuditoria = await prisma.eventoAuditoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventoAuditoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, EventoAuditoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventoAuditoriaClient<$Result.GetResult<Prisma.$EventoAuditoriaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventoAuditoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoAuditoriaFindFirstArgs} args - Arguments to find a EventoAuditoria
     * @example
     * // Get one EventoAuditoria
     * const eventoAuditoria = await prisma.eventoAuditoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventoAuditoriaFindFirstArgs>(args?: SelectSubset<T, EventoAuditoriaFindFirstArgs<ExtArgs>>): Prisma__EventoAuditoriaClient<$Result.GetResult<Prisma.$EventoAuditoriaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventoAuditoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoAuditoriaFindFirstOrThrowArgs} args - Arguments to find a EventoAuditoria
     * @example
     * // Get one EventoAuditoria
     * const eventoAuditoria = await prisma.eventoAuditoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventoAuditoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, EventoAuditoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventoAuditoriaClient<$Result.GetResult<Prisma.$EventoAuditoriaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventoAuditorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoAuditoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventoAuditorias
     * const eventoAuditorias = await prisma.eventoAuditoria.findMany()
     * 
     * // Get first 10 EventoAuditorias
     * const eventoAuditorias = await prisma.eventoAuditoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventoAuditoriaWithIdOnly = await prisma.eventoAuditoria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventoAuditoriaFindManyArgs>(args?: SelectSubset<T, EventoAuditoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoAuditoriaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventoAuditoria.
     * @param {EventoAuditoriaCreateArgs} args - Arguments to create a EventoAuditoria.
     * @example
     * // Create one EventoAuditoria
     * const EventoAuditoria = await prisma.eventoAuditoria.create({
     *   data: {
     *     // ... data to create a EventoAuditoria
     *   }
     * })
     * 
     */
    create<T extends EventoAuditoriaCreateArgs>(args: SelectSubset<T, EventoAuditoriaCreateArgs<ExtArgs>>): Prisma__EventoAuditoriaClient<$Result.GetResult<Prisma.$EventoAuditoriaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventoAuditorias.
     * @param {EventoAuditoriaCreateManyArgs} args - Arguments to create many EventoAuditorias.
     * @example
     * // Create many EventoAuditorias
     * const eventoAuditoria = await prisma.eventoAuditoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventoAuditoriaCreateManyArgs>(args?: SelectSubset<T, EventoAuditoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EventoAuditorias and returns the data saved in the database.
     * @param {EventoAuditoriaCreateManyAndReturnArgs} args - Arguments to create many EventoAuditorias.
     * @example
     * // Create many EventoAuditorias
     * const eventoAuditoria = await prisma.eventoAuditoria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EventoAuditorias and only return the `id`
     * const eventoAuditoriaWithIdOnly = await prisma.eventoAuditoria.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EventoAuditoriaCreateManyAndReturnArgs>(args?: SelectSubset<T, EventoAuditoriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventoAuditoriaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EventoAuditoria.
     * @param {EventoAuditoriaDeleteArgs} args - Arguments to delete one EventoAuditoria.
     * @example
     * // Delete one EventoAuditoria
     * const EventoAuditoria = await prisma.eventoAuditoria.delete({
     *   where: {
     *     // ... filter to delete one EventoAuditoria
     *   }
     * })
     * 
     */
    delete<T extends EventoAuditoriaDeleteArgs>(args: SelectSubset<T, EventoAuditoriaDeleteArgs<ExtArgs>>): Prisma__EventoAuditoriaClient<$Result.GetResult<Prisma.$EventoAuditoriaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventoAuditoria.
     * @param {EventoAuditoriaUpdateArgs} args - Arguments to update one EventoAuditoria.
     * @example
     * // Update one EventoAuditoria
     * const eventoAuditoria = await prisma.eventoAuditoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventoAuditoriaUpdateArgs>(args: SelectSubset<T, EventoAuditoriaUpdateArgs<ExtArgs>>): Prisma__EventoAuditoriaClient<$Result.GetResult<Prisma.$EventoAuditoriaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventoAuditorias.
     * @param {EventoAuditoriaDeleteManyArgs} args - Arguments to filter EventoAuditorias to delete.
     * @example
     * // Delete a few EventoAuditorias
     * const { count } = await prisma.eventoAuditoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventoAuditoriaDeleteManyArgs>(args?: SelectSubset<T, EventoAuditoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventoAuditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoAuditoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventoAuditorias
     * const eventoAuditoria = await prisma.eventoAuditoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventoAuditoriaUpdateManyArgs>(args: SelectSubset<T, EventoAuditoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventoAuditoria.
     * @param {EventoAuditoriaUpsertArgs} args - Arguments to update or create a EventoAuditoria.
     * @example
     * // Update or create a EventoAuditoria
     * const eventoAuditoria = await prisma.eventoAuditoria.upsert({
     *   create: {
     *     // ... data to create a EventoAuditoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventoAuditoria we want to update
     *   }
     * })
     */
    upsert<T extends EventoAuditoriaUpsertArgs>(args: SelectSubset<T, EventoAuditoriaUpsertArgs<ExtArgs>>): Prisma__EventoAuditoriaClient<$Result.GetResult<Prisma.$EventoAuditoriaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventoAuditorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoAuditoriaCountArgs} args - Arguments to filter EventoAuditorias to count.
     * @example
     * // Count the number of EventoAuditorias
     * const count = await prisma.eventoAuditoria.count({
     *   where: {
     *     // ... the filter for the EventoAuditorias we want to count
     *   }
     * })
    **/
    count<T extends EventoAuditoriaCountArgs>(
      args?: Subset<T, EventoAuditoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventoAuditoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventoAuditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoAuditoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventoAuditoriaAggregateArgs>(args: Subset<T, EventoAuditoriaAggregateArgs>): Prisma.PrismaPromise<GetEventoAuditoriaAggregateType<T>>

    /**
     * Group by EventoAuditoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventoAuditoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventoAuditoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventoAuditoriaGroupByArgs['orderBy'] }
        : { orderBy?: EventoAuditoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventoAuditoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventoAuditoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventoAuditoria model
   */
  readonly fields: EventoAuditoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventoAuditoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventoAuditoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    proceso<T extends EventoAuditoria$procesoArgs<ExtArgs> = {}>(args?: Subset<T, EventoAuditoria$procesoArgs<ExtArgs>>): Prisma__ProcesoClient<$Result.GetResult<Prisma.$ProcesoPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    usuario<T extends EventoAuditoria$usuarioArgs<ExtArgs> = {}>(args?: Subset<T, EventoAuditoria$usuarioArgs<ExtArgs>>): Prisma__UsuarioClient<$Result.GetResult<Prisma.$UsuarioPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventoAuditoria model
   */ 
  interface EventoAuditoriaFieldRefs {
    readonly id: FieldRef<"EventoAuditoria", 'String'>
    readonly procesoId: FieldRef<"EventoAuditoria", 'String'>
    readonly usuarioId: FieldRef<"EventoAuditoria", 'String'>
    readonly tipo: FieldRef<"EventoAuditoria", 'TipoEvento'>
    readonly descripcion: FieldRef<"EventoAuditoria", 'String'>
    readonly detalles: FieldRef<"EventoAuditoria", 'Json'>
    readonly ipAddress: FieldRef<"EventoAuditoria", 'String'>
    readonly userAgent: FieldRef<"EventoAuditoria", 'String'>
    readonly creadoEn: FieldRef<"EventoAuditoria", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventoAuditoria findUnique
   */
  export type EventoAuditoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAuditoria
     */
    select?: EventoAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which EventoAuditoria to fetch.
     */
    where: EventoAuditoriaWhereUniqueInput
  }

  /**
   * EventoAuditoria findUniqueOrThrow
   */
  export type EventoAuditoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAuditoria
     */
    select?: EventoAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which EventoAuditoria to fetch.
     */
    where: EventoAuditoriaWhereUniqueInput
  }

  /**
   * EventoAuditoria findFirst
   */
  export type EventoAuditoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAuditoria
     */
    select?: EventoAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which EventoAuditoria to fetch.
     */
    where?: EventoAuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventoAuditorias to fetch.
     */
    orderBy?: EventoAuditoriaOrderByWithRelationInput | EventoAuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventoAuditorias.
     */
    cursor?: EventoAuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventoAuditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventoAuditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventoAuditorias.
     */
    distinct?: EventoAuditoriaScalarFieldEnum | EventoAuditoriaScalarFieldEnum[]
  }

  /**
   * EventoAuditoria findFirstOrThrow
   */
  export type EventoAuditoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAuditoria
     */
    select?: EventoAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which EventoAuditoria to fetch.
     */
    where?: EventoAuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventoAuditorias to fetch.
     */
    orderBy?: EventoAuditoriaOrderByWithRelationInput | EventoAuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventoAuditorias.
     */
    cursor?: EventoAuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventoAuditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventoAuditorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventoAuditorias.
     */
    distinct?: EventoAuditoriaScalarFieldEnum | EventoAuditoriaScalarFieldEnum[]
  }

  /**
   * EventoAuditoria findMany
   */
  export type EventoAuditoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAuditoria
     */
    select?: EventoAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAuditoriaInclude<ExtArgs> | null
    /**
     * Filter, which EventoAuditorias to fetch.
     */
    where?: EventoAuditoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventoAuditorias to fetch.
     */
    orderBy?: EventoAuditoriaOrderByWithRelationInput | EventoAuditoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventoAuditorias.
     */
    cursor?: EventoAuditoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventoAuditorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventoAuditorias.
     */
    skip?: number
    distinct?: EventoAuditoriaScalarFieldEnum | EventoAuditoriaScalarFieldEnum[]
  }

  /**
   * EventoAuditoria create
   */
  export type EventoAuditoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAuditoria
     */
    select?: EventoAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAuditoriaInclude<ExtArgs> | null
    /**
     * The data needed to create a EventoAuditoria.
     */
    data: XOR<EventoAuditoriaCreateInput, EventoAuditoriaUncheckedCreateInput>
  }

  /**
   * EventoAuditoria createMany
   */
  export type EventoAuditoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventoAuditorias.
     */
    data: EventoAuditoriaCreateManyInput | EventoAuditoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventoAuditoria createManyAndReturn
   */
  export type EventoAuditoriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAuditoria
     */
    select?: EventoAuditoriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EventoAuditorias.
     */
    data: EventoAuditoriaCreateManyInput | EventoAuditoriaCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAuditoriaIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EventoAuditoria update
   */
  export type EventoAuditoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAuditoria
     */
    select?: EventoAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAuditoriaInclude<ExtArgs> | null
    /**
     * The data needed to update a EventoAuditoria.
     */
    data: XOR<EventoAuditoriaUpdateInput, EventoAuditoriaUncheckedUpdateInput>
    /**
     * Choose, which EventoAuditoria to update.
     */
    where: EventoAuditoriaWhereUniqueInput
  }

  /**
   * EventoAuditoria updateMany
   */
  export type EventoAuditoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventoAuditorias.
     */
    data: XOR<EventoAuditoriaUpdateManyMutationInput, EventoAuditoriaUncheckedUpdateManyInput>
    /**
     * Filter which EventoAuditorias to update
     */
    where?: EventoAuditoriaWhereInput
  }

  /**
   * EventoAuditoria upsert
   */
  export type EventoAuditoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAuditoria
     */
    select?: EventoAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAuditoriaInclude<ExtArgs> | null
    /**
     * The filter to search for the EventoAuditoria to update in case it exists.
     */
    where: EventoAuditoriaWhereUniqueInput
    /**
     * In case the EventoAuditoria found by the `where` argument doesn't exist, create a new EventoAuditoria with this data.
     */
    create: XOR<EventoAuditoriaCreateInput, EventoAuditoriaUncheckedCreateInput>
    /**
     * In case the EventoAuditoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventoAuditoriaUpdateInput, EventoAuditoriaUncheckedUpdateInput>
  }

  /**
   * EventoAuditoria delete
   */
  export type EventoAuditoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAuditoria
     */
    select?: EventoAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAuditoriaInclude<ExtArgs> | null
    /**
     * Filter which EventoAuditoria to delete.
     */
    where: EventoAuditoriaWhereUniqueInput
  }

  /**
   * EventoAuditoria deleteMany
   */
  export type EventoAuditoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventoAuditorias to delete
     */
    where?: EventoAuditoriaWhereInput
  }

  /**
   * EventoAuditoria.proceso
   */
  export type EventoAuditoria$procesoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Proceso
     */
    select?: ProcesoSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ProcesoInclude<ExtArgs> | null
    where?: ProcesoWhereInput
  }

  /**
   * EventoAuditoria.usuario
   */
  export type EventoAuditoria$usuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Usuario
     */
    select?: UsuarioSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UsuarioInclude<ExtArgs> | null
    where?: UsuarioWhereInput
  }

  /**
   * EventoAuditoria without action
   */
  export type EventoAuditoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventoAuditoria
     */
    select?: EventoAuditoriaSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventoAuditoriaInclude<ExtArgs> | null
  }


  /**
   * Model Configuracion
   */

  export type AggregateConfiguracion = {
    _count: ConfiguracionCountAggregateOutputType | null
    _min: ConfiguracionMinAggregateOutputType | null
    _max: ConfiguracionMaxAggregateOutputType | null
  }

  export type ConfiguracionMinAggregateOutputType = {
    id: string | null
    clave: string | null
    valor: string | null
    descripcion: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type ConfiguracionMaxAggregateOutputType = {
    id: string | null
    clave: string | null
    valor: string | null
    descripcion: string | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type ConfiguracionCountAggregateOutputType = {
    id: number
    clave: number
    valor: number
    descripcion: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type ConfiguracionMinAggregateInputType = {
    id?: true
    clave?: true
    valor?: true
    descripcion?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type ConfiguracionMaxAggregateInputType = {
    id?: true
    clave?: true
    valor?: true
    descripcion?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type ConfiguracionCountAggregateInputType = {
    id?: true
    clave?: true
    valor?: true
    descripcion?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type ConfiguracionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Configuracion to aggregate.
     */
    where?: ConfiguracionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configuracions to fetch.
     */
    orderBy?: ConfiguracionOrderByWithRelationInput | ConfiguracionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConfiguracionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configuracions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configuracions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Configuracions
    **/
    _count?: true | ConfiguracionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConfiguracionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConfiguracionMaxAggregateInputType
  }

  export type GetConfiguracionAggregateType<T extends ConfiguracionAggregateArgs> = {
        [P in keyof T & keyof AggregateConfiguracion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConfiguracion[P]>
      : GetScalarType<T[P], AggregateConfiguracion[P]>
  }




  export type ConfiguracionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConfiguracionWhereInput
    orderBy?: ConfiguracionOrderByWithAggregationInput | ConfiguracionOrderByWithAggregationInput[]
    by: ConfiguracionScalarFieldEnum[] | ConfiguracionScalarFieldEnum
    having?: ConfiguracionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConfiguracionCountAggregateInputType | true
    _min?: ConfiguracionMinAggregateInputType
    _max?: ConfiguracionMaxAggregateInputType
  }

  export type ConfiguracionGroupByOutputType = {
    id: string
    clave: string
    valor: string
    descripcion: string | null
    creadoEn: Date
    actualizadoEn: Date
    _count: ConfiguracionCountAggregateOutputType | null
    _min: ConfiguracionMinAggregateOutputType | null
    _max: ConfiguracionMaxAggregateOutputType | null
  }

  type GetConfiguracionGroupByPayload<T extends ConfiguracionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConfiguracionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConfiguracionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConfiguracionGroupByOutputType[P]>
            : GetScalarType<T[P], ConfiguracionGroupByOutputType[P]>
        }
      >
    >


  export type ConfiguracionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clave?: boolean
    valor?: boolean
    descripcion?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["configuracion"]>

  export type ConfiguracionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    clave?: boolean
    valor?: boolean
    descripcion?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["configuracion"]>

  export type ConfiguracionSelectScalar = {
    id?: boolean
    clave?: boolean
    valor?: boolean
    descripcion?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }


  export type $ConfiguracionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Configuracion"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      clave: string
      valor: string
      descripcion: string | null
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["configuracion"]>
    composites: {}
  }

  type ConfiguracionGetPayload<S extends boolean | null | undefined | ConfiguracionDefaultArgs> = $Result.GetResult<Prisma.$ConfiguracionPayload, S>

  type ConfiguracionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConfiguracionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConfiguracionCountAggregateInputType | true
    }

  export interface ConfiguracionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Configuracion'], meta: { name: 'Configuracion' } }
    /**
     * Find zero or one Configuracion that matches the filter.
     * @param {ConfiguracionFindUniqueArgs} args - Arguments to find a Configuracion
     * @example
     * // Get one Configuracion
     * const configuracion = await prisma.configuracion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConfiguracionFindUniqueArgs>(args: SelectSubset<T, ConfiguracionFindUniqueArgs<ExtArgs>>): Prisma__ConfiguracionClient<$Result.GetResult<Prisma.$ConfiguracionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Configuracion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConfiguracionFindUniqueOrThrowArgs} args - Arguments to find a Configuracion
     * @example
     * // Get one Configuracion
     * const configuracion = await prisma.configuracion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConfiguracionFindUniqueOrThrowArgs>(args: SelectSubset<T, ConfiguracionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConfiguracionClient<$Result.GetResult<Prisma.$ConfiguracionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Configuracion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionFindFirstArgs} args - Arguments to find a Configuracion
     * @example
     * // Get one Configuracion
     * const configuracion = await prisma.configuracion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConfiguracionFindFirstArgs>(args?: SelectSubset<T, ConfiguracionFindFirstArgs<ExtArgs>>): Prisma__ConfiguracionClient<$Result.GetResult<Prisma.$ConfiguracionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Configuracion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionFindFirstOrThrowArgs} args - Arguments to find a Configuracion
     * @example
     * // Get one Configuracion
     * const configuracion = await prisma.configuracion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConfiguracionFindFirstOrThrowArgs>(args?: SelectSubset<T, ConfiguracionFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConfiguracionClient<$Result.GetResult<Prisma.$ConfiguracionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Configuracions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Configuracions
     * const configuracions = await prisma.configuracion.findMany()
     * 
     * // Get first 10 Configuracions
     * const configuracions = await prisma.configuracion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const configuracionWithIdOnly = await prisma.configuracion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConfiguracionFindManyArgs>(args?: SelectSubset<T, ConfiguracionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfiguracionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Configuracion.
     * @param {ConfiguracionCreateArgs} args - Arguments to create a Configuracion.
     * @example
     * // Create one Configuracion
     * const Configuracion = await prisma.configuracion.create({
     *   data: {
     *     // ... data to create a Configuracion
     *   }
     * })
     * 
     */
    create<T extends ConfiguracionCreateArgs>(args: SelectSubset<T, ConfiguracionCreateArgs<ExtArgs>>): Prisma__ConfiguracionClient<$Result.GetResult<Prisma.$ConfiguracionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Configuracions.
     * @param {ConfiguracionCreateManyArgs} args - Arguments to create many Configuracions.
     * @example
     * // Create many Configuracions
     * const configuracion = await prisma.configuracion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConfiguracionCreateManyArgs>(args?: SelectSubset<T, ConfiguracionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Configuracions and returns the data saved in the database.
     * @param {ConfiguracionCreateManyAndReturnArgs} args - Arguments to create many Configuracions.
     * @example
     * // Create many Configuracions
     * const configuracion = await prisma.configuracion.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Configuracions and only return the `id`
     * const configuracionWithIdOnly = await prisma.configuracion.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConfiguracionCreateManyAndReturnArgs>(args?: SelectSubset<T, ConfiguracionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConfiguracionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Configuracion.
     * @param {ConfiguracionDeleteArgs} args - Arguments to delete one Configuracion.
     * @example
     * // Delete one Configuracion
     * const Configuracion = await prisma.configuracion.delete({
     *   where: {
     *     // ... filter to delete one Configuracion
     *   }
     * })
     * 
     */
    delete<T extends ConfiguracionDeleteArgs>(args: SelectSubset<T, ConfiguracionDeleteArgs<ExtArgs>>): Prisma__ConfiguracionClient<$Result.GetResult<Prisma.$ConfiguracionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Configuracion.
     * @param {ConfiguracionUpdateArgs} args - Arguments to update one Configuracion.
     * @example
     * // Update one Configuracion
     * const configuracion = await prisma.configuracion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConfiguracionUpdateArgs>(args: SelectSubset<T, ConfiguracionUpdateArgs<ExtArgs>>): Prisma__ConfiguracionClient<$Result.GetResult<Prisma.$ConfiguracionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Configuracions.
     * @param {ConfiguracionDeleteManyArgs} args - Arguments to filter Configuracions to delete.
     * @example
     * // Delete a few Configuracions
     * const { count } = await prisma.configuracion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConfiguracionDeleteManyArgs>(args?: SelectSubset<T, ConfiguracionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Configuracions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Configuracions
     * const configuracion = await prisma.configuracion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConfiguracionUpdateManyArgs>(args: SelectSubset<T, ConfiguracionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Configuracion.
     * @param {ConfiguracionUpsertArgs} args - Arguments to update or create a Configuracion.
     * @example
     * // Update or create a Configuracion
     * const configuracion = await prisma.configuracion.upsert({
     *   create: {
     *     // ... data to create a Configuracion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Configuracion we want to update
     *   }
     * })
     */
    upsert<T extends ConfiguracionUpsertArgs>(args: SelectSubset<T, ConfiguracionUpsertArgs<ExtArgs>>): Prisma__ConfiguracionClient<$Result.GetResult<Prisma.$ConfiguracionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Configuracions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionCountArgs} args - Arguments to filter Configuracions to count.
     * @example
     * // Count the number of Configuracions
     * const count = await prisma.configuracion.count({
     *   where: {
     *     // ... the filter for the Configuracions we want to count
     *   }
     * })
    **/
    count<T extends ConfiguracionCountArgs>(
      args?: Subset<T, ConfiguracionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConfiguracionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Configuracion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConfiguracionAggregateArgs>(args: Subset<T, ConfiguracionAggregateArgs>): Prisma.PrismaPromise<GetConfiguracionAggregateType<T>>

    /**
     * Group by Configuracion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConfiguracionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConfiguracionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConfiguracionGroupByArgs['orderBy'] }
        : { orderBy?: ConfiguracionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConfiguracionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConfiguracionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Configuracion model
   */
  readonly fields: ConfiguracionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Configuracion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConfiguracionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Configuracion model
   */ 
  interface ConfiguracionFieldRefs {
    readonly id: FieldRef<"Configuracion", 'String'>
    readonly clave: FieldRef<"Configuracion", 'String'>
    readonly valor: FieldRef<"Configuracion", 'String'>
    readonly descripcion: FieldRef<"Configuracion", 'String'>
    readonly creadoEn: FieldRef<"Configuracion", 'DateTime'>
    readonly actualizadoEn: FieldRef<"Configuracion", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Configuracion findUnique
   */
  export type ConfiguracionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuracion
     */
    select?: ConfiguracionSelect<ExtArgs> | null
    /**
     * Filter, which Configuracion to fetch.
     */
    where: ConfiguracionWhereUniqueInput
  }

  /**
   * Configuracion findUniqueOrThrow
   */
  export type ConfiguracionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuracion
     */
    select?: ConfiguracionSelect<ExtArgs> | null
    /**
     * Filter, which Configuracion to fetch.
     */
    where: ConfiguracionWhereUniqueInput
  }

  /**
   * Configuracion findFirst
   */
  export type ConfiguracionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuracion
     */
    select?: ConfiguracionSelect<ExtArgs> | null
    /**
     * Filter, which Configuracion to fetch.
     */
    where?: ConfiguracionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configuracions to fetch.
     */
    orderBy?: ConfiguracionOrderByWithRelationInput | ConfiguracionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configuracions.
     */
    cursor?: ConfiguracionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configuracions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configuracions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configuracions.
     */
    distinct?: ConfiguracionScalarFieldEnum | ConfiguracionScalarFieldEnum[]
  }

  /**
   * Configuracion findFirstOrThrow
   */
  export type ConfiguracionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuracion
     */
    select?: ConfiguracionSelect<ExtArgs> | null
    /**
     * Filter, which Configuracion to fetch.
     */
    where?: ConfiguracionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configuracions to fetch.
     */
    orderBy?: ConfiguracionOrderByWithRelationInput | ConfiguracionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Configuracions.
     */
    cursor?: ConfiguracionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configuracions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configuracions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Configuracions.
     */
    distinct?: ConfiguracionScalarFieldEnum | ConfiguracionScalarFieldEnum[]
  }

  /**
   * Configuracion findMany
   */
  export type ConfiguracionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuracion
     */
    select?: ConfiguracionSelect<ExtArgs> | null
    /**
     * Filter, which Configuracions to fetch.
     */
    where?: ConfiguracionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Configuracions to fetch.
     */
    orderBy?: ConfiguracionOrderByWithRelationInput | ConfiguracionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Configuracions.
     */
    cursor?: ConfiguracionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Configuracions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Configuracions.
     */
    skip?: number
    distinct?: ConfiguracionScalarFieldEnum | ConfiguracionScalarFieldEnum[]
  }

  /**
   * Configuracion create
   */
  export type ConfiguracionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuracion
     */
    select?: ConfiguracionSelect<ExtArgs> | null
    /**
     * The data needed to create a Configuracion.
     */
    data: XOR<ConfiguracionCreateInput, ConfiguracionUncheckedCreateInput>
  }

  /**
   * Configuracion createMany
   */
  export type ConfiguracionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Configuracions.
     */
    data: ConfiguracionCreateManyInput | ConfiguracionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Configuracion createManyAndReturn
   */
  export type ConfiguracionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuracion
     */
    select?: ConfiguracionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Configuracions.
     */
    data: ConfiguracionCreateManyInput | ConfiguracionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Configuracion update
   */
  export type ConfiguracionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuracion
     */
    select?: ConfiguracionSelect<ExtArgs> | null
    /**
     * The data needed to update a Configuracion.
     */
    data: XOR<ConfiguracionUpdateInput, ConfiguracionUncheckedUpdateInput>
    /**
     * Choose, which Configuracion to update.
     */
    where: ConfiguracionWhereUniqueInput
  }

  /**
   * Configuracion updateMany
   */
  export type ConfiguracionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Configuracions.
     */
    data: XOR<ConfiguracionUpdateManyMutationInput, ConfiguracionUncheckedUpdateManyInput>
    /**
     * Filter which Configuracions to update
     */
    where?: ConfiguracionWhereInput
  }

  /**
   * Configuracion upsert
   */
  export type ConfiguracionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuracion
     */
    select?: ConfiguracionSelect<ExtArgs> | null
    /**
     * The filter to search for the Configuracion to update in case it exists.
     */
    where: ConfiguracionWhereUniqueInput
    /**
     * In case the Configuracion found by the `where` argument doesn't exist, create a new Configuracion with this data.
     */
    create: XOR<ConfiguracionCreateInput, ConfiguracionUncheckedCreateInput>
    /**
     * In case the Configuracion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConfiguracionUpdateInput, ConfiguracionUncheckedUpdateInput>
  }

  /**
   * Configuracion delete
   */
  export type ConfiguracionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuracion
     */
    select?: ConfiguracionSelect<ExtArgs> | null
    /**
     * Filter which Configuracion to delete.
     */
    where: ConfiguracionWhereUniqueInput
  }

  /**
   * Configuracion deleteMany
   */
  export type ConfiguracionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Configuracions to delete
     */
    where?: ConfiguracionWhereInput
  }

  /**
   * Configuracion without action
   */
  export type ConfiguracionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Configuracion
     */
    select?: ConfiguracionSelect<ExtArgs> | null
  }


  /**
   * Model Convocatoria
   */

  export type AggregateConvocatoria = {
    _count: ConvocatoriaCountAggregateOutputType | null
    _min: ConvocatoriaMinAggregateOutputType | null
    _max: ConvocatoriaMaxAggregateOutputType | null
  }

  export type ConvocatoriaMinAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    fechaInicio: Date | null
    fechaFin: Date | null
    activa: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type ConvocatoriaMaxAggregateOutputType = {
    id: string | null
    nombre: string | null
    descripcion: string | null
    fechaInicio: Date | null
    fechaFin: Date | null
    activa: boolean | null
    creadoEn: Date | null
    actualizadoEn: Date | null
  }

  export type ConvocatoriaCountAggregateOutputType = {
    id: number
    nombre: number
    descripcion: number
    fechaInicio: number
    fechaFin: number
    activa: number
    formularioJson: number
    creadoEn: number
    actualizadoEn: number
    _all: number
  }


  export type ConvocatoriaMinAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    fechaInicio?: true
    fechaFin?: true
    activa?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type ConvocatoriaMaxAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    fechaInicio?: true
    fechaFin?: true
    activa?: true
    creadoEn?: true
    actualizadoEn?: true
  }

  export type ConvocatoriaCountAggregateInputType = {
    id?: true
    nombre?: true
    descripcion?: true
    fechaInicio?: true
    fechaFin?: true
    activa?: true
    formularioJson?: true
    creadoEn?: true
    actualizadoEn?: true
    _all?: true
  }

  export type ConvocatoriaAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Convocatoria to aggregate.
     */
    where?: ConvocatoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Convocatorias to fetch.
     */
    orderBy?: ConvocatoriaOrderByWithRelationInput | ConvocatoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ConvocatoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Convocatorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Convocatorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Convocatorias
    **/
    _count?: true | ConvocatoriaCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ConvocatoriaMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ConvocatoriaMaxAggregateInputType
  }

  export type GetConvocatoriaAggregateType<T extends ConvocatoriaAggregateArgs> = {
        [P in keyof T & keyof AggregateConvocatoria]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateConvocatoria[P]>
      : GetScalarType<T[P], AggregateConvocatoria[P]>
  }




  export type ConvocatoriaGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ConvocatoriaWhereInput
    orderBy?: ConvocatoriaOrderByWithAggregationInput | ConvocatoriaOrderByWithAggregationInput[]
    by: ConvocatoriaScalarFieldEnum[] | ConvocatoriaScalarFieldEnum
    having?: ConvocatoriaScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ConvocatoriaCountAggregateInputType | true
    _min?: ConvocatoriaMinAggregateInputType
    _max?: ConvocatoriaMaxAggregateInputType
  }

  export type ConvocatoriaGroupByOutputType = {
    id: string
    nombre: string
    descripcion: string | null
    fechaInicio: Date
    fechaFin: Date
    activa: boolean
    formularioJson: JsonValue | null
    creadoEn: Date
    actualizadoEn: Date
    _count: ConvocatoriaCountAggregateOutputType | null
    _min: ConvocatoriaMinAggregateOutputType | null
    _max: ConvocatoriaMaxAggregateOutputType | null
  }

  type GetConvocatoriaGroupByPayload<T extends ConvocatoriaGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ConvocatoriaGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ConvocatoriaGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ConvocatoriaGroupByOutputType[P]>
            : GetScalarType<T[P], ConvocatoriaGroupByOutputType[P]>
        }
      >
    >


  export type ConvocatoriaSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    activa?: boolean
    formularioJson?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["convocatoria"]>

  export type ConvocatoriaSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    activa?: boolean
    formularioJson?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }, ExtArgs["result"]["convocatoria"]>

  export type ConvocatoriaSelectScalar = {
    id?: boolean
    nombre?: boolean
    descripcion?: boolean
    fechaInicio?: boolean
    fechaFin?: boolean
    activa?: boolean
    formularioJson?: boolean
    creadoEn?: boolean
    actualizadoEn?: boolean
  }


  export type $ConvocatoriaPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Convocatoria"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      nombre: string
      descripcion: string | null
      fechaInicio: Date
      fechaFin: Date
      activa: boolean
      formularioJson: Prisma.JsonValue | null
      creadoEn: Date
      actualizadoEn: Date
    }, ExtArgs["result"]["convocatoria"]>
    composites: {}
  }

  type ConvocatoriaGetPayload<S extends boolean | null | undefined | ConvocatoriaDefaultArgs> = $Result.GetResult<Prisma.$ConvocatoriaPayload, S>

  type ConvocatoriaCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ConvocatoriaFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ConvocatoriaCountAggregateInputType | true
    }

  export interface ConvocatoriaDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Convocatoria'], meta: { name: 'Convocatoria' } }
    /**
     * Find zero or one Convocatoria that matches the filter.
     * @param {ConvocatoriaFindUniqueArgs} args - Arguments to find a Convocatoria
     * @example
     * // Get one Convocatoria
     * const convocatoria = await prisma.convocatoria.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ConvocatoriaFindUniqueArgs>(args: SelectSubset<T, ConvocatoriaFindUniqueArgs<ExtArgs>>): Prisma__ConvocatoriaClient<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Convocatoria that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ConvocatoriaFindUniqueOrThrowArgs} args - Arguments to find a Convocatoria
     * @example
     * // Get one Convocatoria
     * const convocatoria = await prisma.convocatoria.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ConvocatoriaFindUniqueOrThrowArgs>(args: SelectSubset<T, ConvocatoriaFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ConvocatoriaClient<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Convocatoria that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocatoriaFindFirstArgs} args - Arguments to find a Convocatoria
     * @example
     * // Get one Convocatoria
     * const convocatoria = await prisma.convocatoria.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ConvocatoriaFindFirstArgs>(args?: SelectSubset<T, ConvocatoriaFindFirstArgs<ExtArgs>>): Prisma__ConvocatoriaClient<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Convocatoria that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocatoriaFindFirstOrThrowArgs} args - Arguments to find a Convocatoria
     * @example
     * // Get one Convocatoria
     * const convocatoria = await prisma.convocatoria.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ConvocatoriaFindFirstOrThrowArgs>(args?: SelectSubset<T, ConvocatoriaFindFirstOrThrowArgs<ExtArgs>>): Prisma__ConvocatoriaClient<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Convocatorias that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocatoriaFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Convocatorias
     * const convocatorias = await prisma.convocatoria.findMany()
     * 
     * // Get first 10 Convocatorias
     * const convocatorias = await prisma.convocatoria.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const convocatoriaWithIdOnly = await prisma.convocatoria.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ConvocatoriaFindManyArgs>(args?: SelectSubset<T, ConvocatoriaFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Convocatoria.
     * @param {ConvocatoriaCreateArgs} args - Arguments to create a Convocatoria.
     * @example
     * // Create one Convocatoria
     * const Convocatoria = await prisma.convocatoria.create({
     *   data: {
     *     // ... data to create a Convocatoria
     *   }
     * })
     * 
     */
    create<T extends ConvocatoriaCreateArgs>(args: SelectSubset<T, ConvocatoriaCreateArgs<ExtArgs>>): Prisma__ConvocatoriaClient<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Convocatorias.
     * @param {ConvocatoriaCreateManyArgs} args - Arguments to create many Convocatorias.
     * @example
     * // Create many Convocatorias
     * const convocatoria = await prisma.convocatoria.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ConvocatoriaCreateManyArgs>(args?: SelectSubset<T, ConvocatoriaCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Convocatorias and returns the data saved in the database.
     * @param {ConvocatoriaCreateManyAndReturnArgs} args - Arguments to create many Convocatorias.
     * @example
     * // Create many Convocatorias
     * const convocatoria = await prisma.convocatoria.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Convocatorias and only return the `id`
     * const convocatoriaWithIdOnly = await prisma.convocatoria.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ConvocatoriaCreateManyAndReturnArgs>(args?: SelectSubset<T, ConvocatoriaCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Convocatoria.
     * @param {ConvocatoriaDeleteArgs} args - Arguments to delete one Convocatoria.
     * @example
     * // Delete one Convocatoria
     * const Convocatoria = await prisma.convocatoria.delete({
     *   where: {
     *     // ... filter to delete one Convocatoria
     *   }
     * })
     * 
     */
    delete<T extends ConvocatoriaDeleteArgs>(args: SelectSubset<T, ConvocatoriaDeleteArgs<ExtArgs>>): Prisma__ConvocatoriaClient<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Convocatoria.
     * @param {ConvocatoriaUpdateArgs} args - Arguments to update one Convocatoria.
     * @example
     * // Update one Convocatoria
     * const convocatoria = await prisma.convocatoria.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ConvocatoriaUpdateArgs>(args: SelectSubset<T, ConvocatoriaUpdateArgs<ExtArgs>>): Prisma__ConvocatoriaClient<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Convocatorias.
     * @param {ConvocatoriaDeleteManyArgs} args - Arguments to filter Convocatorias to delete.
     * @example
     * // Delete a few Convocatorias
     * const { count } = await prisma.convocatoria.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ConvocatoriaDeleteManyArgs>(args?: SelectSubset<T, ConvocatoriaDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Convocatorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocatoriaUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Convocatorias
     * const convocatoria = await prisma.convocatoria.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ConvocatoriaUpdateManyArgs>(args: SelectSubset<T, ConvocatoriaUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Convocatoria.
     * @param {ConvocatoriaUpsertArgs} args - Arguments to update or create a Convocatoria.
     * @example
     * // Update or create a Convocatoria
     * const convocatoria = await prisma.convocatoria.upsert({
     *   create: {
     *     // ... data to create a Convocatoria
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Convocatoria we want to update
     *   }
     * })
     */
    upsert<T extends ConvocatoriaUpsertArgs>(args: SelectSubset<T, ConvocatoriaUpsertArgs<ExtArgs>>): Prisma__ConvocatoriaClient<$Result.GetResult<Prisma.$ConvocatoriaPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Convocatorias.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocatoriaCountArgs} args - Arguments to filter Convocatorias to count.
     * @example
     * // Count the number of Convocatorias
     * const count = await prisma.convocatoria.count({
     *   where: {
     *     // ... the filter for the Convocatorias we want to count
     *   }
     * })
    **/
    count<T extends ConvocatoriaCountArgs>(
      args?: Subset<T, ConvocatoriaCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ConvocatoriaCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Convocatoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocatoriaAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ConvocatoriaAggregateArgs>(args: Subset<T, ConvocatoriaAggregateArgs>): Prisma.PrismaPromise<GetConvocatoriaAggregateType<T>>

    /**
     * Group by Convocatoria.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ConvocatoriaGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ConvocatoriaGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ConvocatoriaGroupByArgs['orderBy'] }
        : { orderBy?: ConvocatoriaGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ConvocatoriaGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetConvocatoriaGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Convocatoria model
   */
  readonly fields: ConvocatoriaFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Convocatoria.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ConvocatoriaClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Convocatoria model
   */ 
  interface ConvocatoriaFieldRefs {
    readonly id: FieldRef<"Convocatoria", 'String'>
    readonly nombre: FieldRef<"Convocatoria", 'String'>
    readonly descripcion: FieldRef<"Convocatoria", 'String'>
    readonly fechaInicio: FieldRef<"Convocatoria", 'DateTime'>
    readonly fechaFin: FieldRef<"Convocatoria", 'DateTime'>
    readonly activa: FieldRef<"Convocatoria", 'Boolean'>
    readonly formularioJson: FieldRef<"Convocatoria", 'Json'>
    readonly creadoEn: FieldRef<"Convocatoria", 'DateTime'>
    readonly actualizadoEn: FieldRef<"Convocatoria", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Convocatoria findUnique
   */
  export type ConvocatoriaFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * Filter, which Convocatoria to fetch.
     */
    where: ConvocatoriaWhereUniqueInput
  }

  /**
   * Convocatoria findUniqueOrThrow
   */
  export type ConvocatoriaFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * Filter, which Convocatoria to fetch.
     */
    where: ConvocatoriaWhereUniqueInput
  }

  /**
   * Convocatoria findFirst
   */
  export type ConvocatoriaFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * Filter, which Convocatoria to fetch.
     */
    where?: ConvocatoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Convocatorias to fetch.
     */
    orderBy?: ConvocatoriaOrderByWithRelationInput | ConvocatoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Convocatorias.
     */
    cursor?: ConvocatoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Convocatorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Convocatorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Convocatorias.
     */
    distinct?: ConvocatoriaScalarFieldEnum | ConvocatoriaScalarFieldEnum[]
  }

  /**
   * Convocatoria findFirstOrThrow
   */
  export type ConvocatoriaFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * Filter, which Convocatoria to fetch.
     */
    where?: ConvocatoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Convocatorias to fetch.
     */
    orderBy?: ConvocatoriaOrderByWithRelationInput | ConvocatoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Convocatorias.
     */
    cursor?: ConvocatoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Convocatorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Convocatorias.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Convocatorias.
     */
    distinct?: ConvocatoriaScalarFieldEnum | ConvocatoriaScalarFieldEnum[]
  }

  /**
   * Convocatoria findMany
   */
  export type ConvocatoriaFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * Filter, which Convocatorias to fetch.
     */
    where?: ConvocatoriaWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Convocatorias to fetch.
     */
    orderBy?: ConvocatoriaOrderByWithRelationInput | ConvocatoriaOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Convocatorias.
     */
    cursor?: ConvocatoriaWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Convocatorias from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Convocatorias.
     */
    skip?: number
    distinct?: ConvocatoriaScalarFieldEnum | ConvocatoriaScalarFieldEnum[]
  }

  /**
   * Convocatoria create
   */
  export type ConvocatoriaCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * The data needed to create a Convocatoria.
     */
    data: XOR<ConvocatoriaCreateInput, ConvocatoriaUncheckedCreateInput>
  }

  /**
   * Convocatoria createMany
   */
  export type ConvocatoriaCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Convocatorias.
     */
    data: ConvocatoriaCreateManyInput | ConvocatoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Convocatoria createManyAndReturn
   */
  export type ConvocatoriaCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Convocatorias.
     */
    data: ConvocatoriaCreateManyInput | ConvocatoriaCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Convocatoria update
   */
  export type ConvocatoriaUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * The data needed to update a Convocatoria.
     */
    data: XOR<ConvocatoriaUpdateInput, ConvocatoriaUncheckedUpdateInput>
    /**
     * Choose, which Convocatoria to update.
     */
    where: ConvocatoriaWhereUniqueInput
  }

  /**
   * Convocatoria updateMany
   */
  export type ConvocatoriaUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Convocatorias.
     */
    data: XOR<ConvocatoriaUpdateManyMutationInput, ConvocatoriaUncheckedUpdateManyInput>
    /**
     * Filter which Convocatorias to update
     */
    where?: ConvocatoriaWhereInput
  }

  /**
   * Convocatoria upsert
   */
  export type ConvocatoriaUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * The filter to search for the Convocatoria to update in case it exists.
     */
    where: ConvocatoriaWhereUniqueInput
    /**
     * In case the Convocatoria found by the `where` argument doesn't exist, create a new Convocatoria with this data.
     */
    create: XOR<ConvocatoriaCreateInput, ConvocatoriaUncheckedCreateInput>
    /**
     * In case the Convocatoria was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ConvocatoriaUpdateInput, ConvocatoriaUncheckedUpdateInput>
  }

  /**
   * Convocatoria delete
   */
  export type ConvocatoriaDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
    /**
     * Filter which Convocatoria to delete.
     */
    where: ConvocatoriaWhereUniqueInput
  }

  /**
   * Convocatoria deleteMany
   */
  export type ConvocatoriaDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Convocatorias to delete
     */
    where?: ConvocatoriaWhereInput
  }

  /**
   * Convocatoria without action
   */
  export type ConvocatoriaDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Convocatoria
     */
    select?: ConvocatoriaSelect<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UsuarioScalarFieldEnum: {
    id: 'id',
    cedula: 'cedula',
    email: 'email',
    nombreCompleto: 'nombreCompleto',
    passwordHash: 'passwordHash',
    rol: 'rol',
    estado: 'estado',
    mfaSecret: 'mfaSecret',
    mfaHabilitado: 'mfaHabilitado',
    intentosFallidos: 'intentosFallidos',
    bloqueadoHasta: 'bloqueadoHasta',
    ultimoAcceso: 'ultimoAcceso',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    creadoPorId: 'creadoPorId'
  };

  export type UsuarioScalarFieldEnum = (typeof UsuarioScalarFieldEnum)[keyof typeof UsuarioScalarFieldEnum]


  export const PasswordHistorialScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    passwordHash: 'passwordHash',
    creadoEn: 'creadoEn'
  };

  export type PasswordHistorialScalarFieldEnum = (typeof PasswordHistorialScalarFieldEnum)[keyof typeof PasswordHistorialScalarFieldEnum]


  export const TokenRecuperacionScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    token: 'token',
    expiraEn: 'expiraEn',
    usado: 'usado',
    creadoEn: 'creadoEn'
  };

  export type TokenRecuperacionScalarFieldEnum = (typeof TokenRecuperacionScalarFieldEnum)[keyof typeof TokenRecuperacionScalarFieldEnum]


  export const SesionScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    tokenHash: 'tokenHash',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    expiraEn: 'expiraEn',
    creadoEn: 'creadoEn',
    ultimaActividad: 'ultimaActividad'
  };

  export type SesionScalarFieldEnum = (typeof SesionScalarFieldEnum)[keyof typeof SesionScalarFieldEnum]


  export const CambioRolScalarFieldEnum: {
    id: 'id',
    usuarioId: 'usuarioId',
    rolAnterior: 'rolAnterior',
    rolNuevo: 'rolNuevo',
    motivo: 'motivo',
    cambiadoPorId: 'cambiadoPorId',
    creadoEn: 'creadoEn'
  };

  export type CambioRolScalarFieldEnum = (typeof CambioRolScalarFieldEnum)[keyof typeof CambioRolScalarFieldEnum]


  export const CatalogoDocumentoScalarFieldEnum: {
    id: 'id',
    tipo: 'tipo',
    nombre: 'nombre',
    descripcion: 'descripcion',
    obligatorio: 'obligatorio',
    formatosPermitidos: 'formatosPermitidos',
    tamanoMaximoMb: 'tamanoMaximoMb',
    vigenciaDias: 'vigenciaDias',
    activo: 'activo',
    orden: 'orden',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type CatalogoDocumentoScalarFieldEnum = (typeof CatalogoDocumentoScalarFieldEnum)[keyof typeof CatalogoDocumentoScalarFieldEnum]


  export const ProcesoScalarFieldEnum: {
    id: 'id',
    codigo: 'codigo',
    beneficiarioId: 'beneficiarioId',
    arrendadorId: 'arrendadorId',
    estado: 'estado',
    formulario: 'formulario',
    pdfPath: 'pdfPath',
    pdfHash: 'pdfHash',
    pdfVersion: 'pdfVersion',
    firmado: 'firmado',
    firmadoEn: 'firmadoEn',
    firmadoPorId: 'firmadoPorId',
    firmaHash: 'firmaHash',
    firmaIp: 'firmaIp',
    firmaUserAgent: 'firmaUserAgent',
    cerradoEn: 'cerradoEn',
    cerradoPorId: 'cerradoPorId',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn',
    enviadoEn: 'enviadoEn'
  };

  export type ProcesoScalarFieldEnum = (typeof ProcesoScalarFieldEnum)[keyof typeof ProcesoScalarFieldEnum]


  export const DocumentoScalarFieldEnum: {
    id: 'id',
    procesoId: 'procesoId',
    catalogoId: 'catalogoId',
    nombreOriginal: 'nombreOriginal',
    nombreAlmacenado: 'nombreAlmacenado',
    rutaArchivo: 'rutaArchivo',
    mimeType: 'mimeType',
    tamanoBytes: 'tamanoBytes',
    hashArchivo: 'hashArchivo',
    estado: 'estado',
    validadoPorId: 'validadoPorId',
    validadoEn: 'validadoEn',
    motivoRechazo: 'motivoRechazo',
    version: 'version',
    esActivo: 'esActivo',
    creadoEn: 'creadoEn',
    cargadoPorId: 'cargadoPorId'
  };

  export type DocumentoScalarFieldEnum = (typeof DocumentoScalarFieldEnum)[keyof typeof DocumentoScalarFieldEnum]


  export const RegistroDescargaScalarFieldEnum: {
    id: 'id',
    documentoId: 'documentoId',
    usuarioId: 'usuarioId',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    creadoEn: 'creadoEn'
  };

  export type RegistroDescargaScalarFieldEnum = (typeof RegistroDescargaScalarFieldEnum)[keyof typeof RegistroDescargaScalarFieldEnum]


  export const HistorialPdfScalarFieldEnum: {
    id: 'id',
    procesoId: 'procesoId',
    version: 'version',
    pdfPath: 'pdfPath',
    pdfHash: 'pdfHash',
    creadoEn: 'creadoEn'
  };

  export type HistorialPdfScalarFieldEnum = (typeof HistorialPdfScalarFieldEnum)[keyof typeof HistorialPdfScalarFieldEnum]


  export const DecisionScalarFieldEnum: {
    id: 'id',
    procesoId: 'procesoId',
    estadoAnterior: 'estadoAnterior',
    estadoNuevo: 'estadoNuevo',
    aprobado: 'aprobado',
    motivo: 'motivo',
    usuarioId: 'usuarioId',
    rol: 'rol',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    creadoEn: 'creadoEn'
  };

  export type DecisionScalarFieldEnum = (typeof DecisionScalarFieldEnum)[keyof typeof DecisionScalarFieldEnum]


  export const EventoAuditoriaScalarFieldEnum: {
    id: 'id',
    procesoId: 'procesoId',
    usuarioId: 'usuarioId',
    tipo: 'tipo',
    descripcion: 'descripcion',
    detalles: 'detalles',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    creadoEn: 'creadoEn'
  };

  export type EventoAuditoriaScalarFieldEnum = (typeof EventoAuditoriaScalarFieldEnum)[keyof typeof EventoAuditoriaScalarFieldEnum]


  export const ConfiguracionScalarFieldEnum: {
    id: 'id',
    clave: 'clave',
    valor: 'valor',
    descripcion: 'descripcion',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type ConfiguracionScalarFieldEnum = (typeof ConfiguracionScalarFieldEnum)[keyof typeof ConfiguracionScalarFieldEnum]


  export const ConvocatoriaScalarFieldEnum: {
    id: 'id',
    nombre: 'nombre',
    descripcion: 'descripcion',
    fechaInicio: 'fechaInicio',
    fechaFin: 'fechaFin',
    activa: 'activa',
    formularioJson: 'formularioJson',
    creadoEn: 'creadoEn',
    actualizadoEn: 'actualizadoEn'
  };

  export type ConvocatoriaScalarFieldEnum = (typeof ConvocatoriaScalarFieldEnum)[keyof typeof ConvocatoriaScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Rol'
   */
  export type EnumRolFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Rol'>
    


  /**
   * Reference to a field of type 'Rol[]'
   */
  export type ListEnumRolFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Rol[]'>
    


  /**
   * Reference to a field of type 'EstadoUsuario'
   */
  export type EnumEstadoUsuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoUsuario'>
    


  /**
   * Reference to a field of type 'EstadoUsuario[]'
   */
  export type ListEnumEstadoUsuarioFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoUsuario[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'TipoDocumento'
   */
  export type EnumTipoDocumentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoDocumento'>
    


  /**
   * Reference to a field of type 'TipoDocumento[]'
   */
  export type ListEnumTipoDocumentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoDocumento[]'>
    


  /**
   * Reference to a field of type 'EstadoProceso'
   */
  export type EnumEstadoProcesoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoProceso'>
    


  /**
   * Reference to a field of type 'EstadoProceso[]'
   */
  export type ListEnumEstadoProcesoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoProceso[]'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'EstadoDocumento'
   */
  export type EnumEstadoDocumentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoDocumento'>
    


  /**
   * Reference to a field of type 'EstadoDocumento[]'
   */
  export type ListEnumEstadoDocumentoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'EstadoDocumento[]'>
    


  /**
   * Reference to a field of type 'TipoEvento'
   */
  export type EnumTipoEventoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoEvento'>
    


  /**
   * Reference to a field of type 'TipoEvento[]'
   */
  export type ListEnumTipoEventoFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'TipoEvento[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type UsuarioWhereInput = {
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    id?: StringFilter<"Usuario"> | string
    cedula?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    nombreCompleto?: StringFilter<"Usuario"> | string
    passwordHash?: StringFilter<"Usuario"> | string
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    estado?: EnumEstadoUsuarioFilter<"Usuario"> | $Enums.EstadoUsuario
    mfaSecret?: StringNullableFilter<"Usuario"> | string | null
    mfaHabilitado?: BoolFilter<"Usuario"> | boolean
    intentosFallidos?: IntFilter<"Usuario"> | number
    bloqueadoHasta?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    ultimoAcceso?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    creadoEn?: DateTimeFilter<"Usuario"> | Date | string
    actualizadoEn?: DateTimeFilter<"Usuario"> | Date | string
    creadoPorId?: StringNullableFilter<"Usuario"> | string | null
    creadoPor?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
    usuariosCreados?: UsuarioListRelationFilter
    passwordHistorial?: PasswordHistorialListRelationFilter
    sesiones?: SesionListRelationFilter
    procesosBeneficiario?: ProcesoListRelationFilter
    procesosArrendador?: ProcesoListRelationFilter
    documentosCargados?: DocumentoListRelationFilter
    documentosValidados?: DocumentoListRelationFilter
    eventosAuditoria?: EventoAuditoriaListRelationFilter
    decisiones?: DecisionListRelationFilter
    tokenRecuperacion?: TokenRecuperacionListRelationFilter
    cambiosRol?: CambioRolListRelationFilter
  }

  export type UsuarioOrderByWithRelationInput = {
    id?: SortOrder
    cedula?: SortOrder
    email?: SortOrder
    nombreCompleto?: SortOrder
    passwordHash?: SortOrder
    rol?: SortOrder
    estado?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    mfaHabilitado?: SortOrder
    intentosFallidos?: SortOrder
    bloqueadoHasta?: SortOrderInput | SortOrder
    ultimoAcceso?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    creadoPorId?: SortOrderInput | SortOrder
    creadoPor?: UsuarioOrderByWithRelationInput
    usuariosCreados?: UsuarioOrderByRelationAggregateInput
    passwordHistorial?: PasswordHistorialOrderByRelationAggregateInput
    sesiones?: SesionOrderByRelationAggregateInput
    procesosBeneficiario?: ProcesoOrderByRelationAggregateInput
    procesosArrendador?: ProcesoOrderByRelationAggregateInput
    documentosCargados?: DocumentoOrderByRelationAggregateInput
    documentosValidados?: DocumentoOrderByRelationAggregateInput
    eventosAuditoria?: EventoAuditoriaOrderByRelationAggregateInput
    decisiones?: DecisionOrderByRelationAggregateInput
    tokenRecuperacion?: TokenRecuperacionOrderByRelationAggregateInput
    cambiosRol?: CambioRolOrderByRelationAggregateInput
  }

  export type UsuarioWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    cedula?: string
    email?: string
    AND?: UsuarioWhereInput | UsuarioWhereInput[]
    OR?: UsuarioWhereInput[]
    NOT?: UsuarioWhereInput | UsuarioWhereInput[]
    nombreCompleto?: StringFilter<"Usuario"> | string
    passwordHash?: StringFilter<"Usuario"> | string
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    estado?: EnumEstadoUsuarioFilter<"Usuario"> | $Enums.EstadoUsuario
    mfaSecret?: StringNullableFilter<"Usuario"> | string | null
    mfaHabilitado?: BoolFilter<"Usuario"> | boolean
    intentosFallidos?: IntFilter<"Usuario"> | number
    bloqueadoHasta?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    ultimoAcceso?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    creadoEn?: DateTimeFilter<"Usuario"> | Date | string
    actualizadoEn?: DateTimeFilter<"Usuario"> | Date | string
    creadoPorId?: StringNullableFilter<"Usuario"> | string | null
    creadoPor?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
    usuariosCreados?: UsuarioListRelationFilter
    passwordHistorial?: PasswordHistorialListRelationFilter
    sesiones?: SesionListRelationFilter
    procesosBeneficiario?: ProcesoListRelationFilter
    procesosArrendador?: ProcesoListRelationFilter
    documentosCargados?: DocumentoListRelationFilter
    documentosValidados?: DocumentoListRelationFilter
    eventosAuditoria?: EventoAuditoriaListRelationFilter
    decisiones?: DecisionListRelationFilter
    tokenRecuperacion?: TokenRecuperacionListRelationFilter
    cambiosRol?: CambioRolListRelationFilter
  }, "id" | "cedula" | "email">

  export type UsuarioOrderByWithAggregationInput = {
    id?: SortOrder
    cedula?: SortOrder
    email?: SortOrder
    nombreCompleto?: SortOrder
    passwordHash?: SortOrder
    rol?: SortOrder
    estado?: SortOrder
    mfaSecret?: SortOrderInput | SortOrder
    mfaHabilitado?: SortOrder
    intentosFallidos?: SortOrder
    bloqueadoHasta?: SortOrderInput | SortOrder
    ultimoAcceso?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    creadoPorId?: SortOrderInput | SortOrder
    _count?: UsuarioCountOrderByAggregateInput
    _avg?: UsuarioAvgOrderByAggregateInput
    _max?: UsuarioMaxOrderByAggregateInput
    _min?: UsuarioMinOrderByAggregateInput
    _sum?: UsuarioSumOrderByAggregateInput
  }

  export type UsuarioScalarWhereWithAggregatesInput = {
    AND?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    OR?: UsuarioScalarWhereWithAggregatesInput[]
    NOT?: UsuarioScalarWhereWithAggregatesInput | UsuarioScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Usuario"> | string
    cedula?: StringWithAggregatesFilter<"Usuario"> | string
    email?: StringWithAggregatesFilter<"Usuario"> | string
    nombreCompleto?: StringWithAggregatesFilter<"Usuario"> | string
    passwordHash?: StringWithAggregatesFilter<"Usuario"> | string
    rol?: EnumRolWithAggregatesFilter<"Usuario"> | $Enums.Rol
    estado?: EnumEstadoUsuarioWithAggregatesFilter<"Usuario"> | $Enums.EstadoUsuario
    mfaSecret?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
    mfaHabilitado?: BoolWithAggregatesFilter<"Usuario"> | boolean
    intentosFallidos?: IntWithAggregatesFilter<"Usuario"> | number
    bloqueadoHasta?: DateTimeNullableWithAggregatesFilter<"Usuario"> | Date | string | null
    ultimoAcceso?: DateTimeNullableWithAggregatesFilter<"Usuario"> | Date | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"Usuario"> | Date | string
    creadoPorId?: StringNullableWithAggregatesFilter<"Usuario"> | string | null
  }

  export type PasswordHistorialWhereInput = {
    AND?: PasswordHistorialWhereInput | PasswordHistorialWhereInput[]
    OR?: PasswordHistorialWhereInput[]
    NOT?: PasswordHistorialWhereInput | PasswordHistorialWhereInput[]
    id?: StringFilter<"PasswordHistorial"> | string
    usuarioId?: StringFilter<"PasswordHistorial"> | string
    passwordHash?: StringFilter<"PasswordHistorial"> | string
    creadoEn?: DateTimeFilter<"PasswordHistorial"> | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type PasswordHistorialOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    passwordHash?: SortOrder
    creadoEn?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type PasswordHistorialWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PasswordHistorialWhereInput | PasswordHistorialWhereInput[]
    OR?: PasswordHistorialWhereInput[]
    NOT?: PasswordHistorialWhereInput | PasswordHistorialWhereInput[]
    usuarioId?: StringFilter<"PasswordHistorial"> | string
    passwordHash?: StringFilter<"PasswordHistorial"> | string
    creadoEn?: DateTimeFilter<"PasswordHistorial"> | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id">

  export type PasswordHistorialOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    passwordHash?: SortOrder
    creadoEn?: SortOrder
    _count?: PasswordHistorialCountOrderByAggregateInput
    _max?: PasswordHistorialMaxOrderByAggregateInput
    _min?: PasswordHistorialMinOrderByAggregateInput
  }

  export type PasswordHistorialScalarWhereWithAggregatesInput = {
    AND?: PasswordHistorialScalarWhereWithAggregatesInput | PasswordHistorialScalarWhereWithAggregatesInput[]
    OR?: PasswordHistorialScalarWhereWithAggregatesInput[]
    NOT?: PasswordHistorialScalarWhereWithAggregatesInput | PasswordHistorialScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PasswordHistorial"> | string
    usuarioId?: StringWithAggregatesFilter<"PasswordHistorial"> | string
    passwordHash?: StringWithAggregatesFilter<"PasswordHistorial"> | string
    creadoEn?: DateTimeWithAggregatesFilter<"PasswordHistorial"> | Date | string
  }

  export type TokenRecuperacionWhereInput = {
    AND?: TokenRecuperacionWhereInput | TokenRecuperacionWhereInput[]
    OR?: TokenRecuperacionWhereInput[]
    NOT?: TokenRecuperacionWhereInput | TokenRecuperacionWhereInput[]
    id?: StringFilter<"TokenRecuperacion"> | string
    usuarioId?: StringFilter<"TokenRecuperacion"> | string
    token?: StringFilter<"TokenRecuperacion"> | string
    expiraEn?: DateTimeFilter<"TokenRecuperacion"> | Date | string
    usado?: BoolFilter<"TokenRecuperacion"> | boolean
    creadoEn?: DateTimeFilter<"TokenRecuperacion"> | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type TokenRecuperacionOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    token?: SortOrder
    expiraEn?: SortOrder
    usado?: SortOrder
    creadoEn?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type TokenRecuperacionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    token?: string
    AND?: TokenRecuperacionWhereInput | TokenRecuperacionWhereInput[]
    OR?: TokenRecuperacionWhereInput[]
    NOT?: TokenRecuperacionWhereInput | TokenRecuperacionWhereInput[]
    usuarioId?: StringFilter<"TokenRecuperacion"> | string
    expiraEn?: DateTimeFilter<"TokenRecuperacion"> | Date | string
    usado?: BoolFilter<"TokenRecuperacion"> | boolean
    creadoEn?: DateTimeFilter<"TokenRecuperacion"> | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id" | "token">

  export type TokenRecuperacionOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    token?: SortOrder
    expiraEn?: SortOrder
    usado?: SortOrder
    creadoEn?: SortOrder
    _count?: TokenRecuperacionCountOrderByAggregateInput
    _max?: TokenRecuperacionMaxOrderByAggregateInput
    _min?: TokenRecuperacionMinOrderByAggregateInput
  }

  export type TokenRecuperacionScalarWhereWithAggregatesInput = {
    AND?: TokenRecuperacionScalarWhereWithAggregatesInput | TokenRecuperacionScalarWhereWithAggregatesInput[]
    OR?: TokenRecuperacionScalarWhereWithAggregatesInput[]
    NOT?: TokenRecuperacionScalarWhereWithAggregatesInput | TokenRecuperacionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TokenRecuperacion"> | string
    usuarioId?: StringWithAggregatesFilter<"TokenRecuperacion"> | string
    token?: StringWithAggregatesFilter<"TokenRecuperacion"> | string
    expiraEn?: DateTimeWithAggregatesFilter<"TokenRecuperacion"> | Date | string
    usado?: BoolWithAggregatesFilter<"TokenRecuperacion"> | boolean
    creadoEn?: DateTimeWithAggregatesFilter<"TokenRecuperacion"> | Date | string
  }

  export type SesionWhereInput = {
    AND?: SesionWhereInput | SesionWhereInput[]
    OR?: SesionWhereInput[]
    NOT?: SesionWhereInput | SesionWhereInput[]
    id?: StringFilter<"Sesion"> | string
    usuarioId?: StringFilter<"Sesion"> | string
    tokenHash?: StringFilter<"Sesion"> | string
    ipAddress?: StringFilter<"Sesion"> | string
    userAgent?: StringFilter<"Sesion"> | string
    expiraEn?: DateTimeFilter<"Sesion"> | Date | string
    creadoEn?: DateTimeFilter<"Sesion"> | Date | string
    ultimaActividad?: DateTimeFilter<"Sesion"> | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type SesionOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tokenHash?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiraEn?: SortOrder
    creadoEn?: SortOrder
    ultimaActividad?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type SesionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tokenHash?: string
    AND?: SesionWhereInput | SesionWhereInput[]
    OR?: SesionWhereInput[]
    NOT?: SesionWhereInput | SesionWhereInput[]
    usuarioId?: StringFilter<"Sesion"> | string
    ipAddress?: StringFilter<"Sesion"> | string
    userAgent?: StringFilter<"Sesion"> | string
    expiraEn?: DateTimeFilter<"Sesion"> | Date | string
    creadoEn?: DateTimeFilter<"Sesion"> | Date | string
    ultimaActividad?: DateTimeFilter<"Sesion"> | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id" | "tokenHash">

  export type SesionOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tokenHash?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiraEn?: SortOrder
    creadoEn?: SortOrder
    ultimaActividad?: SortOrder
    _count?: SesionCountOrderByAggregateInput
    _max?: SesionMaxOrderByAggregateInput
    _min?: SesionMinOrderByAggregateInput
  }

  export type SesionScalarWhereWithAggregatesInput = {
    AND?: SesionScalarWhereWithAggregatesInput | SesionScalarWhereWithAggregatesInput[]
    OR?: SesionScalarWhereWithAggregatesInput[]
    NOT?: SesionScalarWhereWithAggregatesInput | SesionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Sesion"> | string
    usuarioId?: StringWithAggregatesFilter<"Sesion"> | string
    tokenHash?: StringWithAggregatesFilter<"Sesion"> | string
    ipAddress?: StringWithAggregatesFilter<"Sesion"> | string
    userAgent?: StringWithAggregatesFilter<"Sesion"> | string
    expiraEn?: DateTimeWithAggregatesFilter<"Sesion"> | Date | string
    creadoEn?: DateTimeWithAggregatesFilter<"Sesion"> | Date | string
    ultimaActividad?: DateTimeWithAggregatesFilter<"Sesion"> | Date | string
  }

  export type CambioRolWhereInput = {
    AND?: CambioRolWhereInput | CambioRolWhereInput[]
    OR?: CambioRolWhereInput[]
    NOT?: CambioRolWhereInput | CambioRolWhereInput[]
    id?: StringFilter<"CambioRol"> | string
    usuarioId?: StringFilter<"CambioRol"> | string
    rolAnterior?: EnumRolFilter<"CambioRol"> | $Enums.Rol
    rolNuevo?: EnumRolFilter<"CambioRol"> | $Enums.Rol
    motivo?: StringNullableFilter<"CambioRol"> | string | null
    cambiadoPorId?: StringFilter<"CambioRol"> | string
    creadoEn?: DateTimeFilter<"CambioRol"> | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type CambioRolOrderByWithRelationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    rolAnterior?: SortOrder
    rolNuevo?: SortOrder
    motivo?: SortOrderInput | SortOrder
    cambiadoPorId?: SortOrder
    creadoEn?: SortOrder
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type CambioRolWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: CambioRolWhereInput | CambioRolWhereInput[]
    OR?: CambioRolWhereInput[]
    NOT?: CambioRolWhereInput | CambioRolWhereInput[]
    usuarioId?: StringFilter<"CambioRol"> | string
    rolAnterior?: EnumRolFilter<"CambioRol"> | $Enums.Rol
    rolNuevo?: EnumRolFilter<"CambioRol"> | $Enums.Rol
    motivo?: StringNullableFilter<"CambioRol"> | string | null
    cambiadoPorId?: StringFilter<"CambioRol"> | string
    creadoEn?: DateTimeFilter<"CambioRol"> | Date | string
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id">

  export type CambioRolOrderByWithAggregationInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    rolAnterior?: SortOrder
    rolNuevo?: SortOrder
    motivo?: SortOrderInput | SortOrder
    cambiadoPorId?: SortOrder
    creadoEn?: SortOrder
    _count?: CambioRolCountOrderByAggregateInput
    _max?: CambioRolMaxOrderByAggregateInput
    _min?: CambioRolMinOrderByAggregateInput
  }

  export type CambioRolScalarWhereWithAggregatesInput = {
    AND?: CambioRolScalarWhereWithAggregatesInput | CambioRolScalarWhereWithAggregatesInput[]
    OR?: CambioRolScalarWhereWithAggregatesInput[]
    NOT?: CambioRolScalarWhereWithAggregatesInput | CambioRolScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CambioRol"> | string
    usuarioId?: StringWithAggregatesFilter<"CambioRol"> | string
    rolAnterior?: EnumRolWithAggregatesFilter<"CambioRol"> | $Enums.Rol
    rolNuevo?: EnumRolWithAggregatesFilter<"CambioRol"> | $Enums.Rol
    motivo?: StringNullableWithAggregatesFilter<"CambioRol"> | string | null
    cambiadoPorId?: StringWithAggregatesFilter<"CambioRol"> | string
    creadoEn?: DateTimeWithAggregatesFilter<"CambioRol"> | Date | string
  }

  export type CatalogoDocumentoWhereInput = {
    AND?: CatalogoDocumentoWhereInput | CatalogoDocumentoWhereInput[]
    OR?: CatalogoDocumentoWhereInput[]
    NOT?: CatalogoDocumentoWhereInput | CatalogoDocumentoWhereInput[]
    id?: StringFilter<"CatalogoDocumento"> | string
    tipo?: EnumTipoDocumentoFilter<"CatalogoDocumento"> | $Enums.TipoDocumento
    nombre?: StringFilter<"CatalogoDocumento"> | string
    descripcion?: StringNullableFilter<"CatalogoDocumento"> | string | null
    obligatorio?: BoolFilter<"CatalogoDocumento"> | boolean
    formatosPermitidos?: StringNullableListFilter<"CatalogoDocumento">
    tamanoMaximoMb?: IntFilter<"CatalogoDocumento"> | number
    vigenciaDias?: IntNullableFilter<"CatalogoDocumento"> | number | null
    activo?: BoolFilter<"CatalogoDocumento"> | boolean
    orden?: IntFilter<"CatalogoDocumento"> | number
    creadoEn?: DateTimeFilter<"CatalogoDocumento"> | Date | string
    actualizadoEn?: DateTimeFilter<"CatalogoDocumento"> | Date | string
    documentos?: DocumentoListRelationFilter
  }

  export type CatalogoDocumentoOrderByWithRelationInput = {
    id?: SortOrder
    tipo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    obligatorio?: SortOrder
    formatosPermitidos?: SortOrder
    tamanoMaximoMb?: SortOrder
    vigenciaDias?: SortOrderInput | SortOrder
    activo?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    documentos?: DocumentoOrderByRelationAggregateInput
  }

  export type CatalogoDocumentoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    tipo?: $Enums.TipoDocumento
    AND?: CatalogoDocumentoWhereInput | CatalogoDocumentoWhereInput[]
    OR?: CatalogoDocumentoWhereInput[]
    NOT?: CatalogoDocumentoWhereInput | CatalogoDocumentoWhereInput[]
    nombre?: StringFilter<"CatalogoDocumento"> | string
    descripcion?: StringNullableFilter<"CatalogoDocumento"> | string | null
    obligatorio?: BoolFilter<"CatalogoDocumento"> | boolean
    formatosPermitidos?: StringNullableListFilter<"CatalogoDocumento">
    tamanoMaximoMb?: IntFilter<"CatalogoDocumento"> | number
    vigenciaDias?: IntNullableFilter<"CatalogoDocumento"> | number | null
    activo?: BoolFilter<"CatalogoDocumento"> | boolean
    orden?: IntFilter<"CatalogoDocumento"> | number
    creadoEn?: DateTimeFilter<"CatalogoDocumento"> | Date | string
    actualizadoEn?: DateTimeFilter<"CatalogoDocumento"> | Date | string
    documentos?: DocumentoListRelationFilter
  }, "id" | "tipo">

  export type CatalogoDocumentoOrderByWithAggregationInput = {
    id?: SortOrder
    tipo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    obligatorio?: SortOrder
    formatosPermitidos?: SortOrder
    tamanoMaximoMb?: SortOrder
    vigenciaDias?: SortOrderInput | SortOrder
    activo?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: CatalogoDocumentoCountOrderByAggregateInput
    _avg?: CatalogoDocumentoAvgOrderByAggregateInput
    _max?: CatalogoDocumentoMaxOrderByAggregateInput
    _min?: CatalogoDocumentoMinOrderByAggregateInput
    _sum?: CatalogoDocumentoSumOrderByAggregateInput
  }

  export type CatalogoDocumentoScalarWhereWithAggregatesInput = {
    AND?: CatalogoDocumentoScalarWhereWithAggregatesInput | CatalogoDocumentoScalarWhereWithAggregatesInput[]
    OR?: CatalogoDocumentoScalarWhereWithAggregatesInput[]
    NOT?: CatalogoDocumentoScalarWhereWithAggregatesInput | CatalogoDocumentoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"CatalogoDocumento"> | string
    tipo?: EnumTipoDocumentoWithAggregatesFilter<"CatalogoDocumento"> | $Enums.TipoDocumento
    nombre?: StringWithAggregatesFilter<"CatalogoDocumento"> | string
    descripcion?: StringNullableWithAggregatesFilter<"CatalogoDocumento"> | string | null
    obligatorio?: BoolWithAggregatesFilter<"CatalogoDocumento"> | boolean
    formatosPermitidos?: StringNullableListFilter<"CatalogoDocumento">
    tamanoMaximoMb?: IntWithAggregatesFilter<"CatalogoDocumento"> | number
    vigenciaDias?: IntNullableWithAggregatesFilter<"CatalogoDocumento"> | number | null
    activo?: BoolWithAggregatesFilter<"CatalogoDocumento"> | boolean
    orden?: IntWithAggregatesFilter<"CatalogoDocumento"> | number
    creadoEn?: DateTimeWithAggregatesFilter<"CatalogoDocumento"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"CatalogoDocumento"> | Date | string
  }

  export type ProcesoWhereInput = {
    AND?: ProcesoWhereInput | ProcesoWhereInput[]
    OR?: ProcesoWhereInput[]
    NOT?: ProcesoWhereInput | ProcesoWhereInput[]
    id?: StringFilter<"Proceso"> | string
    codigo?: StringFilter<"Proceso"> | string
    beneficiarioId?: StringFilter<"Proceso"> | string
    arrendadorId?: StringNullableFilter<"Proceso"> | string | null
    estado?: EnumEstadoProcesoFilter<"Proceso"> | $Enums.EstadoProceso
    formulario?: JsonNullableFilter<"Proceso">
    pdfPath?: StringNullableFilter<"Proceso"> | string | null
    pdfHash?: StringNullableFilter<"Proceso"> | string | null
    pdfVersion?: IntFilter<"Proceso"> | number
    firmado?: BoolFilter<"Proceso"> | boolean
    firmadoEn?: DateTimeNullableFilter<"Proceso"> | Date | string | null
    firmadoPorId?: StringNullableFilter<"Proceso"> | string | null
    firmaHash?: StringNullableFilter<"Proceso"> | string | null
    firmaIp?: StringNullableFilter<"Proceso"> | string | null
    firmaUserAgent?: StringNullableFilter<"Proceso"> | string | null
    cerradoEn?: DateTimeNullableFilter<"Proceso"> | Date | string | null
    cerradoPorId?: StringNullableFilter<"Proceso"> | string | null
    creadoEn?: DateTimeFilter<"Proceso"> | Date | string
    actualizadoEn?: DateTimeFilter<"Proceso"> | Date | string
    enviadoEn?: DateTimeNullableFilter<"Proceso"> | Date | string | null
    beneficiario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    arrendador?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
    documentos?: DocumentoListRelationFilter
    eventos?: EventoAuditoriaListRelationFilter
    decisiones?: DecisionListRelationFilter
    historialPdf?: HistorialPdfListRelationFilter
  }

  export type ProcesoOrderByWithRelationInput = {
    id?: SortOrder
    codigo?: SortOrder
    beneficiarioId?: SortOrder
    arrendadorId?: SortOrderInput | SortOrder
    estado?: SortOrder
    formulario?: SortOrderInput | SortOrder
    pdfPath?: SortOrderInput | SortOrder
    pdfHash?: SortOrderInput | SortOrder
    pdfVersion?: SortOrder
    firmado?: SortOrder
    firmadoEn?: SortOrderInput | SortOrder
    firmadoPorId?: SortOrderInput | SortOrder
    firmaHash?: SortOrderInput | SortOrder
    firmaIp?: SortOrderInput | SortOrder
    firmaUserAgent?: SortOrderInput | SortOrder
    cerradoEn?: SortOrderInput | SortOrder
    cerradoPorId?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    enviadoEn?: SortOrderInput | SortOrder
    beneficiario?: UsuarioOrderByWithRelationInput
    arrendador?: UsuarioOrderByWithRelationInput
    documentos?: DocumentoOrderByRelationAggregateInput
    eventos?: EventoAuditoriaOrderByRelationAggregateInput
    decisiones?: DecisionOrderByRelationAggregateInput
    historialPdf?: HistorialPdfOrderByRelationAggregateInput
  }

  export type ProcesoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    codigo?: string
    AND?: ProcesoWhereInput | ProcesoWhereInput[]
    OR?: ProcesoWhereInput[]
    NOT?: ProcesoWhereInput | ProcesoWhereInput[]
    beneficiarioId?: StringFilter<"Proceso"> | string
    arrendadorId?: StringNullableFilter<"Proceso"> | string | null
    estado?: EnumEstadoProcesoFilter<"Proceso"> | $Enums.EstadoProceso
    formulario?: JsonNullableFilter<"Proceso">
    pdfPath?: StringNullableFilter<"Proceso"> | string | null
    pdfHash?: StringNullableFilter<"Proceso"> | string | null
    pdfVersion?: IntFilter<"Proceso"> | number
    firmado?: BoolFilter<"Proceso"> | boolean
    firmadoEn?: DateTimeNullableFilter<"Proceso"> | Date | string | null
    firmadoPorId?: StringNullableFilter<"Proceso"> | string | null
    firmaHash?: StringNullableFilter<"Proceso"> | string | null
    firmaIp?: StringNullableFilter<"Proceso"> | string | null
    firmaUserAgent?: StringNullableFilter<"Proceso"> | string | null
    cerradoEn?: DateTimeNullableFilter<"Proceso"> | Date | string | null
    cerradoPorId?: StringNullableFilter<"Proceso"> | string | null
    creadoEn?: DateTimeFilter<"Proceso"> | Date | string
    actualizadoEn?: DateTimeFilter<"Proceso"> | Date | string
    enviadoEn?: DateTimeNullableFilter<"Proceso"> | Date | string | null
    beneficiario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    arrendador?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
    documentos?: DocumentoListRelationFilter
    eventos?: EventoAuditoriaListRelationFilter
    decisiones?: DecisionListRelationFilter
    historialPdf?: HistorialPdfListRelationFilter
  }, "id" | "codigo">

  export type ProcesoOrderByWithAggregationInput = {
    id?: SortOrder
    codigo?: SortOrder
    beneficiarioId?: SortOrder
    arrendadorId?: SortOrderInput | SortOrder
    estado?: SortOrder
    formulario?: SortOrderInput | SortOrder
    pdfPath?: SortOrderInput | SortOrder
    pdfHash?: SortOrderInput | SortOrder
    pdfVersion?: SortOrder
    firmado?: SortOrder
    firmadoEn?: SortOrderInput | SortOrder
    firmadoPorId?: SortOrderInput | SortOrder
    firmaHash?: SortOrderInput | SortOrder
    firmaIp?: SortOrderInput | SortOrder
    firmaUserAgent?: SortOrderInput | SortOrder
    cerradoEn?: SortOrderInput | SortOrder
    cerradoPorId?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    enviadoEn?: SortOrderInput | SortOrder
    _count?: ProcesoCountOrderByAggregateInput
    _avg?: ProcesoAvgOrderByAggregateInput
    _max?: ProcesoMaxOrderByAggregateInput
    _min?: ProcesoMinOrderByAggregateInput
    _sum?: ProcesoSumOrderByAggregateInput
  }

  export type ProcesoScalarWhereWithAggregatesInput = {
    AND?: ProcesoScalarWhereWithAggregatesInput | ProcesoScalarWhereWithAggregatesInput[]
    OR?: ProcesoScalarWhereWithAggregatesInput[]
    NOT?: ProcesoScalarWhereWithAggregatesInput | ProcesoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Proceso"> | string
    codigo?: StringWithAggregatesFilter<"Proceso"> | string
    beneficiarioId?: StringWithAggregatesFilter<"Proceso"> | string
    arrendadorId?: StringNullableWithAggregatesFilter<"Proceso"> | string | null
    estado?: EnumEstadoProcesoWithAggregatesFilter<"Proceso"> | $Enums.EstadoProceso
    formulario?: JsonNullableWithAggregatesFilter<"Proceso">
    pdfPath?: StringNullableWithAggregatesFilter<"Proceso"> | string | null
    pdfHash?: StringNullableWithAggregatesFilter<"Proceso"> | string | null
    pdfVersion?: IntWithAggregatesFilter<"Proceso"> | number
    firmado?: BoolWithAggregatesFilter<"Proceso"> | boolean
    firmadoEn?: DateTimeNullableWithAggregatesFilter<"Proceso"> | Date | string | null
    firmadoPorId?: StringNullableWithAggregatesFilter<"Proceso"> | string | null
    firmaHash?: StringNullableWithAggregatesFilter<"Proceso"> | string | null
    firmaIp?: StringNullableWithAggregatesFilter<"Proceso"> | string | null
    firmaUserAgent?: StringNullableWithAggregatesFilter<"Proceso"> | string | null
    cerradoEn?: DateTimeNullableWithAggregatesFilter<"Proceso"> | Date | string | null
    cerradoPorId?: StringNullableWithAggregatesFilter<"Proceso"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"Proceso"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"Proceso"> | Date | string
    enviadoEn?: DateTimeNullableWithAggregatesFilter<"Proceso"> | Date | string | null
  }

  export type DocumentoWhereInput = {
    AND?: DocumentoWhereInput | DocumentoWhereInput[]
    OR?: DocumentoWhereInput[]
    NOT?: DocumentoWhereInput | DocumentoWhereInput[]
    id?: StringFilter<"Documento"> | string
    procesoId?: StringFilter<"Documento"> | string
    catalogoId?: StringFilter<"Documento"> | string
    nombreOriginal?: StringFilter<"Documento"> | string
    nombreAlmacenado?: StringFilter<"Documento"> | string
    rutaArchivo?: StringFilter<"Documento"> | string
    mimeType?: StringFilter<"Documento"> | string
    tamanoBytes?: IntFilter<"Documento"> | number
    hashArchivo?: StringFilter<"Documento"> | string
    estado?: EnumEstadoDocumentoFilter<"Documento"> | $Enums.EstadoDocumento
    validadoPorId?: StringNullableFilter<"Documento"> | string | null
    validadoEn?: DateTimeNullableFilter<"Documento"> | Date | string | null
    motivoRechazo?: StringNullableFilter<"Documento"> | string | null
    version?: IntFilter<"Documento"> | number
    esActivo?: BoolFilter<"Documento"> | boolean
    creadoEn?: DateTimeFilter<"Documento"> | Date | string
    cargadoPorId?: StringFilter<"Documento"> | string
    proceso?: XOR<ProcesoRelationFilter, ProcesoWhereInput>
    catalogo?: XOR<CatalogoDocumentoRelationFilter, CatalogoDocumentoWhereInput>
    cargadoPor?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    validadoPor?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
    descargas?: RegistroDescargaListRelationFilter
  }

  export type DocumentoOrderByWithRelationInput = {
    id?: SortOrder
    procesoId?: SortOrder
    catalogoId?: SortOrder
    nombreOriginal?: SortOrder
    nombreAlmacenado?: SortOrder
    rutaArchivo?: SortOrder
    mimeType?: SortOrder
    tamanoBytes?: SortOrder
    hashArchivo?: SortOrder
    estado?: SortOrder
    validadoPorId?: SortOrderInput | SortOrder
    validadoEn?: SortOrderInput | SortOrder
    motivoRechazo?: SortOrderInput | SortOrder
    version?: SortOrder
    esActivo?: SortOrder
    creadoEn?: SortOrder
    cargadoPorId?: SortOrder
    proceso?: ProcesoOrderByWithRelationInput
    catalogo?: CatalogoDocumentoOrderByWithRelationInput
    cargadoPor?: UsuarioOrderByWithRelationInput
    validadoPor?: UsuarioOrderByWithRelationInput
    descargas?: RegistroDescargaOrderByRelationAggregateInput
  }

  export type DocumentoWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DocumentoWhereInput | DocumentoWhereInput[]
    OR?: DocumentoWhereInput[]
    NOT?: DocumentoWhereInput | DocumentoWhereInput[]
    procesoId?: StringFilter<"Documento"> | string
    catalogoId?: StringFilter<"Documento"> | string
    nombreOriginal?: StringFilter<"Documento"> | string
    nombreAlmacenado?: StringFilter<"Documento"> | string
    rutaArchivo?: StringFilter<"Documento"> | string
    mimeType?: StringFilter<"Documento"> | string
    tamanoBytes?: IntFilter<"Documento"> | number
    hashArchivo?: StringFilter<"Documento"> | string
    estado?: EnumEstadoDocumentoFilter<"Documento"> | $Enums.EstadoDocumento
    validadoPorId?: StringNullableFilter<"Documento"> | string | null
    validadoEn?: DateTimeNullableFilter<"Documento"> | Date | string | null
    motivoRechazo?: StringNullableFilter<"Documento"> | string | null
    version?: IntFilter<"Documento"> | number
    esActivo?: BoolFilter<"Documento"> | boolean
    creadoEn?: DateTimeFilter<"Documento"> | Date | string
    cargadoPorId?: StringFilter<"Documento"> | string
    proceso?: XOR<ProcesoRelationFilter, ProcesoWhereInput>
    catalogo?: XOR<CatalogoDocumentoRelationFilter, CatalogoDocumentoWhereInput>
    cargadoPor?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
    validadoPor?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
    descargas?: RegistroDescargaListRelationFilter
  }, "id">

  export type DocumentoOrderByWithAggregationInput = {
    id?: SortOrder
    procesoId?: SortOrder
    catalogoId?: SortOrder
    nombreOriginal?: SortOrder
    nombreAlmacenado?: SortOrder
    rutaArchivo?: SortOrder
    mimeType?: SortOrder
    tamanoBytes?: SortOrder
    hashArchivo?: SortOrder
    estado?: SortOrder
    validadoPorId?: SortOrderInput | SortOrder
    validadoEn?: SortOrderInput | SortOrder
    motivoRechazo?: SortOrderInput | SortOrder
    version?: SortOrder
    esActivo?: SortOrder
    creadoEn?: SortOrder
    cargadoPorId?: SortOrder
    _count?: DocumentoCountOrderByAggregateInput
    _avg?: DocumentoAvgOrderByAggregateInput
    _max?: DocumentoMaxOrderByAggregateInput
    _min?: DocumentoMinOrderByAggregateInput
    _sum?: DocumentoSumOrderByAggregateInput
  }

  export type DocumentoScalarWhereWithAggregatesInput = {
    AND?: DocumentoScalarWhereWithAggregatesInput | DocumentoScalarWhereWithAggregatesInput[]
    OR?: DocumentoScalarWhereWithAggregatesInput[]
    NOT?: DocumentoScalarWhereWithAggregatesInput | DocumentoScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Documento"> | string
    procesoId?: StringWithAggregatesFilter<"Documento"> | string
    catalogoId?: StringWithAggregatesFilter<"Documento"> | string
    nombreOriginal?: StringWithAggregatesFilter<"Documento"> | string
    nombreAlmacenado?: StringWithAggregatesFilter<"Documento"> | string
    rutaArchivo?: StringWithAggregatesFilter<"Documento"> | string
    mimeType?: StringWithAggregatesFilter<"Documento"> | string
    tamanoBytes?: IntWithAggregatesFilter<"Documento"> | number
    hashArchivo?: StringWithAggregatesFilter<"Documento"> | string
    estado?: EnumEstadoDocumentoWithAggregatesFilter<"Documento"> | $Enums.EstadoDocumento
    validadoPorId?: StringNullableWithAggregatesFilter<"Documento"> | string | null
    validadoEn?: DateTimeNullableWithAggregatesFilter<"Documento"> | Date | string | null
    motivoRechazo?: StringNullableWithAggregatesFilter<"Documento"> | string | null
    version?: IntWithAggregatesFilter<"Documento"> | number
    esActivo?: BoolWithAggregatesFilter<"Documento"> | boolean
    creadoEn?: DateTimeWithAggregatesFilter<"Documento"> | Date | string
    cargadoPorId?: StringWithAggregatesFilter<"Documento"> | string
  }

  export type RegistroDescargaWhereInput = {
    AND?: RegistroDescargaWhereInput | RegistroDescargaWhereInput[]
    OR?: RegistroDescargaWhereInput[]
    NOT?: RegistroDescargaWhereInput | RegistroDescargaWhereInput[]
    id?: StringFilter<"RegistroDescarga"> | string
    documentoId?: StringFilter<"RegistroDescarga"> | string
    usuarioId?: StringFilter<"RegistroDescarga"> | string
    ipAddress?: StringFilter<"RegistroDescarga"> | string
    userAgent?: StringFilter<"RegistroDescarga"> | string
    creadoEn?: DateTimeFilter<"RegistroDescarga"> | Date | string
    documento?: XOR<DocumentoRelationFilter, DocumentoWhereInput>
  }

  export type RegistroDescargaOrderByWithRelationInput = {
    id?: SortOrder
    documentoId?: SortOrder
    usuarioId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    creadoEn?: SortOrder
    documento?: DocumentoOrderByWithRelationInput
  }

  export type RegistroDescargaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RegistroDescargaWhereInput | RegistroDescargaWhereInput[]
    OR?: RegistroDescargaWhereInput[]
    NOT?: RegistroDescargaWhereInput | RegistroDescargaWhereInput[]
    documentoId?: StringFilter<"RegistroDescarga"> | string
    usuarioId?: StringFilter<"RegistroDescarga"> | string
    ipAddress?: StringFilter<"RegistroDescarga"> | string
    userAgent?: StringFilter<"RegistroDescarga"> | string
    creadoEn?: DateTimeFilter<"RegistroDescarga"> | Date | string
    documento?: XOR<DocumentoRelationFilter, DocumentoWhereInput>
  }, "id">

  export type RegistroDescargaOrderByWithAggregationInput = {
    id?: SortOrder
    documentoId?: SortOrder
    usuarioId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    creadoEn?: SortOrder
    _count?: RegistroDescargaCountOrderByAggregateInput
    _max?: RegistroDescargaMaxOrderByAggregateInput
    _min?: RegistroDescargaMinOrderByAggregateInput
  }

  export type RegistroDescargaScalarWhereWithAggregatesInput = {
    AND?: RegistroDescargaScalarWhereWithAggregatesInput | RegistroDescargaScalarWhereWithAggregatesInput[]
    OR?: RegistroDescargaScalarWhereWithAggregatesInput[]
    NOT?: RegistroDescargaScalarWhereWithAggregatesInput | RegistroDescargaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RegistroDescarga"> | string
    documentoId?: StringWithAggregatesFilter<"RegistroDescarga"> | string
    usuarioId?: StringWithAggregatesFilter<"RegistroDescarga"> | string
    ipAddress?: StringWithAggregatesFilter<"RegistroDescarga"> | string
    userAgent?: StringWithAggregatesFilter<"RegistroDescarga"> | string
    creadoEn?: DateTimeWithAggregatesFilter<"RegistroDescarga"> | Date | string
  }

  export type HistorialPdfWhereInput = {
    AND?: HistorialPdfWhereInput | HistorialPdfWhereInput[]
    OR?: HistorialPdfWhereInput[]
    NOT?: HistorialPdfWhereInput | HistorialPdfWhereInput[]
    id?: StringFilter<"HistorialPdf"> | string
    procesoId?: StringFilter<"HistorialPdf"> | string
    version?: IntFilter<"HistorialPdf"> | number
    pdfPath?: StringFilter<"HistorialPdf"> | string
    pdfHash?: StringFilter<"HistorialPdf"> | string
    creadoEn?: DateTimeFilter<"HistorialPdf"> | Date | string
    proceso?: XOR<ProcesoRelationFilter, ProcesoWhereInput>
  }

  export type HistorialPdfOrderByWithRelationInput = {
    id?: SortOrder
    procesoId?: SortOrder
    version?: SortOrder
    pdfPath?: SortOrder
    pdfHash?: SortOrder
    creadoEn?: SortOrder
    proceso?: ProcesoOrderByWithRelationInput
  }

  export type HistorialPdfWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: HistorialPdfWhereInput | HistorialPdfWhereInput[]
    OR?: HistorialPdfWhereInput[]
    NOT?: HistorialPdfWhereInput | HistorialPdfWhereInput[]
    procesoId?: StringFilter<"HistorialPdf"> | string
    version?: IntFilter<"HistorialPdf"> | number
    pdfPath?: StringFilter<"HistorialPdf"> | string
    pdfHash?: StringFilter<"HistorialPdf"> | string
    creadoEn?: DateTimeFilter<"HistorialPdf"> | Date | string
    proceso?: XOR<ProcesoRelationFilter, ProcesoWhereInput>
  }, "id">

  export type HistorialPdfOrderByWithAggregationInput = {
    id?: SortOrder
    procesoId?: SortOrder
    version?: SortOrder
    pdfPath?: SortOrder
    pdfHash?: SortOrder
    creadoEn?: SortOrder
    _count?: HistorialPdfCountOrderByAggregateInput
    _avg?: HistorialPdfAvgOrderByAggregateInput
    _max?: HistorialPdfMaxOrderByAggregateInput
    _min?: HistorialPdfMinOrderByAggregateInput
    _sum?: HistorialPdfSumOrderByAggregateInput
  }

  export type HistorialPdfScalarWhereWithAggregatesInput = {
    AND?: HistorialPdfScalarWhereWithAggregatesInput | HistorialPdfScalarWhereWithAggregatesInput[]
    OR?: HistorialPdfScalarWhereWithAggregatesInput[]
    NOT?: HistorialPdfScalarWhereWithAggregatesInput | HistorialPdfScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"HistorialPdf"> | string
    procesoId?: StringWithAggregatesFilter<"HistorialPdf"> | string
    version?: IntWithAggregatesFilter<"HistorialPdf"> | number
    pdfPath?: StringWithAggregatesFilter<"HistorialPdf"> | string
    pdfHash?: StringWithAggregatesFilter<"HistorialPdf"> | string
    creadoEn?: DateTimeWithAggregatesFilter<"HistorialPdf"> | Date | string
  }

  export type DecisionWhereInput = {
    AND?: DecisionWhereInput | DecisionWhereInput[]
    OR?: DecisionWhereInput[]
    NOT?: DecisionWhereInput | DecisionWhereInput[]
    id?: StringFilter<"Decision"> | string
    procesoId?: StringFilter<"Decision"> | string
    estadoAnterior?: EnumEstadoProcesoFilter<"Decision"> | $Enums.EstadoProceso
    estadoNuevo?: EnumEstadoProcesoFilter<"Decision"> | $Enums.EstadoProceso
    aprobado?: BoolFilter<"Decision"> | boolean
    motivo?: StringFilter<"Decision"> | string
    usuarioId?: StringFilter<"Decision"> | string
    rol?: EnumRolFilter<"Decision"> | $Enums.Rol
    ipAddress?: StringFilter<"Decision"> | string
    userAgent?: StringFilter<"Decision"> | string
    creadoEn?: DateTimeFilter<"Decision"> | Date | string
    proceso?: XOR<ProcesoRelationFilter, ProcesoWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }

  export type DecisionOrderByWithRelationInput = {
    id?: SortOrder
    procesoId?: SortOrder
    estadoAnterior?: SortOrder
    estadoNuevo?: SortOrder
    aprobado?: SortOrder
    motivo?: SortOrder
    usuarioId?: SortOrder
    rol?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    creadoEn?: SortOrder
    proceso?: ProcesoOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type DecisionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DecisionWhereInput | DecisionWhereInput[]
    OR?: DecisionWhereInput[]
    NOT?: DecisionWhereInput | DecisionWhereInput[]
    procesoId?: StringFilter<"Decision"> | string
    estadoAnterior?: EnumEstadoProcesoFilter<"Decision"> | $Enums.EstadoProceso
    estadoNuevo?: EnumEstadoProcesoFilter<"Decision"> | $Enums.EstadoProceso
    aprobado?: BoolFilter<"Decision"> | boolean
    motivo?: StringFilter<"Decision"> | string
    usuarioId?: StringFilter<"Decision"> | string
    rol?: EnumRolFilter<"Decision"> | $Enums.Rol
    ipAddress?: StringFilter<"Decision"> | string
    userAgent?: StringFilter<"Decision"> | string
    creadoEn?: DateTimeFilter<"Decision"> | Date | string
    proceso?: XOR<ProcesoRelationFilter, ProcesoWhereInput>
    usuario?: XOR<UsuarioRelationFilter, UsuarioWhereInput>
  }, "id">

  export type DecisionOrderByWithAggregationInput = {
    id?: SortOrder
    procesoId?: SortOrder
    estadoAnterior?: SortOrder
    estadoNuevo?: SortOrder
    aprobado?: SortOrder
    motivo?: SortOrder
    usuarioId?: SortOrder
    rol?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    creadoEn?: SortOrder
    _count?: DecisionCountOrderByAggregateInput
    _max?: DecisionMaxOrderByAggregateInput
    _min?: DecisionMinOrderByAggregateInput
  }

  export type DecisionScalarWhereWithAggregatesInput = {
    AND?: DecisionScalarWhereWithAggregatesInput | DecisionScalarWhereWithAggregatesInput[]
    OR?: DecisionScalarWhereWithAggregatesInput[]
    NOT?: DecisionScalarWhereWithAggregatesInput | DecisionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Decision"> | string
    procesoId?: StringWithAggregatesFilter<"Decision"> | string
    estadoAnterior?: EnumEstadoProcesoWithAggregatesFilter<"Decision"> | $Enums.EstadoProceso
    estadoNuevo?: EnumEstadoProcesoWithAggregatesFilter<"Decision"> | $Enums.EstadoProceso
    aprobado?: BoolWithAggregatesFilter<"Decision"> | boolean
    motivo?: StringWithAggregatesFilter<"Decision"> | string
    usuarioId?: StringWithAggregatesFilter<"Decision"> | string
    rol?: EnumRolWithAggregatesFilter<"Decision"> | $Enums.Rol
    ipAddress?: StringWithAggregatesFilter<"Decision"> | string
    userAgent?: StringWithAggregatesFilter<"Decision"> | string
    creadoEn?: DateTimeWithAggregatesFilter<"Decision"> | Date | string
  }

  export type EventoAuditoriaWhereInput = {
    AND?: EventoAuditoriaWhereInput | EventoAuditoriaWhereInput[]
    OR?: EventoAuditoriaWhereInput[]
    NOT?: EventoAuditoriaWhereInput | EventoAuditoriaWhereInput[]
    id?: StringFilter<"EventoAuditoria"> | string
    procesoId?: StringNullableFilter<"EventoAuditoria"> | string | null
    usuarioId?: StringNullableFilter<"EventoAuditoria"> | string | null
    tipo?: EnumTipoEventoFilter<"EventoAuditoria"> | $Enums.TipoEvento
    descripcion?: StringFilter<"EventoAuditoria"> | string
    detalles?: JsonNullableFilter<"EventoAuditoria">
    ipAddress?: StringFilter<"EventoAuditoria"> | string
    userAgent?: StringFilter<"EventoAuditoria"> | string
    creadoEn?: DateTimeFilter<"EventoAuditoria"> | Date | string
    proceso?: XOR<ProcesoNullableRelationFilter, ProcesoWhereInput> | null
    usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
  }

  export type EventoAuditoriaOrderByWithRelationInput = {
    id?: SortOrder
    procesoId?: SortOrderInput | SortOrder
    usuarioId?: SortOrderInput | SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
    detalles?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    creadoEn?: SortOrder
    proceso?: ProcesoOrderByWithRelationInput
    usuario?: UsuarioOrderByWithRelationInput
  }

  export type EventoAuditoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EventoAuditoriaWhereInput | EventoAuditoriaWhereInput[]
    OR?: EventoAuditoriaWhereInput[]
    NOT?: EventoAuditoriaWhereInput | EventoAuditoriaWhereInput[]
    procesoId?: StringNullableFilter<"EventoAuditoria"> | string | null
    usuarioId?: StringNullableFilter<"EventoAuditoria"> | string | null
    tipo?: EnumTipoEventoFilter<"EventoAuditoria"> | $Enums.TipoEvento
    descripcion?: StringFilter<"EventoAuditoria"> | string
    detalles?: JsonNullableFilter<"EventoAuditoria">
    ipAddress?: StringFilter<"EventoAuditoria"> | string
    userAgent?: StringFilter<"EventoAuditoria"> | string
    creadoEn?: DateTimeFilter<"EventoAuditoria"> | Date | string
    proceso?: XOR<ProcesoNullableRelationFilter, ProcesoWhereInput> | null
    usuario?: XOR<UsuarioNullableRelationFilter, UsuarioWhereInput> | null
  }, "id">

  export type EventoAuditoriaOrderByWithAggregationInput = {
    id?: SortOrder
    procesoId?: SortOrderInput | SortOrder
    usuarioId?: SortOrderInput | SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
    detalles?: SortOrderInput | SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    creadoEn?: SortOrder
    _count?: EventoAuditoriaCountOrderByAggregateInput
    _max?: EventoAuditoriaMaxOrderByAggregateInput
    _min?: EventoAuditoriaMinOrderByAggregateInput
  }

  export type EventoAuditoriaScalarWhereWithAggregatesInput = {
    AND?: EventoAuditoriaScalarWhereWithAggregatesInput | EventoAuditoriaScalarWhereWithAggregatesInput[]
    OR?: EventoAuditoriaScalarWhereWithAggregatesInput[]
    NOT?: EventoAuditoriaScalarWhereWithAggregatesInput | EventoAuditoriaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventoAuditoria"> | string
    procesoId?: StringNullableWithAggregatesFilter<"EventoAuditoria"> | string | null
    usuarioId?: StringNullableWithAggregatesFilter<"EventoAuditoria"> | string | null
    tipo?: EnumTipoEventoWithAggregatesFilter<"EventoAuditoria"> | $Enums.TipoEvento
    descripcion?: StringWithAggregatesFilter<"EventoAuditoria"> | string
    detalles?: JsonNullableWithAggregatesFilter<"EventoAuditoria">
    ipAddress?: StringWithAggregatesFilter<"EventoAuditoria"> | string
    userAgent?: StringWithAggregatesFilter<"EventoAuditoria"> | string
    creadoEn?: DateTimeWithAggregatesFilter<"EventoAuditoria"> | Date | string
  }

  export type ConfiguracionWhereInput = {
    AND?: ConfiguracionWhereInput | ConfiguracionWhereInput[]
    OR?: ConfiguracionWhereInput[]
    NOT?: ConfiguracionWhereInput | ConfiguracionWhereInput[]
    id?: StringFilter<"Configuracion"> | string
    clave?: StringFilter<"Configuracion"> | string
    valor?: StringFilter<"Configuracion"> | string
    descripcion?: StringNullableFilter<"Configuracion"> | string | null
    creadoEn?: DateTimeFilter<"Configuracion"> | Date | string
    actualizadoEn?: DateTimeFilter<"Configuracion"> | Date | string
  }

  export type ConfiguracionOrderByWithRelationInput = {
    id?: SortOrder
    clave?: SortOrder
    valor?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type ConfiguracionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    clave?: string
    AND?: ConfiguracionWhereInput | ConfiguracionWhereInput[]
    OR?: ConfiguracionWhereInput[]
    NOT?: ConfiguracionWhereInput | ConfiguracionWhereInput[]
    valor?: StringFilter<"Configuracion"> | string
    descripcion?: StringNullableFilter<"Configuracion"> | string | null
    creadoEn?: DateTimeFilter<"Configuracion"> | Date | string
    actualizadoEn?: DateTimeFilter<"Configuracion"> | Date | string
  }, "id" | "clave">

  export type ConfiguracionOrderByWithAggregationInput = {
    id?: SortOrder
    clave?: SortOrder
    valor?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: ConfiguracionCountOrderByAggregateInput
    _max?: ConfiguracionMaxOrderByAggregateInput
    _min?: ConfiguracionMinOrderByAggregateInput
  }

  export type ConfiguracionScalarWhereWithAggregatesInput = {
    AND?: ConfiguracionScalarWhereWithAggregatesInput | ConfiguracionScalarWhereWithAggregatesInput[]
    OR?: ConfiguracionScalarWhereWithAggregatesInput[]
    NOT?: ConfiguracionScalarWhereWithAggregatesInput | ConfiguracionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Configuracion"> | string
    clave?: StringWithAggregatesFilter<"Configuracion"> | string
    valor?: StringWithAggregatesFilter<"Configuracion"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Configuracion"> | string | null
    creadoEn?: DateTimeWithAggregatesFilter<"Configuracion"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"Configuracion"> | Date | string
  }

  export type ConvocatoriaWhereInput = {
    AND?: ConvocatoriaWhereInput | ConvocatoriaWhereInput[]
    OR?: ConvocatoriaWhereInput[]
    NOT?: ConvocatoriaWhereInput | ConvocatoriaWhereInput[]
    id?: StringFilter<"Convocatoria"> | string
    nombre?: StringFilter<"Convocatoria"> | string
    descripcion?: StringNullableFilter<"Convocatoria"> | string | null
    fechaInicio?: DateTimeFilter<"Convocatoria"> | Date | string
    fechaFin?: DateTimeFilter<"Convocatoria"> | Date | string
    activa?: BoolFilter<"Convocatoria"> | boolean
    formularioJson?: JsonNullableFilter<"Convocatoria">
    creadoEn?: DateTimeFilter<"Convocatoria"> | Date | string
    actualizadoEn?: DateTimeFilter<"Convocatoria"> | Date | string
  }

  export type ConvocatoriaOrderByWithRelationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    activa?: SortOrder
    formularioJson?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type ConvocatoriaWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ConvocatoriaWhereInput | ConvocatoriaWhereInput[]
    OR?: ConvocatoriaWhereInput[]
    NOT?: ConvocatoriaWhereInput | ConvocatoriaWhereInput[]
    nombre?: StringFilter<"Convocatoria"> | string
    descripcion?: StringNullableFilter<"Convocatoria"> | string | null
    fechaInicio?: DateTimeFilter<"Convocatoria"> | Date | string
    fechaFin?: DateTimeFilter<"Convocatoria"> | Date | string
    activa?: BoolFilter<"Convocatoria"> | boolean
    formularioJson?: JsonNullableFilter<"Convocatoria">
    creadoEn?: DateTimeFilter<"Convocatoria"> | Date | string
    actualizadoEn?: DateTimeFilter<"Convocatoria"> | Date | string
  }, "id">

  export type ConvocatoriaOrderByWithAggregationInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrderInput | SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    activa?: SortOrder
    formularioJson?: SortOrderInput | SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    _count?: ConvocatoriaCountOrderByAggregateInput
    _max?: ConvocatoriaMaxOrderByAggregateInput
    _min?: ConvocatoriaMinOrderByAggregateInput
  }

  export type ConvocatoriaScalarWhereWithAggregatesInput = {
    AND?: ConvocatoriaScalarWhereWithAggregatesInput | ConvocatoriaScalarWhereWithAggregatesInput[]
    OR?: ConvocatoriaScalarWhereWithAggregatesInput[]
    NOT?: ConvocatoriaScalarWhereWithAggregatesInput | ConvocatoriaScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Convocatoria"> | string
    nombre?: StringWithAggregatesFilter<"Convocatoria"> | string
    descripcion?: StringNullableWithAggregatesFilter<"Convocatoria"> | string | null
    fechaInicio?: DateTimeWithAggregatesFilter<"Convocatoria"> | Date | string
    fechaFin?: DateTimeWithAggregatesFilter<"Convocatoria"> | Date | string
    activa?: BoolWithAggregatesFilter<"Convocatoria"> | boolean
    formularioJson?: JsonNullableWithAggregatesFilter<"Convocatoria">
    creadoEn?: DateTimeWithAggregatesFilter<"Convocatoria"> | Date | string
    actualizadoEn?: DateTimeWithAggregatesFilter<"Convocatoria"> | Date | string
  }

  export type UsuarioCreateInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPor?: UsuarioCreateNestedOneWithoutUsuariosCreadosInput
    usuariosCreados?: UsuarioCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPorId?: string | null
    usuariosCreados?: UsuarioUncheckedCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialUncheckedCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionUncheckedCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoUncheckedCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoUncheckedCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoUncheckedCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoUncheckedCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionUncheckedCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionUncheckedCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPor?: UsuarioUpdateOneWithoutUsuariosCreadosNestedInput
    usuariosCreados?: UsuarioUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosCreados?: UsuarioUncheckedUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUncheckedUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUncheckedUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUncheckedUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUncheckedUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUncheckedUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUncheckedUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUncheckedUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUncheckedUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPorId?: string | null
  }

  export type UsuarioUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PasswordHistorialCreateInput = {
    id?: string
    passwordHash: string
    creadoEn?: Date | string
    usuario: UsuarioCreateNestedOneWithoutPasswordHistorialInput
  }

  export type PasswordHistorialUncheckedCreateInput = {
    id?: string
    usuarioId: string
    passwordHash: string
    creadoEn?: Date | string
  }

  export type PasswordHistorialUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutPasswordHistorialNestedInput
  }

  export type PasswordHistorialUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistorialCreateManyInput = {
    id?: string
    usuarioId: string
    passwordHash: string
    creadoEn?: Date | string
  }

  export type PasswordHistorialUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistorialUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenRecuperacionCreateInput = {
    id?: string
    token: string
    expiraEn: Date | string
    usado?: boolean
    creadoEn?: Date | string
    usuario: UsuarioCreateNestedOneWithoutTokenRecuperacionInput
  }

  export type TokenRecuperacionUncheckedCreateInput = {
    id?: string
    usuarioId: string
    token: string
    expiraEn: Date | string
    usado?: boolean
    creadoEn?: Date | string
  }

  export type TokenRecuperacionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutTokenRecuperacionNestedInput
  }

  export type TokenRecuperacionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenRecuperacionCreateManyInput = {
    id?: string
    usuarioId: string
    token: string
    expiraEn: Date | string
    usado?: boolean
    creadoEn?: Date | string
  }

  export type TokenRecuperacionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenRecuperacionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SesionCreateInput = {
    id?: string
    tokenHash: string
    ipAddress: string
    userAgent: string
    expiraEn: Date | string
    creadoEn?: Date | string
    ultimaActividad?: Date | string
    usuario: UsuarioCreateNestedOneWithoutSesionesInput
  }

  export type SesionUncheckedCreateInput = {
    id?: string
    usuarioId: string
    tokenHash: string
    ipAddress: string
    userAgent: string
    expiraEn: Date | string
    creadoEn?: Date | string
    ultimaActividad?: Date | string
  }

  export type SesionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    ultimaActividad?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutSesionesNestedInput
  }

  export type SesionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    ultimaActividad?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SesionCreateManyInput = {
    id?: string
    usuarioId: string
    tokenHash: string
    ipAddress: string
    userAgent: string
    expiraEn: Date | string
    creadoEn?: Date | string
    ultimaActividad?: Date | string
  }

  export type SesionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    ultimaActividad?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SesionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    ultimaActividad?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CambioRolCreateInput = {
    id?: string
    rolAnterior: $Enums.Rol
    rolNuevo: $Enums.Rol
    motivo?: string | null
    cambiadoPorId: string
    creadoEn?: Date | string
    usuario: UsuarioCreateNestedOneWithoutCambiosRolInput
  }

  export type CambioRolUncheckedCreateInput = {
    id?: string
    usuarioId: string
    rolAnterior: $Enums.Rol
    rolNuevo: $Enums.Rol
    motivo?: string | null
    cambiadoPorId: string
    creadoEn?: Date | string
  }

  export type CambioRolUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    rolAnterior?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    rolNuevo?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    cambiadoPorId?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutCambiosRolNestedInput
  }

  export type CambioRolUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    rolAnterior?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    rolNuevo?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    cambiadoPorId?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CambioRolCreateManyInput = {
    id?: string
    usuarioId: string
    rolAnterior: $Enums.Rol
    rolNuevo: $Enums.Rol
    motivo?: string | null
    cambiadoPorId: string
    creadoEn?: Date | string
  }

  export type CambioRolUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    rolAnterior?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    rolNuevo?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    cambiadoPorId?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CambioRolUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    rolAnterior?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    rolNuevo?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    cambiadoPorId?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogoDocumentoCreateInput = {
    id?: string
    tipo: $Enums.TipoDocumento
    nombre: string
    descripcion?: string | null
    obligatorio?: boolean
    formatosPermitidos?: CatalogoDocumentoCreateformatosPermitidosInput | string[]
    tamanoMaximoMb?: number
    vigenciaDias?: number | null
    activo?: boolean
    orden?: number
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    documentos?: DocumentoCreateNestedManyWithoutCatalogoInput
  }

  export type CatalogoDocumentoUncheckedCreateInput = {
    id?: string
    tipo: $Enums.TipoDocumento
    nombre: string
    descripcion?: string | null
    obligatorio?: boolean
    formatosPermitidos?: CatalogoDocumentoCreateformatosPermitidosInput | string[]
    tamanoMaximoMb?: number
    vigenciaDias?: number | null
    activo?: boolean
    orden?: number
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    documentos?: DocumentoUncheckedCreateNestedManyWithoutCatalogoInput
  }

  export type CatalogoDocumentoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    obligatorio?: BoolFieldUpdateOperationsInput | boolean
    formatosPermitidos?: CatalogoDocumentoUpdateformatosPermitidosInput | string[]
    tamanoMaximoMb?: IntFieldUpdateOperationsInput | number
    vigenciaDias?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    documentos?: DocumentoUpdateManyWithoutCatalogoNestedInput
  }

  export type CatalogoDocumentoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    obligatorio?: BoolFieldUpdateOperationsInput | boolean
    formatosPermitidos?: CatalogoDocumentoUpdateformatosPermitidosInput | string[]
    tamanoMaximoMb?: IntFieldUpdateOperationsInput | number
    vigenciaDias?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    documentos?: DocumentoUncheckedUpdateManyWithoutCatalogoNestedInput
  }

  export type CatalogoDocumentoCreateManyInput = {
    id?: string
    tipo: $Enums.TipoDocumento
    nombre: string
    descripcion?: string | null
    obligatorio?: boolean
    formatosPermitidos?: CatalogoDocumentoCreateformatosPermitidosInput | string[]
    tamanoMaximoMb?: number
    vigenciaDias?: number | null
    activo?: boolean
    orden?: number
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type CatalogoDocumentoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    obligatorio?: BoolFieldUpdateOperationsInput | boolean
    formatosPermitidos?: CatalogoDocumentoUpdateformatosPermitidosInput | string[]
    tamanoMaximoMb?: IntFieldUpdateOperationsInput | number
    vigenciaDias?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogoDocumentoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    obligatorio?: BoolFieldUpdateOperationsInput | boolean
    formatosPermitidos?: CatalogoDocumentoUpdateformatosPermitidosInput | string[]
    tamanoMaximoMb?: IntFieldUpdateOperationsInput | number
    vigenciaDias?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcesoCreateInput = {
    id?: string
    codigo: string
    estado?: $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: string | null
    pdfHash?: string | null
    pdfVersion?: number
    firmado?: boolean
    firmadoEn?: Date | string | null
    firmadoPorId?: string | null
    firmaHash?: string | null
    firmaIp?: string | null
    firmaUserAgent?: string | null
    cerradoEn?: Date | string | null
    cerradoPorId?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    enviadoEn?: Date | string | null
    beneficiario: UsuarioCreateNestedOneWithoutProcesosBeneficiarioInput
    arrendador?: UsuarioCreateNestedOneWithoutProcesosArrendadorInput
    documentos?: DocumentoCreateNestedManyWithoutProcesoInput
    eventos?: EventoAuditoriaCreateNestedManyWithoutProcesoInput
    decisiones?: DecisionCreateNestedManyWithoutProcesoInput
    historialPdf?: HistorialPdfCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoUncheckedCreateInput = {
    id?: string
    codigo: string
    beneficiarioId: string
    arrendadorId?: string | null
    estado?: $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: string | null
    pdfHash?: string | null
    pdfVersion?: number
    firmado?: boolean
    firmadoEn?: Date | string | null
    firmadoPorId?: string | null
    firmaHash?: string | null
    firmaIp?: string | null
    firmaUserAgent?: string | null
    cerradoEn?: Date | string | null
    cerradoPorId?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    enviadoEn?: Date | string | null
    documentos?: DocumentoUncheckedCreateNestedManyWithoutProcesoInput
    eventos?: EventoAuditoriaUncheckedCreateNestedManyWithoutProcesoInput
    decisiones?: DecisionUncheckedCreateNestedManyWithoutProcesoInput
    historialPdf?: HistorialPdfUncheckedCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    pdfHash?: NullableStringFieldUpdateOperationsInput | string | null
    pdfVersion?: IntFieldUpdateOperationsInput | number
    firmado?: BoolFieldUpdateOperationsInput | boolean
    firmadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    firmaHash?: NullableStringFieldUpdateOperationsInput | string | null
    firmaIp?: NullableStringFieldUpdateOperationsInput | string | null
    firmaUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cerradoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cerradoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beneficiario?: UsuarioUpdateOneRequiredWithoutProcesosBeneficiarioNestedInput
    arrendador?: UsuarioUpdateOneWithoutProcesosArrendadorNestedInput
    documentos?: DocumentoUpdateManyWithoutProcesoNestedInput
    eventos?: EventoAuditoriaUpdateManyWithoutProcesoNestedInput
    decisiones?: DecisionUpdateManyWithoutProcesoNestedInput
    historialPdf?: HistorialPdfUpdateManyWithoutProcesoNestedInput
  }

  export type ProcesoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiarioId?: StringFieldUpdateOperationsInput | string
    arrendadorId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    pdfHash?: NullableStringFieldUpdateOperationsInput | string | null
    pdfVersion?: IntFieldUpdateOperationsInput | number
    firmado?: BoolFieldUpdateOperationsInput | boolean
    firmadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    firmaHash?: NullableStringFieldUpdateOperationsInput | string | null
    firmaIp?: NullableStringFieldUpdateOperationsInput | string | null
    firmaUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cerradoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cerradoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentos?: DocumentoUncheckedUpdateManyWithoutProcesoNestedInput
    eventos?: EventoAuditoriaUncheckedUpdateManyWithoutProcesoNestedInput
    decisiones?: DecisionUncheckedUpdateManyWithoutProcesoNestedInput
    historialPdf?: HistorialPdfUncheckedUpdateManyWithoutProcesoNestedInput
  }

  export type ProcesoCreateManyInput = {
    id?: string
    codigo: string
    beneficiarioId: string
    arrendadorId?: string | null
    estado?: $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: string | null
    pdfHash?: string | null
    pdfVersion?: number
    firmado?: boolean
    firmadoEn?: Date | string | null
    firmadoPorId?: string | null
    firmaHash?: string | null
    firmaIp?: string | null
    firmaUserAgent?: string | null
    cerradoEn?: Date | string | null
    cerradoPorId?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    enviadoEn?: Date | string | null
  }

  export type ProcesoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    pdfHash?: NullableStringFieldUpdateOperationsInput | string | null
    pdfVersion?: IntFieldUpdateOperationsInput | number
    firmado?: BoolFieldUpdateOperationsInput | boolean
    firmadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    firmaHash?: NullableStringFieldUpdateOperationsInput | string | null
    firmaIp?: NullableStringFieldUpdateOperationsInput | string | null
    firmaUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cerradoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cerradoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProcesoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiarioId?: StringFieldUpdateOperationsInput | string
    arrendadorId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    pdfHash?: NullableStringFieldUpdateOperationsInput | string | null
    pdfVersion?: IntFieldUpdateOperationsInput | number
    firmado?: BoolFieldUpdateOperationsInput | boolean
    firmadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    firmaHash?: NullableStringFieldUpdateOperationsInput | string | null
    firmaIp?: NullableStringFieldUpdateOperationsInput | string | null
    firmaUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cerradoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cerradoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentoCreateInput = {
    id?: string
    nombreOriginal: string
    nombreAlmacenado: string
    rutaArchivo: string
    mimeType: string
    tamanoBytes: number
    hashArchivo: string
    estado?: $Enums.EstadoDocumento
    validadoEn?: Date | string | null
    motivoRechazo?: string | null
    version?: number
    esActivo?: boolean
    creadoEn?: Date | string
    proceso: ProcesoCreateNestedOneWithoutDocumentosInput
    catalogo: CatalogoDocumentoCreateNestedOneWithoutDocumentosInput
    cargadoPor: UsuarioCreateNestedOneWithoutDocumentosCargadosInput
    validadoPor?: UsuarioCreateNestedOneWithoutDocumentosValidadosInput
    descargas?: RegistroDescargaCreateNestedManyWithoutDocumentoInput
  }

  export type DocumentoUncheckedCreateInput = {
    id?: string
    procesoId: string
    catalogoId: string
    nombreOriginal: string
    nombreAlmacenado: string
    rutaArchivo: string
    mimeType: string
    tamanoBytes: number
    hashArchivo: string
    estado?: $Enums.EstadoDocumento
    validadoPorId?: string | null
    validadoEn?: Date | string | null
    motivoRechazo?: string | null
    version?: number
    esActivo?: boolean
    creadoEn?: Date | string
    cargadoPorId: string
    descargas?: RegistroDescargaUncheckedCreateNestedManyWithoutDocumentoInput
  }

  export type DocumentoUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreOriginal?: StringFieldUpdateOperationsInput | string
    nombreAlmacenado?: StringFieldUpdateOperationsInput | string
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    hashArchivo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDocumentoFieldUpdateOperationsInput | $Enums.EstadoDocumento
    validadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    proceso?: ProcesoUpdateOneRequiredWithoutDocumentosNestedInput
    catalogo?: CatalogoDocumentoUpdateOneRequiredWithoutDocumentosNestedInput
    cargadoPor?: UsuarioUpdateOneRequiredWithoutDocumentosCargadosNestedInput
    validadoPor?: UsuarioUpdateOneWithoutDocumentosValidadosNestedInput
    descargas?: RegistroDescargaUpdateManyWithoutDocumentoNestedInput
  }

  export type DocumentoUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    catalogoId?: StringFieldUpdateOperationsInput | string
    nombreOriginal?: StringFieldUpdateOperationsInput | string
    nombreAlmacenado?: StringFieldUpdateOperationsInput | string
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    hashArchivo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDocumentoFieldUpdateOperationsInput | $Enums.EstadoDocumento
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    validadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    cargadoPorId?: StringFieldUpdateOperationsInput | string
    descargas?: RegistroDescargaUncheckedUpdateManyWithoutDocumentoNestedInput
  }

  export type DocumentoCreateManyInput = {
    id?: string
    procesoId: string
    catalogoId: string
    nombreOriginal: string
    nombreAlmacenado: string
    rutaArchivo: string
    mimeType: string
    tamanoBytes: number
    hashArchivo: string
    estado?: $Enums.EstadoDocumento
    validadoPorId?: string | null
    validadoEn?: Date | string | null
    motivoRechazo?: string | null
    version?: number
    esActivo?: boolean
    creadoEn?: Date | string
    cargadoPorId: string
  }

  export type DocumentoUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreOriginal?: StringFieldUpdateOperationsInput | string
    nombreAlmacenado?: StringFieldUpdateOperationsInput | string
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    hashArchivo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDocumentoFieldUpdateOperationsInput | $Enums.EstadoDocumento
    validadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentoUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    catalogoId?: StringFieldUpdateOperationsInput | string
    nombreOriginal?: StringFieldUpdateOperationsInput | string
    nombreAlmacenado?: StringFieldUpdateOperationsInput | string
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    hashArchivo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDocumentoFieldUpdateOperationsInput | $Enums.EstadoDocumento
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    validadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    cargadoPorId?: StringFieldUpdateOperationsInput | string
  }

  export type RegistroDescargaCreateInput = {
    id?: string
    usuarioId: string
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
    documento: DocumentoCreateNestedOneWithoutDescargasInput
  }

  export type RegistroDescargaUncheckedCreateInput = {
    id?: string
    documentoId: string
    usuarioId: string
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
  }

  export type RegistroDescargaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    documento?: DocumentoUpdateOneRequiredWithoutDescargasNestedInput
  }

  export type RegistroDescargaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegistroDescargaCreateManyInput = {
    id?: string
    documentoId: string
    usuarioId: string
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
  }

  export type RegistroDescargaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegistroDescargaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    documentoId?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistorialPdfCreateInput = {
    id?: string
    version: number
    pdfPath: string
    pdfHash: string
    creadoEn?: Date | string
    proceso: ProcesoCreateNestedOneWithoutHistorialPdfInput
  }

  export type HistorialPdfUncheckedCreateInput = {
    id?: string
    procesoId: string
    version: number
    pdfPath: string
    pdfHash: string
    creadoEn?: Date | string
  }

  export type HistorialPdfUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    pdfPath?: StringFieldUpdateOperationsInput | string
    pdfHash?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    proceso?: ProcesoUpdateOneRequiredWithoutHistorialPdfNestedInput
  }

  export type HistorialPdfUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    pdfPath?: StringFieldUpdateOperationsInput | string
    pdfHash?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistorialPdfCreateManyInput = {
    id?: string
    procesoId: string
    version: number
    pdfPath: string
    pdfHash: string
    creadoEn?: Date | string
  }

  export type HistorialPdfUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    pdfPath?: StringFieldUpdateOperationsInput | string
    pdfHash?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistorialPdfUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    pdfPath?: StringFieldUpdateOperationsInput | string
    pdfHash?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionCreateInput = {
    id?: string
    estadoAnterior: $Enums.EstadoProceso
    estadoNuevo: $Enums.EstadoProceso
    aprobado: boolean
    motivo: string
    rol: $Enums.Rol
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
    proceso: ProcesoCreateNestedOneWithoutDecisionesInput
    usuario: UsuarioCreateNestedOneWithoutDecisionesInput
  }

  export type DecisionUncheckedCreateInput = {
    id?: string
    procesoId: string
    estadoAnterior: $Enums.EstadoProceso
    estadoNuevo: $Enums.EstadoProceso
    aprobado: boolean
    motivo: string
    usuarioId: string
    rol: $Enums.Rol
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
  }

  export type DecisionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    estadoAnterior?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    estadoNuevo?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    motivo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    proceso?: ProcesoUpdateOneRequiredWithoutDecisionesNestedInput
    usuario?: UsuarioUpdateOneRequiredWithoutDecisionesNestedInput
  }

  export type DecisionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    estadoAnterior?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    estadoNuevo?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    motivo?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionCreateManyInput = {
    id?: string
    procesoId: string
    estadoAnterior: $Enums.EstadoProceso
    estadoNuevo: $Enums.EstadoProceso
    aprobado: boolean
    motivo: string
    usuarioId: string
    rol: $Enums.Rol
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
  }

  export type DecisionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    estadoAnterior?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    estadoNuevo?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    motivo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    estadoAnterior?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    estadoNuevo?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    motivo?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoAuditoriaCreateInput = {
    id?: string
    tipo: $Enums.TipoEvento
    descripcion: string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
    proceso?: ProcesoCreateNestedOneWithoutEventosInput
    usuario?: UsuarioCreateNestedOneWithoutEventosAuditoriaInput
  }

  export type EventoAuditoriaUncheckedCreateInput = {
    id?: string
    procesoId?: string | null
    usuarioId?: string | null
    tipo: $Enums.TipoEvento
    descripcion: string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
  }

  export type EventoAuditoriaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoEventoFieldUpdateOperationsInput | $Enums.TipoEvento
    descripcion?: StringFieldUpdateOperationsInput | string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    proceso?: ProcesoUpdateOneWithoutEventosNestedInput
    usuario?: UsuarioUpdateOneWithoutEventosAuditoriaNestedInput
  }

  export type EventoAuditoriaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoEventoFieldUpdateOperationsInput | $Enums.TipoEvento
    descripcion?: StringFieldUpdateOperationsInput | string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoAuditoriaCreateManyInput = {
    id?: string
    procesoId?: string | null
    usuarioId?: string | null
    tipo: $Enums.TipoEvento
    descripcion: string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
  }

  export type EventoAuditoriaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoEventoFieldUpdateOperationsInput | $Enums.TipoEvento
    descripcion?: StringFieldUpdateOperationsInput | string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoAuditoriaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: NullableStringFieldUpdateOperationsInput | string | null
    usuarioId?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoEventoFieldUpdateOperationsInput | $Enums.TipoEvento
    descripcion?: StringFieldUpdateOperationsInput | string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracionCreateInput = {
    id?: string
    clave: string
    valor: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type ConfiguracionUncheckedCreateInput = {
    id?: string
    clave: string
    valor: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type ConfiguracionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    valor?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    valor?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracionCreateManyInput = {
    id?: string
    clave: string
    valor: string
    descripcion?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type ConfiguracionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    valor?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConfiguracionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    clave?: StringFieldUpdateOperationsInput | string
    valor?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConvocatoriaCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    fechaInicio: Date | string
    fechaFin: Date | string
    activa?: boolean
    formularioJson?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type ConvocatoriaUncheckedCreateInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    fechaInicio: Date | string
    fechaFin: Date | string
    activa?: boolean
    formularioJson?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type ConvocatoriaUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    formularioJson?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConvocatoriaUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    formularioJson?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConvocatoriaCreateManyInput = {
    id?: string
    nombre: string
    descripcion?: string | null
    fechaInicio: Date | string
    fechaFin: Date | string
    activa?: boolean
    formularioJson?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type ConvocatoriaUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    formularioJson?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ConvocatoriaUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    fechaInicio?: DateTimeFieldUpdateOperationsInput | Date | string
    fechaFin?: DateTimeFieldUpdateOperationsInput | Date | string
    activa?: BoolFieldUpdateOperationsInput | boolean
    formularioJson?: NullableJsonNullValueInput | InputJsonValue
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    notIn?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type EnumEstadoUsuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoUsuario | EnumEstadoUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoUsuario[] | ListEnumEstadoUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoUsuario[] | ListEnumEstadoUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoUsuarioFilter<$PrismaModel> | $Enums.EstadoUsuario
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type UsuarioNullableRelationFilter = {
    is?: UsuarioWhereInput | null
    isNot?: UsuarioWhereInput | null
  }

  export type UsuarioListRelationFilter = {
    every?: UsuarioWhereInput
    some?: UsuarioWhereInput
    none?: UsuarioWhereInput
  }

  export type PasswordHistorialListRelationFilter = {
    every?: PasswordHistorialWhereInput
    some?: PasswordHistorialWhereInput
    none?: PasswordHistorialWhereInput
  }

  export type SesionListRelationFilter = {
    every?: SesionWhereInput
    some?: SesionWhereInput
    none?: SesionWhereInput
  }

  export type ProcesoListRelationFilter = {
    every?: ProcesoWhereInput
    some?: ProcesoWhereInput
    none?: ProcesoWhereInput
  }

  export type DocumentoListRelationFilter = {
    every?: DocumentoWhereInput
    some?: DocumentoWhereInput
    none?: DocumentoWhereInput
  }

  export type EventoAuditoriaListRelationFilter = {
    every?: EventoAuditoriaWhereInput
    some?: EventoAuditoriaWhereInput
    none?: EventoAuditoriaWhereInput
  }

  export type DecisionListRelationFilter = {
    every?: DecisionWhereInput
    some?: DecisionWhereInput
    none?: DecisionWhereInput
  }

  export type TokenRecuperacionListRelationFilter = {
    every?: TokenRecuperacionWhereInput
    some?: TokenRecuperacionWhereInput
    none?: TokenRecuperacionWhereInput
  }

  export type CambioRolListRelationFilter = {
    every?: CambioRolWhereInput
    some?: CambioRolWhereInput
    none?: CambioRolWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type UsuarioOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PasswordHistorialOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SesionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcesoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentoOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventoAuditoriaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DecisionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TokenRecuperacionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CambioRolOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UsuarioCountOrderByAggregateInput = {
    id?: SortOrder
    cedula?: SortOrder
    email?: SortOrder
    nombreCompleto?: SortOrder
    passwordHash?: SortOrder
    rol?: SortOrder
    estado?: SortOrder
    mfaSecret?: SortOrder
    mfaHabilitado?: SortOrder
    intentosFallidos?: SortOrder
    bloqueadoHasta?: SortOrder
    ultimoAcceso?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    creadoPorId?: SortOrder
  }

  export type UsuarioAvgOrderByAggregateInput = {
    intentosFallidos?: SortOrder
  }

  export type UsuarioMaxOrderByAggregateInput = {
    id?: SortOrder
    cedula?: SortOrder
    email?: SortOrder
    nombreCompleto?: SortOrder
    passwordHash?: SortOrder
    rol?: SortOrder
    estado?: SortOrder
    mfaSecret?: SortOrder
    mfaHabilitado?: SortOrder
    intentosFallidos?: SortOrder
    bloqueadoHasta?: SortOrder
    ultimoAcceso?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    creadoPorId?: SortOrder
  }

  export type UsuarioMinOrderByAggregateInput = {
    id?: SortOrder
    cedula?: SortOrder
    email?: SortOrder
    nombreCompleto?: SortOrder
    passwordHash?: SortOrder
    rol?: SortOrder
    estado?: SortOrder
    mfaSecret?: SortOrder
    mfaHabilitado?: SortOrder
    intentosFallidos?: SortOrder
    bloqueadoHasta?: SortOrder
    ultimoAcceso?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    creadoPorId?: SortOrder
  }

  export type UsuarioSumOrderByAggregateInput = {
    intentosFallidos?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    notIn?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type EnumEstadoUsuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoUsuario | EnumEstadoUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoUsuario[] | ListEnumEstadoUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoUsuario[] | ListEnumEstadoUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoUsuarioWithAggregatesFilter<$PrismaModel> | $Enums.EstadoUsuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoUsuarioFilter<$PrismaModel>
    _max?: NestedEnumEstadoUsuarioFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type UsuarioRelationFilter = {
    is?: UsuarioWhereInput
    isNot?: UsuarioWhereInput
  }

  export type PasswordHistorialCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    passwordHash?: SortOrder
    creadoEn?: SortOrder
  }

  export type PasswordHistorialMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    passwordHash?: SortOrder
    creadoEn?: SortOrder
  }

  export type PasswordHistorialMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    passwordHash?: SortOrder
    creadoEn?: SortOrder
  }

  export type TokenRecuperacionCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    token?: SortOrder
    expiraEn?: SortOrder
    usado?: SortOrder
    creadoEn?: SortOrder
  }

  export type TokenRecuperacionMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    token?: SortOrder
    expiraEn?: SortOrder
    usado?: SortOrder
    creadoEn?: SortOrder
  }

  export type TokenRecuperacionMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    token?: SortOrder
    expiraEn?: SortOrder
    usado?: SortOrder
    creadoEn?: SortOrder
  }

  export type SesionCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tokenHash?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiraEn?: SortOrder
    creadoEn?: SortOrder
    ultimaActividad?: SortOrder
  }

  export type SesionMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tokenHash?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiraEn?: SortOrder
    creadoEn?: SortOrder
    ultimaActividad?: SortOrder
  }

  export type SesionMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    tokenHash?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    expiraEn?: SortOrder
    creadoEn?: SortOrder
    ultimaActividad?: SortOrder
  }

  export type CambioRolCountOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    rolAnterior?: SortOrder
    rolNuevo?: SortOrder
    motivo?: SortOrder
    cambiadoPorId?: SortOrder
    creadoEn?: SortOrder
  }

  export type CambioRolMaxOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    rolAnterior?: SortOrder
    rolNuevo?: SortOrder
    motivo?: SortOrder
    cambiadoPorId?: SortOrder
    creadoEn?: SortOrder
  }

  export type CambioRolMinOrderByAggregateInput = {
    id?: SortOrder
    usuarioId?: SortOrder
    rolAnterior?: SortOrder
    rolNuevo?: SortOrder
    motivo?: SortOrder
    cambiadoPorId?: SortOrder
    creadoEn?: SortOrder
  }

  export type EnumTipoDocumentoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoDocumento | EnumTipoDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoDocumento[] | ListEnumTipoDocumentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoDocumento[] | ListEnumTipoDocumentoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoDocumentoFilter<$PrismaModel> | $Enums.TipoDocumento
  }

  export type StringNullableListFilter<$PrismaModel = never> = {
    equals?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    has?: string | StringFieldRefInput<$PrismaModel> | null
    hasEvery?: string[] | ListStringFieldRefInput<$PrismaModel>
    hasSome?: string[] | ListStringFieldRefInput<$PrismaModel>
    isEmpty?: boolean
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type CatalogoDocumentoCountOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    obligatorio?: SortOrder
    formatosPermitidos?: SortOrder
    tamanoMaximoMb?: SortOrder
    vigenciaDias?: SortOrder
    activo?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type CatalogoDocumentoAvgOrderByAggregateInput = {
    tamanoMaximoMb?: SortOrder
    vigenciaDias?: SortOrder
    orden?: SortOrder
  }

  export type CatalogoDocumentoMaxOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    obligatorio?: SortOrder
    tamanoMaximoMb?: SortOrder
    vigenciaDias?: SortOrder
    activo?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type CatalogoDocumentoMinOrderByAggregateInput = {
    id?: SortOrder
    tipo?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    obligatorio?: SortOrder
    tamanoMaximoMb?: SortOrder
    vigenciaDias?: SortOrder
    activo?: SortOrder
    orden?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type CatalogoDocumentoSumOrderByAggregateInput = {
    tamanoMaximoMb?: SortOrder
    vigenciaDias?: SortOrder
    orden?: SortOrder
  }

  export type EnumTipoDocumentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoDocumento | EnumTipoDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoDocumento[] | ListEnumTipoDocumentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoDocumento[] | ListEnumTipoDocumentoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoDocumentoWithAggregatesFilter<$PrismaModel> | $Enums.TipoDocumento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoDocumentoFilter<$PrismaModel>
    _max?: NestedEnumTipoDocumentoFilter<$PrismaModel>
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type EnumEstadoProcesoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoProceso | EnumEstadoProcesoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoProceso[] | ListEnumEstadoProcesoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoProceso[] | ListEnumEstadoProcesoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoProcesoFilter<$PrismaModel> | $Enums.EstadoProceso
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type HistorialPdfListRelationFilter = {
    every?: HistorialPdfWhereInput
    some?: HistorialPdfWhereInput
    none?: HistorialPdfWhereInput
  }

  export type HistorialPdfOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ProcesoCountOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    beneficiarioId?: SortOrder
    arrendadorId?: SortOrder
    estado?: SortOrder
    formulario?: SortOrder
    pdfPath?: SortOrder
    pdfHash?: SortOrder
    pdfVersion?: SortOrder
    firmado?: SortOrder
    firmadoEn?: SortOrder
    firmadoPorId?: SortOrder
    firmaHash?: SortOrder
    firmaIp?: SortOrder
    firmaUserAgent?: SortOrder
    cerradoEn?: SortOrder
    cerradoPorId?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    enviadoEn?: SortOrder
  }

  export type ProcesoAvgOrderByAggregateInput = {
    pdfVersion?: SortOrder
  }

  export type ProcesoMaxOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    beneficiarioId?: SortOrder
    arrendadorId?: SortOrder
    estado?: SortOrder
    pdfPath?: SortOrder
    pdfHash?: SortOrder
    pdfVersion?: SortOrder
    firmado?: SortOrder
    firmadoEn?: SortOrder
    firmadoPorId?: SortOrder
    firmaHash?: SortOrder
    firmaIp?: SortOrder
    firmaUserAgent?: SortOrder
    cerradoEn?: SortOrder
    cerradoPorId?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    enviadoEn?: SortOrder
  }

  export type ProcesoMinOrderByAggregateInput = {
    id?: SortOrder
    codigo?: SortOrder
    beneficiarioId?: SortOrder
    arrendadorId?: SortOrder
    estado?: SortOrder
    pdfPath?: SortOrder
    pdfHash?: SortOrder
    pdfVersion?: SortOrder
    firmado?: SortOrder
    firmadoEn?: SortOrder
    firmadoPorId?: SortOrder
    firmaHash?: SortOrder
    firmaIp?: SortOrder
    firmaUserAgent?: SortOrder
    cerradoEn?: SortOrder
    cerradoPorId?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
    enviadoEn?: SortOrder
  }

  export type ProcesoSumOrderByAggregateInput = {
    pdfVersion?: SortOrder
  }

  export type EnumEstadoProcesoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoProceso | EnumEstadoProcesoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoProceso[] | ListEnumEstadoProcesoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoProceso[] | ListEnumEstadoProcesoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoProcesoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoProceso
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoProcesoFilter<$PrismaModel>
    _max?: NestedEnumEstadoProcesoFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type EnumEstadoDocumentoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoDocumento | EnumEstadoDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoDocumento[] | ListEnumEstadoDocumentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoDocumento[] | ListEnumEstadoDocumentoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoDocumentoFilter<$PrismaModel> | $Enums.EstadoDocumento
  }

  export type ProcesoRelationFilter = {
    is?: ProcesoWhereInput
    isNot?: ProcesoWhereInput
  }

  export type CatalogoDocumentoRelationFilter = {
    is?: CatalogoDocumentoWhereInput
    isNot?: CatalogoDocumentoWhereInput
  }

  export type RegistroDescargaListRelationFilter = {
    every?: RegistroDescargaWhereInput
    some?: RegistroDescargaWhereInput
    none?: RegistroDescargaWhereInput
  }

  export type RegistroDescargaOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DocumentoCountOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    catalogoId?: SortOrder
    nombreOriginal?: SortOrder
    nombreAlmacenado?: SortOrder
    rutaArchivo?: SortOrder
    mimeType?: SortOrder
    tamanoBytes?: SortOrder
    hashArchivo?: SortOrder
    estado?: SortOrder
    validadoPorId?: SortOrder
    validadoEn?: SortOrder
    motivoRechazo?: SortOrder
    version?: SortOrder
    esActivo?: SortOrder
    creadoEn?: SortOrder
    cargadoPorId?: SortOrder
  }

  export type DocumentoAvgOrderByAggregateInput = {
    tamanoBytes?: SortOrder
    version?: SortOrder
  }

  export type DocumentoMaxOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    catalogoId?: SortOrder
    nombreOriginal?: SortOrder
    nombreAlmacenado?: SortOrder
    rutaArchivo?: SortOrder
    mimeType?: SortOrder
    tamanoBytes?: SortOrder
    hashArchivo?: SortOrder
    estado?: SortOrder
    validadoPorId?: SortOrder
    validadoEn?: SortOrder
    motivoRechazo?: SortOrder
    version?: SortOrder
    esActivo?: SortOrder
    creadoEn?: SortOrder
    cargadoPorId?: SortOrder
  }

  export type DocumentoMinOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    catalogoId?: SortOrder
    nombreOriginal?: SortOrder
    nombreAlmacenado?: SortOrder
    rutaArchivo?: SortOrder
    mimeType?: SortOrder
    tamanoBytes?: SortOrder
    hashArchivo?: SortOrder
    estado?: SortOrder
    validadoPorId?: SortOrder
    validadoEn?: SortOrder
    motivoRechazo?: SortOrder
    version?: SortOrder
    esActivo?: SortOrder
    creadoEn?: SortOrder
    cargadoPorId?: SortOrder
  }

  export type DocumentoSumOrderByAggregateInput = {
    tamanoBytes?: SortOrder
    version?: SortOrder
  }

  export type EnumEstadoDocumentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoDocumento | EnumEstadoDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoDocumento[] | ListEnumEstadoDocumentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoDocumento[] | ListEnumEstadoDocumentoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoDocumentoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoDocumento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoDocumentoFilter<$PrismaModel>
    _max?: NestedEnumEstadoDocumentoFilter<$PrismaModel>
  }

  export type DocumentoRelationFilter = {
    is?: DocumentoWhereInput
    isNot?: DocumentoWhereInput
  }

  export type RegistroDescargaCountOrderByAggregateInput = {
    id?: SortOrder
    documentoId?: SortOrder
    usuarioId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    creadoEn?: SortOrder
  }

  export type RegistroDescargaMaxOrderByAggregateInput = {
    id?: SortOrder
    documentoId?: SortOrder
    usuarioId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    creadoEn?: SortOrder
  }

  export type RegistroDescargaMinOrderByAggregateInput = {
    id?: SortOrder
    documentoId?: SortOrder
    usuarioId?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    creadoEn?: SortOrder
  }

  export type HistorialPdfCountOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    version?: SortOrder
    pdfPath?: SortOrder
    pdfHash?: SortOrder
    creadoEn?: SortOrder
  }

  export type HistorialPdfAvgOrderByAggregateInput = {
    version?: SortOrder
  }

  export type HistorialPdfMaxOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    version?: SortOrder
    pdfPath?: SortOrder
    pdfHash?: SortOrder
    creadoEn?: SortOrder
  }

  export type HistorialPdfMinOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    version?: SortOrder
    pdfPath?: SortOrder
    pdfHash?: SortOrder
    creadoEn?: SortOrder
  }

  export type HistorialPdfSumOrderByAggregateInput = {
    version?: SortOrder
  }

  export type DecisionCountOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    estadoAnterior?: SortOrder
    estadoNuevo?: SortOrder
    aprobado?: SortOrder
    motivo?: SortOrder
    usuarioId?: SortOrder
    rol?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    creadoEn?: SortOrder
  }

  export type DecisionMaxOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    estadoAnterior?: SortOrder
    estadoNuevo?: SortOrder
    aprobado?: SortOrder
    motivo?: SortOrder
    usuarioId?: SortOrder
    rol?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    creadoEn?: SortOrder
  }

  export type DecisionMinOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    estadoAnterior?: SortOrder
    estadoNuevo?: SortOrder
    aprobado?: SortOrder
    motivo?: SortOrder
    usuarioId?: SortOrder
    rol?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    creadoEn?: SortOrder
  }

  export type EnumTipoEventoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEvento | EnumTipoEventoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEvento[] | ListEnumTipoEventoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoEvento[] | ListEnumTipoEventoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoEventoFilter<$PrismaModel> | $Enums.TipoEvento
  }

  export type ProcesoNullableRelationFilter = {
    is?: ProcesoWhereInput | null
    isNot?: ProcesoWhereInput | null
  }

  export type EventoAuditoriaCountOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    usuarioId?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
    detalles?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    creadoEn?: SortOrder
  }

  export type EventoAuditoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    usuarioId?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    creadoEn?: SortOrder
  }

  export type EventoAuditoriaMinOrderByAggregateInput = {
    id?: SortOrder
    procesoId?: SortOrder
    usuarioId?: SortOrder
    tipo?: SortOrder
    descripcion?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    creadoEn?: SortOrder
  }

  export type EnumTipoEventoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEvento | EnumTipoEventoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEvento[] | ListEnumTipoEventoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoEvento[] | ListEnumTipoEventoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoEventoWithAggregatesFilter<$PrismaModel> | $Enums.TipoEvento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoEventoFilter<$PrismaModel>
    _max?: NestedEnumTipoEventoFilter<$PrismaModel>
  }

  export type ConfiguracionCountOrderByAggregateInput = {
    id?: SortOrder
    clave?: SortOrder
    valor?: SortOrder
    descripcion?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type ConfiguracionMaxOrderByAggregateInput = {
    id?: SortOrder
    clave?: SortOrder
    valor?: SortOrder
    descripcion?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type ConfiguracionMinOrderByAggregateInput = {
    id?: SortOrder
    clave?: SortOrder
    valor?: SortOrder
    descripcion?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type ConvocatoriaCountOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    activa?: SortOrder
    formularioJson?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type ConvocatoriaMaxOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    activa?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type ConvocatoriaMinOrderByAggregateInput = {
    id?: SortOrder
    nombre?: SortOrder
    descripcion?: SortOrder
    fechaInicio?: SortOrder
    fechaFin?: SortOrder
    activa?: SortOrder
    creadoEn?: SortOrder
    actualizadoEn?: SortOrder
  }

  export type UsuarioCreateNestedOneWithoutUsuariosCreadosInput = {
    create?: XOR<UsuarioCreateWithoutUsuariosCreadosInput, UsuarioUncheckedCreateWithoutUsuariosCreadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutUsuariosCreadosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioCreateNestedManyWithoutCreadoPorInput = {
    create?: XOR<UsuarioCreateWithoutCreadoPorInput, UsuarioUncheckedCreateWithoutCreadoPorInput> | UsuarioCreateWithoutCreadoPorInput[] | UsuarioUncheckedCreateWithoutCreadoPorInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutCreadoPorInput | UsuarioCreateOrConnectWithoutCreadoPorInput[]
    createMany?: UsuarioCreateManyCreadoPorInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type PasswordHistorialCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<PasswordHistorialCreateWithoutUsuarioInput, PasswordHistorialUncheckedCreateWithoutUsuarioInput> | PasswordHistorialCreateWithoutUsuarioInput[] | PasswordHistorialUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PasswordHistorialCreateOrConnectWithoutUsuarioInput | PasswordHistorialCreateOrConnectWithoutUsuarioInput[]
    createMany?: PasswordHistorialCreateManyUsuarioInputEnvelope
    connect?: PasswordHistorialWhereUniqueInput | PasswordHistorialWhereUniqueInput[]
  }

  export type SesionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<SesionCreateWithoutUsuarioInput, SesionUncheckedCreateWithoutUsuarioInput> | SesionCreateWithoutUsuarioInput[] | SesionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: SesionCreateOrConnectWithoutUsuarioInput | SesionCreateOrConnectWithoutUsuarioInput[]
    createMany?: SesionCreateManyUsuarioInputEnvelope
    connect?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
  }

  export type ProcesoCreateNestedManyWithoutBeneficiarioInput = {
    create?: XOR<ProcesoCreateWithoutBeneficiarioInput, ProcesoUncheckedCreateWithoutBeneficiarioInput> | ProcesoCreateWithoutBeneficiarioInput[] | ProcesoUncheckedCreateWithoutBeneficiarioInput[]
    connectOrCreate?: ProcesoCreateOrConnectWithoutBeneficiarioInput | ProcesoCreateOrConnectWithoutBeneficiarioInput[]
    createMany?: ProcesoCreateManyBeneficiarioInputEnvelope
    connect?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
  }

  export type ProcesoCreateNestedManyWithoutArrendadorInput = {
    create?: XOR<ProcesoCreateWithoutArrendadorInput, ProcesoUncheckedCreateWithoutArrendadorInput> | ProcesoCreateWithoutArrendadorInput[] | ProcesoUncheckedCreateWithoutArrendadorInput[]
    connectOrCreate?: ProcesoCreateOrConnectWithoutArrendadorInput | ProcesoCreateOrConnectWithoutArrendadorInput[]
    createMany?: ProcesoCreateManyArrendadorInputEnvelope
    connect?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
  }

  export type DocumentoCreateNestedManyWithoutCargadoPorInput = {
    create?: XOR<DocumentoCreateWithoutCargadoPorInput, DocumentoUncheckedCreateWithoutCargadoPorInput> | DocumentoCreateWithoutCargadoPorInput[] | DocumentoUncheckedCreateWithoutCargadoPorInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutCargadoPorInput | DocumentoCreateOrConnectWithoutCargadoPorInput[]
    createMany?: DocumentoCreateManyCargadoPorInputEnvelope
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
  }

  export type DocumentoCreateNestedManyWithoutValidadoPorInput = {
    create?: XOR<DocumentoCreateWithoutValidadoPorInput, DocumentoUncheckedCreateWithoutValidadoPorInput> | DocumentoCreateWithoutValidadoPorInput[] | DocumentoUncheckedCreateWithoutValidadoPorInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutValidadoPorInput | DocumentoCreateOrConnectWithoutValidadoPorInput[]
    createMany?: DocumentoCreateManyValidadoPorInputEnvelope
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
  }

  export type EventoAuditoriaCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<EventoAuditoriaCreateWithoutUsuarioInput, EventoAuditoriaUncheckedCreateWithoutUsuarioInput> | EventoAuditoriaCreateWithoutUsuarioInput[] | EventoAuditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EventoAuditoriaCreateOrConnectWithoutUsuarioInput | EventoAuditoriaCreateOrConnectWithoutUsuarioInput[]
    createMany?: EventoAuditoriaCreateManyUsuarioInputEnvelope
    connect?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
  }

  export type DecisionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<DecisionCreateWithoutUsuarioInput, DecisionUncheckedCreateWithoutUsuarioInput> | DecisionCreateWithoutUsuarioInput[] | DecisionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: DecisionCreateOrConnectWithoutUsuarioInput | DecisionCreateOrConnectWithoutUsuarioInput[]
    createMany?: DecisionCreateManyUsuarioInputEnvelope
    connect?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
  }

  export type TokenRecuperacionCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<TokenRecuperacionCreateWithoutUsuarioInput, TokenRecuperacionUncheckedCreateWithoutUsuarioInput> | TokenRecuperacionCreateWithoutUsuarioInput[] | TokenRecuperacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TokenRecuperacionCreateOrConnectWithoutUsuarioInput | TokenRecuperacionCreateOrConnectWithoutUsuarioInput[]
    createMany?: TokenRecuperacionCreateManyUsuarioInputEnvelope
    connect?: TokenRecuperacionWhereUniqueInput | TokenRecuperacionWhereUniqueInput[]
  }

  export type CambioRolCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<CambioRolCreateWithoutUsuarioInput, CambioRolUncheckedCreateWithoutUsuarioInput> | CambioRolCreateWithoutUsuarioInput[] | CambioRolUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CambioRolCreateOrConnectWithoutUsuarioInput | CambioRolCreateOrConnectWithoutUsuarioInput[]
    createMany?: CambioRolCreateManyUsuarioInputEnvelope
    connect?: CambioRolWhereUniqueInput | CambioRolWhereUniqueInput[]
  }

  export type UsuarioUncheckedCreateNestedManyWithoutCreadoPorInput = {
    create?: XOR<UsuarioCreateWithoutCreadoPorInput, UsuarioUncheckedCreateWithoutCreadoPorInput> | UsuarioCreateWithoutCreadoPorInput[] | UsuarioUncheckedCreateWithoutCreadoPorInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutCreadoPorInput | UsuarioCreateOrConnectWithoutCreadoPorInput[]
    createMany?: UsuarioCreateManyCreadoPorInputEnvelope
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
  }

  export type PasswordHistorialUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<PasswordHistorialCreateWithoutUsuarioInput, PasswordHistorialUncheckedCreateWithoutUsuarioInput> | PasswordHistorialCreateWithoutUsuarioInput[] | PasswordHistorialUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PasswordHistorialCreateOrConnectWithoutUsuarioInput | PasswordHistorialCreateOrConnectWithoutUsuarioInput[]
    createMany?: PasswordHistorialCreateManyUsuarioInputEnvelope
    connect?: PasswordHistorialWhereUniqueInput | PasswordHistorialWhereUniqueInput[]
  }

  export type SesionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<SesionCreateWithoutUsuarioInput, SesionUncheckedCreateWithoutUsuarioInput> | SesionCreateWithoutUsuarioInput[] | SesionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: SesionCreateOrConnectWithoutUsuarioInput | SesionCreateOrConnectWithoutUsuarioInput[]
    createMany?: SesionCreateManyUsuarioInputEnvelope
    connect?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
  }

  export type ProcesoUncheckedCreateNestedManyWithoutBeneficiarioInput = {
    create?: XOR<ProcesoCreateWithoutBeneficiarioInput, ProcesoUncheckedCreateWithoutBeneficiarioInput> | ProcesoCreateWithoutBeneficiarioInput[] | ProcesoUncheckedCreateWithoutBeneficiarioInput[]
    connectOrCreate?: ProcesoCreateOrConnectWithoutBeneficiarioInput | ProcesoCreateOrConnectWithoutBeneficiarioInput[]
    createMany?: ProcesoCreateManyBeneficiarioInputEnvelope
    connect?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
  }

  export type ProcesoUncheckedCreateNestedManyWithoutArrendadorInput = {
    create?: XOR<ProcesoCreateWithoutArrendadorInput, ProcesoUncheckedCreateWithoutArrendadorInput> | ProcesoCreateWithoutArrendadorInput[] | ProcesoUncheckedCreateWithoutArrendadorInput[]
    connectOrCreate?: ProcesoCreateOrConnectWithoutArrendadorInput | ProcesoCreateOrConnectWithoutArrendadorInput[]
    createMany?: ProcesoCreateManyArrendadorInputEnvelope
    connect?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
  }

  export type DocumentoUncheckedCreateNestedManyWithoutCargadoPorInput = {
    create?: XOR<DocumentoCreateWithoutCargadoPorInput, DocumentoUncheckedCreateWithoutCargadoPorInput> | DocumentoCreateWithoutCargadoPorInput[] | DocumentoUncheckedCreateWithoutCargadoPorInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutCargadoPorInput | DocumentoCreateOrConnectWithoutCargadoPorInput[]
    createMany?: DocumentoCreateManyCargadoPorInputEnvelope
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
  }

  export type DocumentoUncheckedCreateNestedManyWithoutValidadoPorInput = {
    create?: XOR<DocumentoCreateWithoutValidadoPorInput, DocumentoUncheckedCreateWithoutValidadoPorInput> | DocumentoCreateWithoutValidadoPorInput[] | DocumentoUncheckedCreateWithoutValidadoPorInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutValidadoPorInput | DocumentoCreateOrConnectWithoutValidadoPorInput[]
    createMany?: DocumentoCreateManyValidadoPorInputEnvelope
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
  }

  export type EventoAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<EventoAuditoriaCreateWithoutUsuarioInput, EventoAuditoriaUncheckedCreateWithoutUsuarioInput> | EventoAuditoriaCreateWithoutUsuarioInput[] | EventoAuditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EventoAuditoriaCreateOrConnectWithoutUsuarioInput | EventoAuditoriaCreateOrConnectWithoutUsuarioInput[]
    createMany?: EventoAuditoriaCreateManyUsuarioInputEnvelope
    connect?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
  }

  export type DecisionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<DecisionCreateWithoutUsuarioInput, DecisionUncheckedCreateWithoutUsuarioInput> | DecisionCreateWithoutUsuarioInput[] | DecisionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: DecisionCreateOrConnectWithoutUsuarioInput | DecisionCreateOrConnectWithoutUsuarioInput[]
    createMany?: DecisionCreateManyUsuarioInputEnvelope
    connect?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
  }

  export type TokenRecuperacionUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<TokenRecuperacionCreateWithoutUsuarioInput, TokenRecuperacionUncheckedCreateWithoutUsuarioInput> | TokenRecuperacionCreateWithoutUsuarioInput[] | TokenRecuperacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TokenRecuperacionCreateOrConnectWithoutUsuarioInput | TokenRecuperacionCreateOrConnectWithoutUsuarioInput[]
    createMany?: TokenRecuperacionCreateManyUsuarioInputEnvelope
    connect?: TokenRecuperacionWhereUniqueInput | TokenRecuperacionWhereUniqueInput[]
  }

  export type CambioRolUncheckedCreateNestedManyWithoutUsuarioInput = {
    create?: XOR<CambioRolCreateWithoutUsuarioInput, CambioRolUncheckedCreateWithoutUsuarioInput> | CambioRolCreateWithoutUsuarioInput[] | CambioRolUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CambioRolCreateOrConnectWithoutUsuarioInput | CambioRolCreateOrConnectWithoutUsuarioInput[]
    createMany?: CambioRolCreateManyUsuarioInputEnvelope
    connect?: CambioRolWhereUniqueInput | CambioRolWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumRolFieldUpdateOperationsInput = {
    set?: $Enums.Rol
  }

  export type EnumEstadoUsuarioFieldUpdateOperationsInput = {
    set?: $Enums.EstadoUsuario
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type UsuarioUpdateOneWithoutUsuariosCreadosNestedInput = {
    create?: XOR<UsuarioCreateWithoutUsuariosCreadosInput, UsuarioUncheckedCreateWithoutUsuariosCreadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutUsuariosCreadosInput
    upsert?: UsuarioUpsertWithoutUsuariosCreadosInput
    disconnect?: UsuarioWhereInput | boolean
    delete?: UsuarioWhereInput | boolean
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutUsuariosCreadosInput, UsuarioUpdateWithoutUsuariosCreadosInput>, UsuarioUncheckedUpdateWithoutUsuariosCreadosInput>
  }

  export type UsuarioUpdateManyWithoutCreadoPorNestedInput = {
    create?: XOR<UsuarioCreateWithoutCreadoPorInput, UsuarioUncheckedCreateWithoutCreadoPorInput> | UsuarioCreateWithoutCreadoPorInput[] | UsuarioUncheckedCreateWithoutCreadoPorInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutCreadoPorInput | UsuarioCreateOrConnectWithoutCreadoPorInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutCreadoPorInput | UsuarioUpsertWithWhereUniqueWithoutCreadoPorInput[]
    createMany?: UsuarioCreateManyCreadoPorInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutCreadoPorInput | UsuarioUpdateWithWhereUniqueWithoutCreadoPorInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutCreadoPorInput | UsuarioUpdateManyWithWhereWithoutCreadoPorInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type PasswordHistorialUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<PasswordHistorialCreateWithoutUsuarioInput, PasswordHistorialUncheckedCreateWithoutUsuarioInput> | PasswordHistorialCreateWithoutUsuarioInput[] | PasswordHistorialUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PasswordHistorialCreateOrConnectWithoutUsuarioInput | PasswordHistorialCreateOrConnectWithoutUsuarioInput[]
    upsert?: PasswordHistorialUpsertWithWhereUniqueWithoutUsuarioInput | PasswordHistorialUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: PasswordHistorialCreateManyUsuarioInputEnvelope
    set?: PasswordHistorialWhereUniqueInput | PasswordHistorialWhereUniqueInput[]
    disconnect?: PasswordHistorialWhereUniqueInput | PasswordHistorialWhereUniqueInput[]
    delete?: PasswordHistorialWhereUniqueInput | PasswordHistorialWhereUniqueInput[]
    connect?: PasswordHistorialWhereUniqueInput | PasswordHistorialWhereUniqueInput[]
    update?: PasswordHistorialUpdateWithWhereUniqueWithoutUsuarioInput | PasswordHistorialUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: PasswordHistorialUpdateManyWithWhereWithoutUsuarioInput | PasswordHistorialUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: PasswordHistorialScalarWhereInput | PasswordHistorialScalarWhereInput[]
  }

  export type SesionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<SesionCreateWithoutUsuarioInput, SesionUncheckedCreateWithoutUsuarioInput> | SesionCreateWithoutUsuarioInput[] | SesionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: SesionCreateOrConnectWithoutUsuarioInput | SesionCreateOrConnectWithoutUsuarioInput[]
    upsert?: SesionUpsertWithWhereUniqueWithoutUsuarioInput | SesionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: SesionCreateManyUsuarioInputEnvelope
    set?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
    disconnect?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
    delete?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
    connect?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
    update?: SesionUpdateWithWhereUniqueWithoutUsuarioInput | SesionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: SesionUpdateManyWithWhereWithoutUsuarioInput | SesionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: SesionScalarWhereInput | SesionScalarWhereInput[]
  }

  export type ProcesoUpdateManyWithoutBeneficiarioNestedInput = {
    create?: XOR<ProcesoCreateWithoutBeneficiarioInput, ProcesoUncheckedCreateWithoutBeneficiarioInput> | ProcesoCreateWithoutBeneficiarioInput[] | ProcesoUncheckedCreateWithoutBeneficiarioInput[]
    connectOrCreate?: ProcesoCreateOrConnectWithoutBeneficiarioInput | ProcesoCreateOrConnectWithoutBeneficiarioInput[]
    upsert?: ProcesoUpsertWithWhereUniqueWithoutBeneficiarioInput | ProcesoUpsertWithWhereUniqueWithoutBeneficiarioInput[]
    createMany?: ProcesoCreateManyBeneficiarioInputEnvelope
    set?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
    disconnect?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
    delete?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
    connect?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
    update?: ProcesoUpdateWithWhereUniqueWithoutBeneficiarioInput | ProcesoUpdateWithWhereUniqueWithoutBeneficiarioInput[]
    updateMany?: ProcesoUpdateManyWithWhereWithoutBeneficiarioInput | ProcesoUpdateManyWithWhereWithoutBeneficiarioInput[]
    deleteMany?: ProcesoScalarWhereInput | ProcesoScalarWhereInput[]
  }

  export type ProcesoUpdateManyWithoutArrendadorNestedInput = {
    create?: XOR<ProcesoCreateWithoutArrendadorInput, ProcesoUncheckedCreateWithoutArrendadorInput> | ProcesoCreateWithoutArrendadorInput[] | ProcesoUncheckedCreateWithoutArrendadorInput[]
    connectOrCreate?: ProcesoCreateOrConnectWithoutArrendadorInput | ProcesoCreateOrConnectWithoutArrendadorInput[]
    upsert?: ProcesoUpsertWithWhereUniqueWithoutArrendadorInput | ProcesoUpsertWithWhereUniqueWithoutArrendadorInput[]
    createMany?: ProcesoCreateManyArrendadorInputEnvelope
    set?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
    disconnect?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
    delete?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
    connect?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
    update?: ProcesoUpdateWithWhereUniqueWithoutArrendadorInput | ProcesoUpdateWithWhereUniqueWithoutArrendadorInput[]
    updateMany?: ProcesoUpdateManyWithWhereWithoutArrendadorInput | ProcesoUpdateManyWithWhereWithoutArrendadorInput[]
    deleteMany?: ProcesoScalarWhereInput | ProcesoScalarWhereInput[]
  }

  export type DocumentoUpdateManyWithoutCargadoPorNestedInput = {
    create?: XOR<DocumentoCreateWithoutCargadoPorInput, DocumentoUncheckedCreateWithoutCargadoPorInput> | DocumentoCreateWithoutCargadoPorInput[] | DocumentoUncheckedCreateWithoutCargadoPorInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutCargadoPorInput | DocumentoCreateOrConnectWithoutCargadoPorInput[]
    upsert?: DocumentoUpsertWithWhereUniqueWithoutCargadoPorInput | DocumentoUpsertWithWhereUniqueWithoutCargadoPorInput[]
    createMany?: DocumentoCreateManyCargadoPorInputEnvelope
    set?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    disconnect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    delete?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    update?: DocumentoUpdateWithWhereUniqueWithoutCargadoPorInput | DocumentoUpdateWithWhereUniqueWithoutCargadoPorInput[]
    updateMany?: DocumentoUpdateManyWithWhereWithoutCargadoPorInput | DocumentoUpdateManyWithWhereWithoutCargadoPorInput[]
    deleteMany?: DocumentoScalarWhereInput | DocumentoScalarWhereInput[]
  }

  export type DocumentoUpdateManyWithoutValidadoPorNestedInput = {
    create?: XOR<DocumentoCreateWithoutValidadoPorInput, DocumentoUncheckedCreateWithoutValidadoPorInput> | DocumentoCreateWithoutValidadoPorInput[] | DocumentoUncheckedCreateWithoutValidadoPorInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutValidadoPorInput | DocumentoCreateOrConnectWithoutValidadoPorInput[]
    upsert?: DocumentoUpsertWithWhereUniqueWithoutValidadoPorInput | DocumentoUpsertWithWhereUniqueWithoutValidadoPorInput[]
    createMany?: DocumentoCreateManyValidadoPorInputEnvelope
    set?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    disconnect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    delete?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    update?: DocumentoUpdateWithWhereUniqueWithoutValidadoPorInput | DocumentoUpdateWithWhereUniqueWithoutValidadoPorInput[]
    updateMany?: DocumentoUpdateManyWithWhereWithoutValidadoPorInput | DocumentoUpdateManyWithWhereWithoutValidadoPorInput[]
    deleteMany?: DocumentoScalarWhereInput | DocumentoScalarWhereInput[]
  }

  export type EventoAuditoriaUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<EventoAuditoriaCreateWithoutUsuarioInput, EventoAuditoriaUncheckedCreateWithoutUsuarioInput> | EventoAuditoriaCreateWithoutUsuarioInput[] | EventoAuditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EventoAuditoriaCreateOrConnectWithoutUsuarioInput | EventoAuditoriaCreateOrConnectWithoutUsuarioInput[]
    upsert?: EventoAuditoriaUpsertWithWhereUniqueWithoutUsuarioInput | EventoAuditoriaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: EventoAuditoriaCreateManyUsuarioInputEnvelope
    set?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
    disconnect?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
    delete?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
    connect?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
    update?: EventoAuditoriaUpdateWithWhereUniqueWithoutUsuarioInput | EventoAuditoriaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: EventoAuditoriaUpdateManyWithWhereWithoutUsuarioInput | EventoAuditoriaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: EventoAuditoriaScalarWhereInput | EventoAuditoriaScalarWhereInput[]
  }

  export type DecisionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<DecisionCreateWithoutUsuarioInput, DecisionUncheckedCreateWithoutUsuarioInput> | DecisionCreateWithoutUsuarioInput[] | DecisionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: DecisionCreateOrConnectWithoutUsuarioInput | DecisionCreateOrConnectWithoutUsuarioInput[]
    upsert?: DecisionUpsertWithWhereUniqueWithoutUsuarioInput | DecisionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: DecisionCreateManyUsuarioInputEnvelope
    set?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
    disconnect?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
    delete?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
    connect?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
    update?: DecisionUpdateWithWhereUniqueWithoutUsuarioInput | DecisionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: DecisionUpdateManyWithWhereWithoutUsuarioInput | DecisionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: DecisionScalarWhereInput | DecisionScalarWhereInput[]
  }

  export type TokenRecuperacionUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<TokenRecuperacionCreateWithoutUsuarioInput, TokenRecuperacionUncheckedCreateWithoutUsuarioInput> | TokenRecuperacionCreateWithoutUsuarioInput[] | TokenRecuperacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TokenRecuperacionCreateOrConnectWithoutUsuarioInput | TokenRecuperacionCreateOrConnectWithoutUsuarioInput[]
    upsert?: TokenRecuperacionUpsertWithWhereUniqueWithoutUsuarioInput | TokenRecuperacionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: TokenRecuperacionCreateManyUsuarioInputEnvelope
    set?: TokenRecuperacionWhereUniqueInput | TokenRecuperacionWhereUniqueInput[]
    disconnect?: TokenRecuperacionWhereUniqueInput | TokenRecuperacionWhereUniqueInput[]
    delete?: TokenRecuperacionWhereUniqueInput | TokenRecuperacionWhereUniqueInput[]
    connect?: TokenRecuperacionWhereUniqueInput | TokenRecuperacionWhereUniqueInput[]
    update?: TokenRecuperacionUpdateWithWhereUniqueWithoutUsuarioInput | TokenRecuperacionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: TokenRecuperacionUpdateManyWithWhereWithoutUsuarioInput | TokenRecuperacionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: TokenRecuperacionScalarWhereInput | TokenRecuperacionScalarWhereInput[]
  }

  export type CambioRolUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<CambioRolCreateWithoutUsuarioInput, CambioRolUncheckedCreateWithoutUsuarioInput> | CambioRolCreateWithoutUsuarioInput[] | CambioRolUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CambioRolCreateOrConnectWithoutUsuarioInput | CambioRolCreateOrConnectWithoutUsuarioInput[]
    upsert?: CambioRolUpsertWithWhereUniqueWithoutUsuarioInput | CambioRolUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: CambioRolCreateManyUsuarioInputEnvelope
    set?: CambioRolWhereUniqueInput | CambioRolWhereUniqueInput[]
    disconnect?: CambioRolWhereUniqueInput | CambioRolWhereUniqueInput[]
    delete?: CambioRolWhereUniqueInput | CambioRolWhereUniqueInput[]
    connect?: CambioRolWhereUniqueInput | CambioRolWhereUniqueInput[]
    update?: CambioRolUpdateWithWhereUniqueWithoutUsuarioInput | CambioRolUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: CambioRolUpdateManyWithWhereWithoutUsuarioInput | CambioRolUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: CambioRolScalarWhereInput | CambioRolScalarWhereInput[]
  }

  export type UsuarioUncheckedUpdateManyWithoutCreadoPorNestedInput = {
    create?: XOR<UsuarioCreateWithoutCreadoPorInput, UsuarioUncheckedCreateWithoutCreadoPorInput> | UsuarioCreateWithoutCreadoPorInput[] | UsuarioUncheckedCreateWithoutCreadoPorInput[]
    connectOrCreate?: UsuarioCreateOrConnectWithoutCreadoPorInput | UsuarioCreateOrConnectWithoutCreadoPorInput[]
    upsert?: UsuarioUpsertWithWhereUniqueWithoutCreadoPorInput | UsuarioUpsertWithWhereUniqueWithoutCreadoPorInput[]
    createMany?: UsuarioCreateManyCreadoPorInputEnvelope
    set?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    disconnect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    delete?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    connect?: UsuarioWhereUniqueInput | UsuarioWhereUniqueInput[]
    update?: UsuarioUpdateWithWhereUniqueWithoutCreadoPorInput | UsuarioUpdateWithWhereUniqueWithoutCreadoPorInput[]
    updateMany?: UsuarioUpdateManyWithWhereWithoutCreadoPorInput | UsuarioUpdateManyWithWhereWithoutCreadoPorInput[]
    deleteMany?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
  }

  export type PasswordHistorialUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<PasswordHistorialCreateWithoutUsuarioInput, PasswordHistorialUncheckedCreateWithoutUsuarioInput> | PasswordHistorialCreateWithoutUsuarioInput[] | PasswordHistorialUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: PasswordHistorialCreateOrConnectWithoutUsuarioInput | PasswordHistorialCreateOrConnectWithoutUsuarioInput[]
    upsert?: PasswordHistorialUpsertWithWhereUniqueWithoutUsuarioInput | PasswordHistorialUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: PasswordHistorialCreateManyUsuarioInputEnvelope
    set?: PasswordHistorialWhereUniqueInput | PasswordHistorialWhereUniqueInput[]
    disconnect?: PasswordHistorialWhereUniqueInput | PasswordHistorialWhereUniqueInput[]
    delete?: PasswordHistorialWhereUniqueInput | PasswordHistorialWhereUniqueInput[]
    connect?: PasswordHistorialWhereUniqueInput | PasswordHistorialWhereUniqueInput[]
    update?: PasswordHistorialUpdateWithWhereUniqueWithoutUsuarioInput | PasswordHistorialUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: PasswordHistorialUpdateManyWithWhereWithoutUsuarioInput | PasswordHistorialUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: PasswordHistorialScalarWhereInput | PasswordHistorialScalarWhereInput[]
  }

  export type SesionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<SesionCreateWithoutUsuarioInput, SesionUncheckedCreateWithoutUsuarioInput> | SesionCreateWithoutUsuarioInput[] | SesionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: SesionCreateOrConnectWithoutUsuarioInput | SesionCreateOrConnectWithoutUsuarioInput[]
    upsert?: SesionUpsertWithWhereUniqueWithoutUsuarioInput | SesionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: SesionCreateManyUsuarioInputEnvelope
    set?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
    disconnect?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
    delete?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
    connect?: SesionWhereUniqueInput | SesionWhereUniqueInput[]
    update?: SesionUpdateWithWhereUniqueWithoutUsuarioInput | SesionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: SesionUpdateManyWithWhereWithoutUsuarioInput | SesionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: SesionScalarWhereInput | SesionScalarWhereInput[]
  }

  export type ProcesoUncheckedUpdateManyWithoutBeneficiarioNestedInput = {
    create?: XOR<ProcesoCreateWithoutBeneficiarioInput, ProcesoUncheckedCreateWithoutBeneficiarioInput> | ProcesoCreateWithoutBeneficiarioInput[] | ProcesoUncheckedCreateWithoutBeneficiarioInput[]
    connectOrCreate?: ProcesoCreateOrConnectWithoutBeneficiarioInput | ProcesoCreateOrConnectWithoutBeneficiarioInput[]
    upsert?: ProcesoUpsertWithWhereUniqueWithoutBeneficiarioInput | ProcesoUpsertWithWhereUniqueWithoutBeneficiarioInput[]
    createMany?: ProcesoCreateManyBeneficiarioInputEnvelope
    set?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
    disconnect?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
    delete?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
    connect?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
    update?: ProcesoUpdateWithWhereUniqueWithoutBeneficiarioInput | ProcesoUpdateWithWhereUniqueWithoutBeneficiarioInput[]
    updateMany?: ProcesoUpdateManyWithWhereWithoutBeneficiarioInput | ProcesoUpdateManyWithWhereWithoutBeneficiarioInput[]
    deleteMany?: ProcesoScalarWhereInput | ProcesoScalarWhereInput[]
  }

  export type ProcesoUncheckedUpdateManyWithoutArrendadorNestedInput = {
    create?: XOR<ProcesoCreateWithoutArrendadorInput, ProcesoUncheckedCreateWithoutArrendadorInput> | ProcesoCreateWithoutArrendadorInput[] | ProcesoUncheckedCreateWithoutArrendadorInput[]
    connectOrCreate?: ProcesoCreateOrConnectWithoutArrendadorInput | ProcesoCreateOrConnectWithoutArrendadorInput[]
    upsert?: ProcesoUpsertWithWhereUniqueWithoutArrendadorInput | ProcesoUpsertWithWhereUniqueWithoutArrendadorInput[]
    createMany?: ProcesoCreateManyArrendadorInputEnvelope
    set?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
    disconnect?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
    delete?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
    connect?: ProcesoWhereUniqueInput | ProcesoWhereUniqueInput[]
    update?: ProcesoUpdateWithWhereUniqueWithoutArrendadorInput | ProcesoUpdateWithWhereUniqueWithoutArrendadorInput[]
    updateMany?: ProcesoUpdateManyWithWhereWithoutArrendadorInput | ProcesoUpdateManyWithWhereWithoutArrendadorInput[]
    deleteMany?: ProcesoScalarWhereInput | ProcesoScalarWhereInput[]
  }

  export type DocumentoUncheckedUpdateManyWithoutCargadoPorNestedInput = {
    create?: XOR<DocumentoCreateWithoutCargadoPorInput, DocumentoUncheckedCreateWithoutCargadoPorInput> | DocumentoCreateWithoutCargadoPorInput[] | DocumentoUncheckedCreateWithoutCargadoPorInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutCargadoPorInput | DocumentoCreateOrConnectWithoutCargadoPorInput[]
    upsert?: DocumentoUpsertWithWhereUniqueWithoutCargadoPorInput | DocumentoUpsertWithWhereUniqueWithoutCargadoPorInput[]
    createMany?: DocumentoCreateManyCargadoPorInputEnvelope
    set?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    disconnect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    delete?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    update?: DocumentoUpdateWithWhereUniqueWithoutCargadoPorInput | DocumentoUpdateWithWhereUniqueWithoutCargadoPorInput[]
    updateMany?: DocumentoUpdateManyWithWhereWithoutCargadoPorInput | DocumentoUpdateManyWithWhereWithoutCargadoPorInput[]
    deleteMany?: DocumentoScalarWhereInput | DocumentoScalarWhereInput[]
  }

  export type DocumentoUncheckedUpdateManyWithoutValidadoPorNestedInput = {
    create?: XOR<DocumentoCreateWithoutValidadoPorInput, DocumentoUncheckedCreateWithoutValidadoPorInput> | DocumentoCreateWithoutValidadoPorInput[] | DocumentoUncheckedCreateWithoutValidadoPorInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutValidadoPorInput | DocumentoCreateOrConnectWithoutValidadoPorInput[]
    upsert?: DocumentoUpsertWithWhereUniqueWithoutValidadoPorInput | DocumentoUpsertWithWhereUniqueWithoutValidadoPorInput[]
    createMany?: DocumentoCreateManyValidadoPorInputEnvelope
    set?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    disconnect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    delete?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    update?: DocumentoUpdateWithWhereUniqueWithoutValidadoPorInput | DocumentoUpdateWithWhereUniqueWithoutValidadoPorInput[]
    updateMany?: DocumentoUpdateManyWithWhereWithoutValidadoPorInput | DocumentoUpdateManyWithWhereWithoutValidadoPorInput[]
    deleteMany?: DocumentoScalarWhereInput | DocumentoScalarWhereInput[]
  }

  export type EventoAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<EventoAuditoriaCreateWithoutUsuarioInput, EventoAuditoriaUncheckedCreateWithoutUsuarioInput> | EventoAuditoriaCreateWithoutUsuarioInput[] | EventoAuditoriaUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: EventoAuditoriaCreateOrConnectWithoutUsuarioInput | EventoAuditoriaCreateOrConnectWithoutUsuarioInput[]
    upsert?: EventoAuditoriaUpsertWithWhereUniqueWithoutUsuarioInput | EventoAuditoriaUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: EventoAuditoriaCreateManyUsuarioInputEnvelope
    set?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
    disconnect?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
    delete?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
    connect?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
    update?: EventoAuditoriaUpdateWithWhereUniqueWithoutUsuarioInput | EventoAuditoriaUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: EventoAuditoriaUpdateManyWithWhereWithoutUsuarioInput | EventoAuditoriaUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: EventoAuditoriaScalarWhereInput | EventoAuditoriaScalarWhereInput[]
  }

  export type DecisionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<DecisionCreateWithoutUsuarioInput, DecisionUncheckedCreateWithoutUsuarioInput> | DecisionCreateWithoutUsuarioInput[] | DecisionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: DecisionCreateOrConnectWithoutUsuarioInput | DecisionCreateOrConnectWithoutUsuarioInput[]
    upsert?: DecisionUpsertWithWhereUniqueWithoutUsuarioInput | DecisionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: DecisionCreateManyUsuarioInputEnvelope
    set?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
    disconnect?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
    delete?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
    connect?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
    update?: DecisionUpdateWithWhereUniqueWithoutUsuarioInput | DecisionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: DecisionUpdateManyWithWhereWithoutUsuarioInput | DecisionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: DecisionScalarWhereInput | DecisionScalarWhereInput[]
  }

  export type TokenRecuperacionUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<TokenRecuperacionCreateWithoutUsuarioInput, TokenRecuperacionUncheckedCreateWithoutUsuarioInput> | TokenRecuperacionCreateWithoutUsuarioInput[] | TokenRecuperacionUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: TokenRecuperacionCreateOrConnectWithoutUsuarioInput | TokenRecuperacionCreateOrConnectWithoutUsuarioInput[]
    upsert?: TokenRecuperacionUpsertWithWhereUniqueWithoutUsuarioInput | TokenRecuperacionUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: TokenRecuperacionCreateManyUsuarioInputEnvelope
    set?: TokenRecuperacionWhereUniqueInput | TokenRecuperacionWhereUniqueInput[]
    disconnect?: TokenRecuperacionWhereUniqueInput | TokenRecuperacionWhereUniqueInput[]
    delete?: TokenRecuperacionWhereUniqueInput | TokenRecuperacionWhereUniqueInput[]
    connect?: TokenRecuperacionWhereUniqueInput | TokenRecuperacionWhereUniqueInput[]
    update?: TokenRecuperacionUpdateWithWhereUniqueWithoutUsuarioInput | TokenRecuperacionUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: TokenRecuperacionUpdateManyWithWhereWithoutUsuarioInput | TokenRecuperacionUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: TokenRecuperacionScalarWhereInput | TokenRecuperacionScalarWhereInput[]
  }

  export type CambioRolUncheckedUpdateManyWithoutUsuarioNestedInput = {
    create?: XOR<CambioRolCreateWithoutUsuarioInput, CambioRolUncheckedCreateWithoutUsuarioInput> | CambioRolCreateWithoutUsuarioInput[] | CambioRolUncheckedCreateWithoutUsuarioInput[]
    connectOrCreate?: CambioRolCreateOrConnectWithoutUsuarioInput | CambioRolCreateOrConnectWithoutUsuarioInput[]
    upsert?: CambioRolUpsertWithWhereUniqueWithoutUsuarioInput | CambioRolUpsertWithWhereUniqueWithoutUsuarioInput[]
    createMany?: CambioRolCreateManyUsuarioInputEnvelope
    set?: CambioRolWhereUniqueInput | CambioRolWhereUniqueInput[]
    disconnect?: CambioRolWhereUniqueInput | CambioRolWhereUniqueInput[]
    delete?: CambioRolWhereUniqueInput | CambioRolWhereUniqueInput[]
    connect?: CambioRolWhereUniqueInput | CambioRolWhereUniqueInput[]
    update?: CambioRolUpdateWithWhereUniqueWithoutUsuarioInput | CambioRolUpdateWithWhereUniqueWithoutUsuarioInput[]
    updateMany?: CambioRolUpdateManyWithWhereWithoutUsuarioInput | CambioRolUpdateManyWithWhereWithoutUsuarioInput[]
    deleteMany?: CambioRolScalarWhereInput | CambioRolScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutPasswordHistorialInput = {
    create?: XOR<UsuarioCreateWithoutPasswordHistorialInput, UsuarioUncheckedCreateWithoutPasswordHistorialInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPasswordHistorialInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutPasswordHistorialNestedInput = {
    create?: XOR<UsuarioCreateWithoutPasswordHistorialInput, UsuarioUncheckedCreateWithoutPasswordHistorialInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutPasswordHistorialInput
    upsert?: UsuarioUpsertWithoutPasswordHistorialInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutPasswordHistorialInput, UsuarioUpdateWithoutPasswordHistorialInput>, UsuarioUncheckedUpdateWithoutPasswordHistorialInput>
  }

  export type UsuarioCreateNestedOneWithoutTokenRecuperacionInput = {
    create?: XOR<UsuarioCreateWithoutTokenRecuperacionInput, UsuarioUncheckedCreateWithoutTokenRecuperacionInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutTokenRecuperacionInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutTokenRecuperacionNestedInput = {
    create?: XOR<UsuarioCreateWithoutTokenRecuperacionInput, UsuarioUncheckedCreateWithoutTokenRecuperacionInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutTokenRecuperacionInput
    upsert?: UsuarioUpsertWithoutTokenRecuperacionInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutTokenRecuperacionInput, UsuarioUpdateWithoutTokenRecuperacionInput>, UsuarioUncheckedUpdateWithoutTokenRecuperacionInput>
  }

  export type UsuarioCreateNestedOneWithoutSesionesInput = {
    create?: XOR<UsuarioCreateWithoutSesionesInput, UsuarioUncheckedCreateWithoutSesionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutSesionesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutSesionesNestedInput = {
    create?: XOR<UsuarioCreateWithoutSesionesInput, UsuarioUncheckedCreateWithoutSesionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutSesionesInput
    upsert?: UsuarioUpsertWithoutSesionesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutSesionesInput, UsuarioUpdateWithoutSesionesInput>, UsuarioUncheckedUpdateWithoutSesionesInput>
  }

  export type UsuarioCreateNestedOneWithoutCambiosRolInput = {
    create?: XOR<UsuarioCreateWithoutCambiosRolInput, UsuarioUncheckedCreateWithoutCambiosRolInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutCambiosRolInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioUpdateOneRequiredWithoutCambiosRolNestedInput = {
    create?: XOR<UsuarioCreateWithoutCambiosRolInput, UsuarioUncheckedCreateWithoutCambiosRolInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutCambiosRolInput
    upsert?: UsuarioUpsertWithoutCambiosRolInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutCambiosRolInput, UsuarioUpdateWithoutCambiosRolInput>, UsuarioUncheckedUpdateWithoutCambiosRolInput>
  }

  export type CatalogoDocumentoCreateformatosPermitidosInput = {
    set: string[]
  }

  export type DocumentoCreateNestedManyWithoutCatalogoInput = {
    create?: XOR<DocumentoCreateWithoutCatalogoInput, DocumentoUncheckedCreateWithoutCatalogoInput> | DocumentoCreateWithoutCatalogoInput[] | DocumentoUncheckedCreateWithoutCatalogoInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutCatalogoInput | DocumentoCreateOrConnectWithoutCatalogoInput[]
    createMany?: DocumentoCreateManyCatalogoInputEnvelope
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
  }

  export type DocumentoUncheckedCreateNestedManyWithoutCatalogoInput = {
    create?: XOR<DocumentoCreateWithoutCatalogoInput, DocumentoUncheckedCreateWithoutCatalogoInput> | DocumentoCreateWithoutCatalogoInput[] | DocumentoUncheckedCreateWithoutCatalogoInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutCatalogoInput | DocumentoCreateOrConnectWithoutCatalogoInput[]
    createMany?: DocumentoCreateManyCatalogoInputEnvelope
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
  }

  export type EnumTipoDocumentoFieldUpdateOperationsInput = {
    set?: $Enums.TipoDocumento
  }

  export type CatalogoDocumentoUpdateformatosPermitidosInput = {
    set?: string[]
    push?: string | string[]
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DocumentoUpdateManyWithoutCatalogoNestedInput = {
    create?: XOR<DocumentoCreateWithoutCatalogoInput, DocumentoUncheckedCreateWithoutCatalogoInput> | DocumentoCreateWithoutCatalogoInput[] | DocumentoUncheckedCreateWithoutCatalogoInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutCatalogoInput | DocumentoCreateOrConnectWithoutCatalogoInput[]
    upsert?: DocumentoUpsertWithWhereUniqueWithoutCatalogoInput | DocumentoUpsertWithWhereUniqueWithoutCatalogoInput[]
    createMany?: DocumentoCreateManyCatalogoInputEnvelope
    set?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    disconnect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    delete?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    update?: DocumentoUpdateWithWhereUniqueWithoutCatalogoInput | DocumentoUpdateWithWhereUniqueWithoutCatalogoInput[]
    updateMany?: DocumentoUpdateManyWithWhereWithoutCatalogoInput | DocumentoUpdateManyWithWhereWithoutCatalogoInput[]
    deleteMany?: DocumentoScalarWhereInput | DocumentoScalarWhereInput[]
  }

  export type DocumentoUncheckedUpdateManyWithoutCatalogoNestedInput = {
    create?: XOR<DocumentoCreateWithoutCatalogoInput, DocumentoUncheckedCreateWithoutCatalogoInput> | DocumentoCreateWithoutCatalogoInput[] | DocumentoUncheckedCreateWithoutCatalogoInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutCatalogoInput | DocumentoCreateOrConnectWithoutCatalogoInput[]
    upsert?: DocumentoUpsertWithWhereUniqueWithoutCatalogoInput | DocumentoUpsertWithWhereUniqueWithoutCatalogoInput[]
    createMany?: DocumentoCreateManyCatalogoInputEnvelope
    set?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    disconnect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    delete?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    update?: DocumentoUpdateWithWhereUniqueWithoutCatalogoInput | DocumentoUpdateWithWhereUniqueWithoutCatalogoInput[]
    updateMany?: DocumentoUpdateManyWithWhereWithoutCatalogoInput | DocumentoUpdateManyWithWhereWithoutCatalogoInput[]
    deleteMany?: DocumentoScalarWhereInput | DocumentoScalarWhereInput[]
  }

  export type UsuarioCreateNestedOneWithoutProcesosBeneficiarioInput = {
    create?: XOR<UsuarioCreateWithoutProcesosBeneficiarioInput, UsuarioUncheckedCreateWithoutProcesosBeneficiarioInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutProcesosBeneficiarioInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutProcesosArrendadorInput = {
    create?: XOR<UsuarioCreateWithoutProcesosArrendadorInput, UsuarioUncheckedCreateWithoutProcesosArrendadorInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutProcesosArrendadorInput
    connect?: UsuarioWhereUniqueInput
  }

  export type DocumentoCreateNestedManyWithoutProcesoInput = {
    create?: XOR<DocumentoCreateWithoutProcesoInput, DocumentoUncheckedCreateWithoutProcesoInput> | DocumentoCreateWithoutProcesoInput[] | DocumentoUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutProcesoInput | DocumentoCreateOrConnectWithoutProcesoInput[]
    createMany?: DocumentoCreateManyProcesoInputEnvelope
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
  }

  export type EventoAuditoriaCreateNestedManyWithoutProcesoInput = {
    create?: XOR<EventoAuditoriaCreateWithoutProcesoInput, EventoAuditoriaUncheckedCreateWithoutProcesoInput> | EventoAuditoriaCreateWithoutProcesoInput[] | EventoAuditoriaUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: EventoAuditoriaCreateOrConnectWithoutProcesoInput | EventoAuditoriaCreateOrConnectWithoutProcesoInput[]
    createMany?: EventoAuditoriaCreateManyProcesoInputEnvelope
    connect?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
  }

  export type DecisionCreateNestedManyWithoutProcesoInput = {
    create?: XOR<DecisionCreateWithoutProcesoInput, DecisionUncheckedCreateWithoutProcesoInput> | DecisionCreateWithoutProcesoInput[] | DecisionUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: DecisionCreateOrConnectWithoutProcesoInput | DecisionCreateOrConnectWithoutProcesoInput[]
    createMany?: DecisionCreateManyProcesoInputEnvelope
    connect?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
  }

  export type HistorialPdfCreateNestedManyWithoutProcesoInput = {
    create?: XOR<HistorialPdfCreateWithoutProcesoInput, HistorialPdfUncheckedCreateWithoutProcesoInput> | HistorialPdfCreateWithoutProcesoInput[] | HistorialPdfUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: HistorialPdfCreateOrConnectWithoutProcesoInput | HistorialPdfCreateOrConnectWithoutProcesoInput[]
    createMany?: HistorialPdfCreateManyProcesoInputEnvelope
    connect?: HistorialPdfWhereUniqueInput | HistorialPdfWhereUniqueInput[]
  }

  export type DocumentoUncheckedCreateNestedManyWithoutProcesoInput = {
    create?: XOR<DocumentoCreateWithoutProcesoInput, DocumentoUncheckedCreateWithoutProcesoInput> | DocumentoCreateWithoutProcesoInput[] | DocumentoUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutProcesoInput | DocumentoCreateOrConnectWithoutProcesoInput[]
    createMany?: DocumentoCreateManyProcesoInputEnvelope
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
  }

  export type EventoAuditoriaUncheckedCreateNestedManyWithoutProcesoInput = {
    create?: XOR<EventoAuditoriaCreateWithoutProcesoInput, EventoAuditoriaUncheckedCreateWithoutProcesoInput> | EventoAuditoriaCreateWithoutProcesoInput[] | EventoAuditoriaUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: EventoAuditoriaCreateOrConnectWithoutProcesoInput | EventoAuditoriaCreateOrConnectWithoutProcesoInput[]
    createMany?: EventoAuditoriaCreateManyProcesoInputEnvelope
    connect?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
  }

  export type DecisionUncheckedCreateNestedManyWithoutProcesoInput = {
    create?: XOR<DecisionCreateWithoutProcesoInput, DecisionUncheckedCreateWithoutProcesoInput> | DecisionCreateWithoutProcesoInput[] | DecisionUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: DecisionCreateOrConnectWithoutProcesoInput | DecisionCreateOrConnectWithoutProcesoInput[]
    createMany?: DecisionCreateManyProcesoInputEnvelope
    connect?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
  }

  export type HistorialPdfUncheckedCreateNestedManyWithoutProcesoInput = {
    create?: XOR<HistorialPdfCreateWithoutProcesoInput, HistorialPdfUncheckedCreateWithoutProcesoInput> | HistorialPdfCreateWithoutProcesoInput[] | HistorialPdfUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: HistorialPdfCreateOrConnectWithoutProcesoInput | HistorialPdfCreateOrConnectWithoutProcesoInput[]
    createMany?: HistorialPdfCreateManyProcesoInputEnvelope
    connect?: HistorialPdfWhereUniqueInput | HistorialPdfWhereUniqueInput[]
  }

  export type EnumEstadoProcesoFieldUpdateOperationsInput = {
    set?: $Enums.EstadoProceso
  }

  export type UsuarioUpdateOneRequiredWithoutProcesosBeneficiarioNestedInput = {
    create?: XOR<UsuarioCreateWithoutProcesosBeneficiarioInput, UsuarioUncheckedCreateWithoutProcesosBeneficiarioInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutProcesosBeneficiarioInput
    upsert?: UsuarioUpsertWithoutProcesosBeneficiarioInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutProcesosBeneficiarioInput, UsuarioUpdateWithoutProcesosBeneficiarioInput>, UsuarioUncheckedUpdateWithoutProcesosBeneficiarioInput>
  }

  export type UsuarioUpdateOneWithoutProcesosArrendadorNestedInput = {
    create?: XOR<UsuarioCreateWithoutProcesosArrendadorInput, UsuarioUncheckedCreateWithoutProcesosArrendadorInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutProcesosArrendadorInput
    upsert?: UsuarioUpsertWithoutProcesosArrendadorInput
    disconnect?: UsuarioWhereInput | boolean
    delete?: UsuarioWhereInput | boolean
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutProcesosArrendadorInput, UsuarioUpdateWithoutProcesosArrendadorInput>, UsuarioUncheckedUpdateWithoutProcesosArrendadorInput>
  }

  export type DocumentoUpdateManyWithoutProcesoNestedInput = {
    create?: XOR<DocumentoCreateWithoutProcesoInput, DocumentoUncheckedCreateWithoutProcesoInput> | DocumentoCreateWithoutProcesoInput[] | DocumentoUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutProcesoInput | DocumentoCreateOrConnectWithoutProcesoInput[]
    upsert?: DocumentoUpsertWithWhereUniqueWithoutProcesoInput | DocumentoUpsertWithWhereUniqueWithoutProcesoInput[]
    createMany?: DocumentoCreateManyProcesoInputEnvelope
    set?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    disconnect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    delete?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    update?: DocumentoUpdateWithWhereUniqueWithoutProcesoInput | DocumentoUpdateWithWhereUniqueWithoutProcesoInput[]
    updateMany?: DocumentoUpdateManyWithWhereWithoutProcesoInput | DocumentoUpdateManyWithWhereWithoutProcesoInput[]
    deleteMany?: DocumentoScalarWhereInput | DocumentoScalarWhereInput[]
  }

  export type EventoAuditoriaUpdateManyWithoutProcesoNestedInput = {
    create?: XOR<EventoAuditoriaCreateWithoutProcesoInput, EventoAuditoriaUncheckedCreateWithoutProcesoInput> | EventoAuditoriaCreateWithoutProcesoInput[] | EventoAuditoriaUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: EventoAuditoriaCreateOrConnectWithoutProcesoInput | EventoAuditoriaCreateOrConnectWithoutProcesoInput[]
    upsert?: EventoAuditoriaUpsertWithWhereUniqueWithoutProcesoInput | EventoAuditoriaUpsertWithWhereUniqueWithoutProcesoInput[]
    createMany?: EventoAuditoriaCreateManyProcesoInputEnvelope
    set?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
    disconnect?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
    delete?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
    connect?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
    update?: EventoAuditoriaUpdateWithWhereUniqueWithoutProcesoInput | EventoAuditoriaUpdateWithWhereUniqueWithoutProcesoInput[]
    updateMany?: EventoAuditoriaUpdateManyWithWhereWithoutProcesoInput | EventoAuditoriaUpdateManyWithWhereWithoutProcesoInput[]
    deleteMany?: EventoAuditoriaScalarWhereInput | EventoAuditoriaScalarWhereInput[]
  }

  export type DecisionUpdateManyWithoutProcesoNestedInput = {
    create?: XOR<DecisionCreateWithoutProcesoInput, DecisionUncheckedCreateWithoutProcesoInput> | DecisionCreateWithoutProcesoInput[] | DecisionUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: DecisionCreateOrConnectWithoutProcesoInput | DecisionCreateOrConnectWithoutProcesoInput[]
    upsert?: DecisionUpsertWithWhereUniqueWithoutProcesoInput | DecisionUpsertWithWhereUniqueWithoutProcesoInput[]
    createMany?: DecisionCreateManyProcesoInputEnvelope
    set?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
    disconnect?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
    delete?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
    connect?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
    update?: DecisionUpdateWithWhereUniqueWithoutProcesoInput | DecisionUpdateWithWhereUniqueWithoutProcesoInput[]
    updateMany?: DecisionUpdateManyWithWhereWithoutProcesoInput | DecisionUpdateManyWithWhereWithoutProcesoInput[]
    deleteMany?: DecisionScalarWhereInput | DecisionScalarWhereInput[]
  }

  export type HistorialPdfUpdateManyWithoutProcesoNestedInput = {
    create?: XOR<HistorialPdfCreateWithoutProcesoInput, HistorialPdfUncheckedCreateWithoutProcesoInput> | HistorialPdfCreateWithoutProcesoInput[] | HistorialPdfUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: HistorialPdfCreateOrConnectWithoutProcesoInput | HistorialPdfCreateOrConnectWithoutProcesoInput[]
    upsert?: HistorialPdfUpsertWithWhereUniqueWithoutProcesoInput | HistorialPdfUpsertWithWhereUniqueWithoutProcesoInput[]
    createMany?: HistorialPdfCreateManyProcesoInputEnvelope
    set?: HistorialPdfWhereUniqueInput | HistorialPdfWhereUniqueInput[]
    disconnect?: HistorialPdfWhereUniqueInput | HistorialPdfWhereUniqueInput[]
    delete?: HistorialPdfWhereUniqueInput | HistorialPdfWhereUniqueInput[]
    connect?: HistorialPdfWhereUniqueInput | HistorialPdfWhereUniqueInput[]
    update?: HistorialPdfUpdateWithWhereUniqueWithoutProcesoInput | HistorialPdfUpdateWithWhereUniqueWithoutProcesoInput[]
    updateMany?: HistorialPdfUpdateManyWithWhereWithoutProcesoInput | HistorialPdfUpdateManyWithWhereWithoutProcesoInput[]
    deleteMany?: HistorialPdfScalarWhereInput | HistorialPdfScalarWhereInput[]
  }

  export type DocumentoUncheckedUpdateManyWithoutProcesoNestedInput = {
    create?: XOR<DocumentoCreateWithoutProcesoInput, DocumentoUncheckedCreateWithoutProcesoInput> | DocumentoCreateWithoutProcesoInput[] | DocumentoUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: DocumentoCreateOrConnectWithoutProcesoInput | DocumentoCreateOrConnectWithoutProcesoInput[]
    upsert?: DocumentoUpsertWithWhereUniqueWithoutProcesoInput | DocumentoUpsertWithWhereUniqueWithoutProcesoInput[]
    createMany?: DocumentoCreateManyProcesoInputEnvelope
    set?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    disconnect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    delete?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    connect?: DocumentoWhereUniqueInput | DocumentoWhereUniqueInput[]
    update?: DocumentoUpdateWithWhereUniqueWithoutProcesoInput | DocumentoUpdateWithWhereUniqueWithoutProcesoInput[]
    updateMany?: DocumentoUpdateManyWithWhereWithoutProcesoInput | DocumentoUpdateManyWithWhereWithoutProcesoInput[]
    deleteMany?: DocumentoScalarWhereInput | DocumentoScalarWhereInput[]
  }

  export type EventoAuditoriaUncheckedUpdateManyWithoutProcesoNestedInput = {
    create?: XOR<EventoAuditoriaCreateWithoutProcesoInput, EventoAuditoriaUncheckedCreateWithoutProcesoInput> | EventoAuditoriaCreateWithoutProcesoInput[] | EventoAuditoriaUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: EventoAuditoriaCreateOrConnectWithoutProcesoInput | EventoAuditoriaCreateOrConnectWithoutProcesoInput[]
    upsert?: EventoAuditoriaUpsertWithWhereUniqueWithoutProcesoInput | EventoAuditoriaUpsertWithWhereUniqueWithoutProcesoInput[]
    createMany?: EventoAuditoriaCreateManyProcesoInputEnvelope
    set?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
    disconnect?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
    delete?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
    connect?: EventoAuditoriaWhereUniqueInput | EventoAuditoriaWhereUniqueInput[]
    update?: EventoAuditoriaUpdateWithWhereUniqueWithoutProcesoInput | EventoAuditoriaUpdateWithWhereUniqueWithoutProcesoInput[]
    updateMany?: EventoAuditoriaUpdateManyWithWhereWithoutProcesoInput | EventoAuditoriaUpdateManyWithWhereWithoutProcesoInput[]
    deleteMany?: EventoAuditoriaScalarWhereInput | EventoAuditoriaScalarWhereInput[]
  }

  export type DecisionUncheckedUpdateManyWithoutProcesoNestedInput = {
    create?: XOR<DecisionCreateWithoutProcesoInput, DecisionUncheckedCreateWithoutProcesoInput> | DecisionCreateWithoutProcesoInput[] | DecisionUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: DecisionCreateOrConnectWithoutProcesoInput | DecisionCreateOrConnectWithoutProcesoInput[]
    upsert?: DecisionUpsertWithWhereUniqueWithoutProcesoInput | DecisionUpsertWithWhereUniqueWithoutProcesoInput[]
    createMany?: DecisionCreateManyProcesoInputEnvelope
    set?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
    disconnect?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
    delete?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
    connect?: DecisionWhereUniqueInput | DecisionWhereUniqueInput[]
    update?: DecisionUpdateWithWhereUniqueWithoutProcesoInput | DecisionUpdateWithWhereUniqueWithoutProcesoInput[]
    updateMany?: DecisionUpdateManyWithWhereWithoutProcesoInput | DecisionUpdateManyWithWhereWithoutProcesoInput[]
    deleteMany?: DecisionScalarWhereInput | DecisionScalarWhereInput[]
  }

  export type HistorialPdfUncheckedUpdateManyWithoutProcesoNestedInput = {
    create?: XOR<HistorialPdfCreateWithoutProcesoInput, HistorialPdfUncheckedCreateWithoutProcesoInput> | HistorialPdfCreateWithoutProcesoInput[] | HistorialPdfUncheckedCreateWithoutProcesoInput[]
    connectOrCreate?: HistorialPdfCreateOrConnectWithoutProcesoInput | HistorialPdfCreateOrConnectWithoutProcesoInput[]
    upsert?: HistorialPdfUpsertWithWhereUniqueWithoutProcesoInput | HistorialPdfUpsertWithWhereUniqueWithoutProcesoInput[]
    createMany?: HistorialPdfCreateManyProcesoInputEnvelope
    set?: HistorialPdfWhereUniqueInput | HistorialPdfWhereUniqueInput[]
    disconnect?: HistorialPdfWhereUniqueInput | HistorialPdfWhereUniqueInput[]
    delete?: HistorialPdfWhereUniqueInput | HistorialPdfWhereUniqueInput[]
    connect?: HistorialPdfWhereUniqueInput | HistorialPdfWhereUniqueInput[]
    update?: HistorialPdfUpdateWithWhereUniqueWithoutProcesoInput | HistorialPdfUpdateWithWhereUniqueWithoutProcesoInput[]
    updateMany?: HistorialPdfUpdateManyWithWhereWithoutProcesoInput | HistorialPdfUpdateManyWithWhereWithoutProcesoInput[]
    deleteMany?: HistorialPdfScalarWhereInput | HistorialPdfScalarWhereInput[]
  }

  export type ProcesoCreateNestedOneWithoutDocumentosInput = {
    create?: XOR<ProcesoCreateWithoutDocumentosInput, ProcesoUncheckedCreateWithoutDocumentosInput>
    connectOrCreate?: ProcesoCreateOrConnectWithoutDocumentosInput
    connect?: ProcesoWhereUniqueInput
  }

  export type CatalogoDocumentoCreateNestedOneWithoutDocumentosInput = {
    create?: XOR<CatalogoDocumentoCreateWithoutDocumentosInput, CatalogoDocumentoUncheckedCreateWithoutDocumentosInput>
    connectOrCreate?: CatalogoDocumentoCreateOrConnectWithoutDocumentosInput
    connect?: CatalogoDocumentoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutDocumentosCargadosInput = {
    create?: XOR<UsuarioCreateWithoutDocumentosCargadosInput, UsuarioUncheckedCreateWithoutDocumentosCargadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutDocumentosCargadosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutDocumentosValidadosInput = {
    create?: XOR<UsuarioCreateWithoutDocumentosValidadosInput, UsuarioUncheckedCreateWithoutDocumentosValidadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutDocumentosValidadosInput
    connect?: UsuarioWhereUniqueInput
  }

  export type RegistroDescargaCreateNestedManyWithoutDocumentoInput = {
    create?: XOR<RegistroDescargaCreateWithoutDocumentoInput, RegistroDescargaUncheckedCreateWithoutDocumentoInput> | RegistroDescargaCreateWithoutDocumentoInput[] | RegistroDescargaUncheckedCreateWithoutDocumentoInput[]
    connectOrCreate?: RegistroDescargaCreateOrConnectWithoutDocumentoInput | RegistroDescargaCreateOrConnectWithoutDocumentoInput[]
    createMany?: RegistroDescargaCreateManyDocumentoInputEnvelope
    connect?: RegistroDescargaWhereUniqueInput | RegistroDescargaWhereUniqueInput[]
  }

  export type RegistroDescargaUncheckedCreateNestedManyWithoutDocumentoInput = {
    create?: XOR<RegistroDescargaCreateWithoutDocumentoInput, RegistroDescargaUncheckedCreateWithoutDocumentoInput> | RegistroDescargaCreateWithoutDocumentoInput[] | RegistroDescargaUncheckedCreateWithoutDocumentoInput[]
    connectOrCreate?: RegistroDescargaCreateOrConnectWithoutDocumentoInput | RegistroDescargaCreateOrConnectWithoutDocumentoInput[]
    createMany?: RegistroDescargaCreateManyDocumentoInputEnvelope
    connect?: RegistroDescargaWhereUniqueInput | RegistroDescargaWhereUniqueInput[]
  }

  export type EnumEstadoDocumentoFieldUpdateOperationsInput = {
    set?: $Enums.EstadoDocumento
  }

  export type ProcesoUpdateOneRequiredWithoutDocumentosNestedInput = {
    create?: XOR<ProcesoCreateWithoutDocumentosInput, ProcesoUncheckedCreateWithoutDocumentosInput>
    connectOrCreate?: ProcesoCreateOrConnectWithoutDocumentosInput
    upsert?: ProcesoUpsertWithoutDocumentosInput
    connect?: ProcesoWhereUniqueInput
    update?: XOR<XOR<ProcesoUpdateToOneWithWhereWithoutDocumentosInput, ProcesoUpdateWithoutDocumentosInput>, ProcesoUncheckedUpdateWithoutDocumentosInput>
  }

  export type CatalogoDocumentoUpdateOneRequiredWithoutDocumentosNestedInput = {
    create?: XOR<CatalogoDocumentoCreateWithoutDocumentosInput, CatalogoDocumentoUncheckedCreateWithoutDocumentosInput>
    connectOrCreate?: CatalogoDocumentoCreateOrConnectWithoutDocumentosInput
    upsert?: CatalogoDocumentoUpsertWithoutDocumentosInput
    connect?: CatalogoDocumentoWhereUniqueInput
    update?: XOR<XOR<CatalogoDocumentoUpdateToOneWithWhereWithoutDocumentosInput, CatalogoDocumentoUpdateWithoutDocumentosInput>, CatalogoDocumentoUncheckedUpdateWithoutDocumentosInput>
  }

  export type UsuarioUpdateOneRequiredWithoutDocumentosCargadosNestedInput = {
    create?: XOR<UsuarioCreateWithoutDocumentosCargadosInput, UsuarioUncheckedCreateWithoutDocumentosCargadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutDocumentosCargadosInput
    upsert?: UsuarioUpsertWithoutDocumentosCargadosInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutDocumentosCargadosInput, UsuarioUpdateWithoutDocumentosCargadosInput>, UsuarioUncheckedUpdateWithoutDocumentosCargadosInput>
  }

  export type UsuarioUpdateOneWithoutDocumentosValidadosNestedInput = {
    create?: XOR<UsuarioCreateWithoutDocumentosValidadosInput, UsuarioUncheckedCreateWithoutDocumentosValidadosInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutDocumentosValidadosInput
    upsert?: UsuarioUpsertWithoutDocumentosValidadosInput
    disconnect?: UsuarioWhereInput | boolean
    delete?: UsuarioWhereInput | boolean
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutDocumentosValidadosInput, UsuarioUpdateWithoutDocumentosValidadosInput>, UsuarioUncheckedUpdateWithoutDocumentosValidadosInput>
  }

  export type RegistroDescargaUpdateManyWithoutDocumentoNestedInput = {
    create?: XOR<RegistroDescargaCreateWithoutDocumentoInput, RegistroDescargaUncheckedCreateWithoutDocumentoInput> | RegistroDescargaCreateWithoutDocumentoInput[] | RegistroDescargaUncheckedCreateWithoutDocumentoInput[]
    connectOrCreate?: RegistroDescargaCreateOrConnectWithoutDocumentoInput | RegistroDescargaCreateOrConnectWithoutDocumentoInput[]
    upsert?: RegistroDescargaUpsertWithWhereUniqueWithoutDocumentoInput | RegistroDescargaUpsertWithWhereUniqueWithoutDocumentoInput[]
    createMany?: RegistroDescargaCreateManyDocumentoInputEnvelope
    set?: RegistroDescargaWhereUniqueInput | RegistroDescargaWhereUniqueInput[]
    disconnect?: RegistroDescargaWhereUniqueInput | RegistroDescargaWhereUniqueInput[]
    delete?: RegistroDescargaWhereUniqueInput | RegistroDescargaWhereUniqueInput[]
    connect?: RegistroDescargaWhereUniqueInput | RegistroDescargaWhereUniqueInput[]
    update?: RegistroDescargaUpdateWithWhereUniqueWithoutDocumentoInput | RegistroDescargaUpdateWithWhereUniqueWithoutDocumentoInput[]
    updateMany?: RegistroDescargaUpdateManyWithWhereWithoutDocumentoInput | RegistroDescargaUpdateManyWithWhereWithoutDocumentoInput[]
    deleteMany?: RegistroDescargaScalarWhereInput | RegistroDescargaScalarWhereInput[]
  }

  export type RegistroDescargaUncheckedUpdateManyWithoutDocumentoNestedInput = {
    create?: XOR<RegistroDescargaCreateWithoutDocumentoInput, RegistroDescargaUncheckedCreateWithoutDocumentoInput> | RegistroDescargaCreateWithoutDocumentoInput[] | RegistroDescargaUncheckedCreateWithoutDocumentoInput[]
    connectOrCreate?: RegistroDescargaCreateOrConnectWithoutDocumentoInput | RegistroDescargaCreateOrConnectWithoutDocumentoInput[]
    upsert?: RegistroDescargaUpsertWithWhereUniqueWithoutDocumentoInput | RegistroDescargaUpsertWithWhereUniqueWithoutDocumentoInput[]
    createMany?: RegistroDescargaCreateManyDocumentoInputEnvelope
    set?: RegistroDescargaWhereUniqueInput | RegistroDescargaWhereUniqueInput[]
    disconnect?: RegistroDescargaWhereUniqueInput | RegistroDescargaWhereUniqueInput[]
    delete?: RegistroDescargaWhereUniqueInput | RegistroDescargaWhereUniqueInput[]
    connect?: RegistroDescargaWhereUniqueInput | RegistroDescargaWhereUniqueInput[]
    update?: RegistroDescargaUpdateWithWhereUniqueWithoutDocumentoInput | RegistroDescargaUpdateWithWhereUniqueWithoutDocumentoInput[]
    updateMany?: RegistroDescargaUpdateManyWithWhereWithoutDocumentoInput | RegistroDescargaUpdateManyWithWhereWithoutDocumentoInput[]
    deleteMany?: RegistroDescargaScalarWhereInput | RegistroDescargaScalarWhereInput[]
  }

  export type DocumentoCreateNestedOneWithoutDescargasInput = {
    create?: XOR<DocumentoCreateWithoutDescargasInput, DocumentoUncheckedCreateWithoutDescargasInput>
    connectOrCreate?: DocumentoCreateOrConnectWithoutDescargasInput
    connect?: DocumentoWhereUniqueInput
  }

  export type DocumentoUpdateOneRequiredWithoutDescargasNestedInput = {
    create?: XOR<DocumentoCreateWithoutDescargasInput, DocumentoUncheckedCreateWithoutDescargasInput>
    connectOrCreate?: DocumentoCreateOrConnectWithoutDescargasInput
    upsert?: DocumentoUpsertWithoutDescargasInput
    connect?: DocumentoWhereUniqueInput
    update?: XOR<XOR<DocumentoUpdateToOneWithWhereWithoutDescargasInput, DocumentoUpdateWithoutDescargasInput>, DocumentoUncheckedUpdateWithoutDescargasInput>
  }

  export type ProcesoCreateNestedOneWithoutHistorialPdfInput = {
    create?: XOR<ProcesoCreateWithoutHistorialPdfInput, ProcesoUncheckedCreateWithoutHistorialPdfInput>
    connectOrCreate?: ProcesoCreateOrConnectWithoutHistorialPdfInput
    connect?: ProcesoWhereUniqueInput
  }

  export type ProcesoUpdateOneRequiredWithoutHistorialPdfNestedInput = {
    create?: XOR<ProcesoCreateWithoutHistorialPdfInput, ProcesoUncheckedCreateWithoutHistorialPdfInput>
    connectOrCreate?: ProcesoCreateOrConnectWithoutHistorialPdfInput
    upsert?: ProcesoUpsertWithoutHistorialPdfInput
    connect?: ProcesoWhereUniqueInput
    update?: XOR<XOR<ProcesoUpdateToOneWithWhereWithoutHistorialPdfInput, ProcesoUpdateWithoutHistorialPdfInput>, ProcesoUncheckedUpdateWithoutHistorialPdfInput>
  }

  export type ProcesoCreateNestedOneWithoutDecisionesInput = {
    create?: XOR<ProcesoCreateWithoutDecisionesInput, ProcesoUncheckedCreateWithoutDecisionesInput>
    connectOrCreate?: ProcesoCreateOrConnectWithoutDecisionesInput
    connect?: ProcesoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutDecisionesInput = {
    create?: XOR<UsuarioCreateWithoutDecisionesInput, UsuarioUncheckedCreateWithoutDecisionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutDecisionesInput
    connect?: UsuarioWhereUniqueInput
  }

  export type ProcesoUpdateOneRequiredWithoutDecisionesNestedInput = {
    create?: XOR<ProcesoCreateWithoutDecisionesInput, ProcesoUncheckedCreateWithoutDecisionesInput>
    connectOrCreate?: ProcesoCreateOrConnectWithoutDecisionesInput
    upsert?: ProcesoUpsertWithoutDecisionesInput
    connect?: ProcesoWhereUniqueInput
    update?: XOR<XOR<ProcesoUpdateToOneWithWhereWithoutDecisionesInput, ProcesoUpdateWithoutDecisionesInput>, ProcesoUncheckedUpdateWithoutDecisionesInput>
  }

  export type UsuarioUpdateOneRequiredWithoutDecisionesNestedInput = {
    create?: XOR<UsuarioCreateWithoutDecisionesInput, UsuarioUncheckedCreateWithoutDecisionesInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutDecisionesInput
    upsert?: UsuarioUpsertWithoutDecisionesInput
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutDecisionesInput, UsuarioUpdateWithoutDecisionesInput>, UsuarioUncheckedUpdateWithoutDecisionesInput>
  }

  export type ProcesoCreateNestedOneWithoutEventosInput = {
    create?: XOR<ProcesoCreateWithoutEventosInput, ProcesoUncheckedCreateWithoutEventosInput>
    connectOrCreate?: ProcesoCreateOrConnectWithoutEventosInput
    connect?: ProcesoWhereUniqueInput
  }

  export type UsuarioCreateNestedOneWithoutEventosAuditoriaInput = {
    create?: XOR<UsuarioCreateWithoutEventosAuditoriaInput, UsuarioUncheckedCreateWithoutEventosAuditoriaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEventosAuditoriaInput
    connect?: UsuarioWhereUniqueInput
  }

  export type EnumTipoEventoFieldUpdateOperationsInput = {
    set?: $Enums.TipoEvento
  }

  export type ProcesoUpdateOneWithoutEventosNestedInput = {
    create?: XOR<ProcesoCreateWithoutEventosInput, ProcesoUncheckedCreateWithoutEventosInput>
    connectOrCreate?: ProcesoCreateOrConnectWithoutEventosInput
    upsert?: ProcesoUpsertWithoutEventosInput
    disconnect?: ProcesoWhereInput | boolean
    delete?: ProcesoWhereInput | boolean
    connect?: ProcesoWhereUniqueInput
    update?: XOR<XOR<ProcesoUpdateToOneWithWhereWithoutEventosInput, ProcesoUpdateWithoutEventosInput>, ProcesoUncheckedUpdateWithoutEventosInput>
  }

  export type UsuarioUpdateOneWithoutEventosAuditoriaNestedInput = {
    create?: XOR<UsuarioCreateWithoutEventosAuditoriaInput, UsuarioUncheckedCreateWithoutEventosAuditoriaInput>
    connectOrCreate?: UsuarioCreateOrConnectWithoutEventosAuditoriaInput
    upsert?: UsuarioUpsertWithoutEventosAuditoriaInput
    disconnect?: UsuarioWhereInput | boolean
    delete?: UsuarioWhereInput | boolean
    connect?: UsuarioWhereUniqueInput
    update?: XOR<XOR<UsuarioUpdateToOneWithWhereWithoutEventosAuditoriaInput, UsuarioUpdateWithoutEventosAuditoriaInput>, UsuarioUncheckedUpdateWithoutEventosAuditoriaInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumRolFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    notIn?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    not?: NestedEnumRolFilter<$PrismaModel> | $Enums.Rol
  }

  export type NestedEnumEstadoUsuarioFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoUsuario | EnumEstadoUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoUsuario[] | ListEnumEstadoUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoUsuario[] | ListEnumEstadoUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoUsuarioFilter<$PrismaModel> | $Enums.EstadoUsuario
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedEnumRolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.Rol | EnumRolFieldRefInput<$PrismaModel>
    in?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    notIn?: $Enums.Rol[] | ListEnumRolFieldRefInput<$PrismaModel>
    not?: NestedEnumRolWithAggregatesFilter<$PrismaModel> | $Enums.Rol
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumRolFilter<$PrismaModel>
    _max?: NestedEnumRolFilter<$PrismaModel>
  }

  export type NestedEnumEstadoUsuarioWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoUsuario | EnumEstadoUsuarioFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoUsuario[] | ListEnumEstadoUsuarioFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoUsuario[] | ListEnumEstadoUsuarioFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoUsuarioWithAggregatesFilter<$PrismaModel> | $Enums.EstadoUsuario
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoUsuarioFilter<$PrismaModel>
    _max?: NestedEnumEstadoUsuarioFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedEnumTipoDocumentoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoDocumento | EnumTipoDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoDocumento[] | ListEnumTipoDocumentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoDocumento[] | ListEnumTipoDocumentoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoDocumentoFilter<$PrismaModel> | $Enums.TipoDocumento
  }

  export type NestedEnumTipoDocumentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoDocumento | EnumTipoDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoDocumento[] | ListEnumTipoDocumentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoDocumento[] | ListEnumTipoDocumentoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoDocumentoWithAggregatesFilter<$PrismaModel> | $Enums.TipoDocumento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoDocumentoFilter<$PrismaModel>
    _max?: NestedEnumTipoDocumentoFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedEnumEstadoProcesoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoProceso | EnumEstadoProcesoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoProceso[] | ListEnumEstadoProcesoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoProceso[] | ListEnumEstadoProcesoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoProcesoFilter<$PrismaModel> | $Enums.EstadoProceso
  }

  export type NestedEnumEstadoProcesoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoProceso | EnumEstadoProcesoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoProceso[] | ListEnumEstadoProcesoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoProceso[] | ListEnumEstadoProcesoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoProcesoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoProceso
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoProcesoFilter<$PrismaModel>
    _max?: NestedEnumEstadoProcesoFilter<$PrismaModel>
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string[]
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    lte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gt?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    gte?: InputJsonValue | JsonFieldRefInput<$PrismaModel>
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedEnumEstadoDocumentoFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoDocumento | EnumEstadoDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoDocumento[] | ListEnumEstadoDocumentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoDocumento[] | ListEnumEstadoDocumentoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoDocumentoFilter<$PrismaModel> | $Enums.EstadoDocumento
  }

  export type NestedEnumEstadoDocumentoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.EstadoDocumento | EnumEstadoDocumentoFieldRefInput<$PrismaModel>
    in?: $Enums.EstadoDocumento[] | ListEnumEstadoDocumentoFieldRefInput<$PrismaModel>
    notIn?: $Enums.EstadoDocumento[] | ListEnumEstadoDocumentoFieldRefInput<$PrismaModel>
    not?: NestedEnumEstadoDocumentoWithAggregatesFilter<$PrismaModel> | $Enums.EstadoDocumento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumEstadoDocumentoFilter<$PrismaModel>
    _max?: NestedEnumEstadoDocumentoFilter<$PrismaModel>
  }

  export type NestedEnumTipoEventoFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEvento | EnumTipoEventoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEvento[] | ListEnumTipoEventoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoEvento[] | ListEnumTipoEventoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoEventoFilter<$PrismaModel> | $Enums.TipoEvento
  }

  export type NestedEnumTipoEventoWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.TipoEvento | EnumTipoEventoFieldRefInput<$PrismaModel>
    in?: $Enums.TipoEvento[] | ListEnumTipoEventoFieldRefInput<$PrismaModel>
    notIn?: $Enums.TipoEvento[] | ListEnumTipoEventoFieldRefInput<$PrismaModel>
    not?: NestedEnumTipoEventoWithAggregatesFilter<$PrismaModel> | $Enums.TipoEvento
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumTipoEventoFilter<$PrismaModel>
    _max?: NestedEnumTipoEventoFilter<$PrismaModel>
  }

  export type UsuarioCreateWithoutUsuariosCreadosInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPor?: UsuarioCreateNestedOneWithoutUsuariosCreadosInput
    passwordHistorial?: PasswordHistorialCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutUsuariosCreadosInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPorId?: string | null
    passwordHistorial?: PasswordHistorialUncheckedCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionUncheckedCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoUncheckedCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoUncheckedCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoUncheckedCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoUncheckedCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionUncheckedCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionUncheckedCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutUsuariosCreadosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutUsuariosCreadosInput, UsuarioUncheckedCreateWithoutUsuariosCreadosInput>
  }

  export type UsuarioCreateWithoutCreadoPorInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuariosCreados?: UsuarioCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutCreadoPorInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    usuariosCreados?: UsuarioUncheckedCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialUncheckedCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionUncheckedCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoUncheckedCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoUncheckedCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoUncheckedCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoUncheckedCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionUncheckedCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionUncheckedCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutCreadoPorInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutCreadoPorInput, UsuarioUncheckedCreateWithoutCreadoPorInput>
  }

  export type UsuarioCreateManyCreadoPorInputEnvelope = {
    data: UsuarioCreateManyCreadoPorInput | UsuarioCreateManyCreadoPorInput[]
    skipDuplicates?: boolean
  }

  export type PasswordHistorialCreateWithoutUsuarioInput = {
    id?: string
    passwordHash: string
    creadoEn?: Date | string
  }

  export type PasswordHistorialUncheckedCreateWithoutUsuarioInput = {
    id?: string
    passwordHash: string
    creadoEn?: Date | string
  }

  export type PasswordHistorialCreateOrConnectWithoutUsuarioInput = {
    where: PasswordHistorialWhereUniqueInput
    create: XOR<PasswordHistorialCreateWithoutUsuarioInput, PasswordHistorialUncheckedCreateWithoutUsuarioInput>
  }

  export type PasswordHistorialCreateManyUsuarioInputEnvelope = {
    data: PasswordHistorialCreateManyUsuarioInput | PasswordHistorialCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type SesionCreateWithoutUsuarioInput = {
    id?: string
    tokenHash: string
    ipAddress: string
    userAgent: string
    expiraEn: Date | string
    creadoEn?: Date | string
    ultimaActividad?: Date | string
  }

  export type SesionUncheckedCreateWithoutUsuarioInput = {
    id?: string
    tokenHash: string
    ipAddress: string
    userAgent: string
    expiraEn: Date | string
    creadoEn?: Date | string
    ultimaActividad?: Date | string
  }

  export type SesionCreateOrConnectWithoutUsuarioInput = {
    where: SesionWhereUniqueInput
    create: XOR<SesionCreateWithoutUsuarioInput, SesionUncheckedCreateWithoutUsuarioInput>
  }

  export type SesionCreateManyUsuarioInputEnvelope = {
    data: SesionCreateManyUsuarioInput | SesionCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type ProcesoCreateWithoutBeneficiarioInput = {
    id?: string
    codigo: string
    estado?: $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: string | null
    pdfHash?: string | null
    pdfVersion?: number
    firmado?: boolean
    firmadoEn?: Date | string | null
    firmadoPorId?: string | null
    firmaHash?: string | null
    firmaIp?: string | null
    firmaUserAgent?: string | null
    cerradoEn?: Date | string | null
    cerradoPorId?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    enviadoEn?: Date | string | null
    arrendador?: UsuarioCreateNestedOneWithoutProcesosArrendadorInput
    documentos?: DocumentoCreateNestedManyWithoutProcesoInput
    eventos?: EventoAuditoriaCreateNestedManyWithoutProcesoInput
    decisiones?: DecisionCreateNestedManyWithoutProcesoInput
    historialPdf?: HistorialPdfCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoUncheckedCreateWithoutBeneficiarioInput = {
    id?: string
    codigo: string
    arrendadorId?: string | null
    estado?: $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: string | null
    pdfHash?: string | null
    pdfVersion?: number
    firmado?: boolean
    firmadoEn?: Date | string | null
    firmadoPorId?: string | null
    firmaHash?: string | null
    firmaIp?: string | null
    firmaUserAgent?: string | null
    cerradoEn?: Date | string | null
    cerradoPorId?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    enviadoEn?: Date | string | null
    documentos?: DocumentoUncheckedCreateNestedManyWithoutProcesoInput
    eventos?: EventoAuditoriaUncheckedCreateNestedManyWithoutProcesoInput
    decisiones?: DecisionUncheckedCreateNestedManyWithoutProcesoInput
    historialPdf?: HistorialPdfUncheckedCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoCreateOrConnectWithoutBeneficiarioInput = {
    where: ProcesoWhereUniqueInput
    create: XOR<ProcesoCreateWithoutBeneficiarioInput, ProcesoUncheckedCreateWithoutBeneficiarioInput>
  }

  export type ProcesoCreateManyBeneficiarioInputEnvelope = {
    data: ProcesoCreateManyBeneficiarioInput | ProcesoCreateManyBeneficiarioInput[]
    skipDuplicates?: boolean
  }

  export type ProcesoCreateWithoutArrendadorInput = {
    id?: string
    codigo: string
    estado?: $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: string | null
    pdfHash?: string | null
    pdfVersion?: number
    firmado?: boolean
    firmadoEn?: Date | string | null
    firmadoPorId?: string | null
    firmaHash?: string | null
    firmaIp?: string | null
    firmaUserAgent?: string | null
    cerradoEn?: Date | string | null
    cerradoPorId?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    enviadoEn?: Date | string | null
    beneficiario: UsuarioCreateNestedOneWithoutProcesosBeneficiarioInput
    documentos?: DocumentoCreateNestedManyWithoutProcesoInput
    eventos?: EventoAuditoriaCreateNestedManyWithoutProcesoInput
    decisiones?: DecisionCreateNestedManyWithoutProcesoInput
    historialPdf?: HistorialPdfCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoUncheckedCreateWithoutArrendadorInput = {
    id?: string
    codigo: string
    beneficiarioId: string
    estado?: $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: string | null
    pdfHash?: string | null
    pdfVersion?: number
    firmado?: boolean
    firmadoEn?: Date | string | null
    firmadoPorId?: string | null
    firmaHash?: string | null
    firmaIp?: string | null
    firmaUserAgent?: string | null
    cerradoEn?: Date | string | null
    cerradoPorId?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    enviadoEn?: Date | string | null
    documentos?: DocumentoUncheckedCreateNestedManyWithoutProcesoInput
    eventos?: EventoAuditoriaUncheckedCreateNestedManyWithoutProcesoInput
    decisiones?: DecisionUncheckedCreateNestedManyWithoutProcesoInput
    historialPdf?: HistorialPdfUncheckedCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoCreateOrConnectWithoutArrendadorInput = {
    where: ProcesoWhereUniqueInput
    create: XOR<ProcesoCreateWithoutArrendadorInput, ProcesoUncheckedCreateWithoutArrendadorInput>
  }

  export type ProcesoCreateManyArrendadorInputEnvelope = {
    data: ProcesoCreateManyArrendadorInput | ProcesoCreateManyArrendadorInput[]
    skipDuplicates?: boolean
  }

  export type DocumentoCreateWithoutCargadoPorInput = {
    id?: string
    nombreOriginal: string
    nombreAlmacenado: string
    rutaArchivo: string
    mimeType: string
    tamanoBytes: number
    hashArchivo: string
    estado?: $Enums.EstadoDocumento
    validadoEn?: Date | string | null
    motivoRechazo?: string | null
    version?: number
    esActivo?: boolean
    creadoEn?: Date | string
    proceso: ProcesoCreateNestedOneWithoutDocumentosInput
    catalogo: CatalogoDocumentoCreateNestedOneWithoutDocumentosInput
    validadoPor?: UsuarioCreateNestedOneWithoutDocumentosValidadosInput
    descargas?: RegistroDescargaCreateNestedManyWithoutDocumentoInput
  }

  export type DocumentoUncheckedCreateWithoutCargadoPorInput = {
    id?: string
    procesoId: string
    catalogoId: string
    nombreOriginal: string
    nombreAlmacenado: string
    rutaArchivo: string
    mimeType: string
    tamanoBytes: number
    hashArchivo: string
    estado?: $Enums.EstadoDocumento
    validadoPorId?: string | null
    validadoEn?: Date | string | null
    motivoRechazo?: string | null
    version?: number
    esActivo?: boolean
    creadoEn?: Date | string
    descargas?: RegistroDescargaUncheckedCreateNestedManyWithoutDocumentoInput
  }

  export type DocumentoCreateOrConnectWithoutCargadoPorInput = {
    where: DocumentoWhereUniqueInput
    create: XOR<DocumentoCreateWithoutCargadoPorInput, DocumentoUncheckedCreateWithoutCargadoPorInput>
  }

  export type DocumentoCreateManyCargadoPorInputEnvelope = {
    data: DocumentoCreateManyCargadoPorInput | DocumentoCreateManyCargadoPorInput[]
    skipDuplicates?: boolean
  }

  export type DocumentoCreateWithoutValidadoPorInput = {
    id?: string
    nombreOriginal: string
    nombreAlmacenado: string
    rutaArchivo: string
    mimeType: string
    tamanoBytes: number
    hashArchivo: string
    estado?: $Enums.EstadoDocumento
    validadoEn?: Date | string | null
    motivoRechazo?: string | null
    version?: number
    esActivo?: boolean
    creadoEn?: Date | string
    proceso: ProcesoCreateNestedOneWithoutDocumentosInput
    catalogo: CatalogoDocumentoCreateNestedOneWithoutDocumentosInput
    cargadoPor: UsuarioCreateNestedOneWithoutDocumentosCargadosInput
    descargas?: RegistroDescargaCreateNestedManyWithoutDocumentoInput
  }

  export type DocumentoUncheckedCreateWithoutValidadoPorInput = {
    id?: string
    procesoId: string
    catalogoId: string
    nombreOriginal: string
    nombreAlmacenado: string
    rutaArchivo: string
    mimeType: string
    tamanoBytes: number
    hashArchivo: string
    estado?: $Enums.EstadoDocumento
    validadoEn?: Date | string | null
    motivoRechazo?: string | null
    version?: number
    esActivo?: boolean
    creadoEn?: Date | string
    cargadoPorId: string
    descargas?: RegistroDescargaUncheckedCreateNestedManyWithoutDocumentoInput
  }

  export type DocumentoCreateOrConnectWithoutValidadoPorInput = {
    where: DocumentoWhereUniqueInput
    create: XOR<DocumentoCreateWithoutValidadoPorInput, DocumentoUncheckedCreateWithoutValidadoPorInput>
  }

  export type DocumentoCreateManyValidadoPorInputEnvelope = {
    data: DocumentoCreateManyValidadoPorInput | DocumentoCreateManyValidadoPorInput[]
    skipDuplicates?: boolean
  }

  export type EventoAuditoriaCreateWithoutUsuarioInput = {
    id?: string
    tipo: $Enums.TipoEvento
    descripcion: string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
    proceso?: ProcesoCreateNestedOneWithoutEventosInput
  }

  export type EventoAuditoriaUncheckedCreateWithoutUsuarioInput = {
    id?: string
    procesoId?: string | null
    tipo: $Enums.TipoEvento
    descripcion: string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
  }

  export type EventoAuditoriaCreateOrConnectWithoutUsuarioInput = {
    where: EventoAuditoriaWhereUniqueInput
    create: XOR<EventoAuditoriaCreateWithoutUsuarioInput, EventoAuditoriaUncheckedCreateWithoutUsuarioInput>
  }

  export type EventoAuditoriaCreateManyUsuarioInputEnvelope = {
    data: EventoAuditoriaCreateManyUsuarioInput | EventoAuditoriaCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type DecisionCreateWithoutUsuarioInput = {
    id?: string
    estadoAnterior: $Enums.EstadoProceso
    estadoNuevo: $Enums.EstadoProceso
    aprobado: boolean
    motivo: string
    rol: $Enums.Rol
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
    proceso: ProcesoCreateNestedOneWithoutDecisionesInput
  }

  export type DecisionUncheckedCreateWithoutUsuarioInput = {
    id?: string
    procesoId: string
    estadoAnterior: $Enums.EstadoProceso
    estadoNuevo: $Enums.EstadoProceso
    aprobado: boolean
    motivo: string
    rol: $Enums.Rol
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
  }

  export type DecisionCreateOrConnectWithoutUsuarioInput = {
    where: DecisionWhereUniqueInput
    create: XOR<DecisionCreateWithoutUsuarioInput, DecisionUncheckedCreateWithoutUsuarioInput>
  }

  export type DecisionCreateManyUsuarioInputEnvelope = {
    data: DecisionCreateManyUsuarioInput | DecisionCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type TokenRecuperacionCreateWithoutUsuarioInput = {
    id?: string
    token: string
    expiraEn: Date | string
    usado?: boolean
    creadoEn?: Date | string
  }

  export type TokenRecuperacionUncheckedCreateWithoutUsuarioInput = {
    id?: string
    token: string
    expiraEn: Date | string
    usado?: boolean
    creadoEn?: Date | string
  }

  export type TokenRecuperacionCreateOrConnectWithoutUsuarioInput = {
    where: TokenRecuperacionWhereUniqueInput
    create: XOR<TokenRecuperacionCreateWithoutUsuarioInput, TokenRecuperacionUncheckedCreateWithoutUsuarioInput>
  }

  export type TokenRecuperacionCreateManyUsuarioInputEnvelope = {
    data: TokenRecuperacionCreateManyUsuarioInput | TokenRecuperacionCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type CambioRolCreateWithoutUsuarioInput = {
    id?: string
    rolAnterior: $Enums.Rol
    rolNuevo: $Enums.Rol
    motivo?: string | null
    cambiadoPorId: string
    creadoEn?: Date | string
  }

  export type CambioRolUncheckedCreateWithoutUsuarioInput = {
    id?: string
    rolAnterior: $Enums.Rol
    rolNuevo: $Enums.Rol
    motivo?: string | null
    cambiadoPorId: string
    creadoEn?: Date | string
  }

  export type CambioRolCreateOrConnectWithoutUsuarioInput = {
    where: CambioRolWhereUniqueInput
    create: XOR<CambioRolCreateWithoutUsuarioInput, CambioRolUncheckedCreateWithoutUsuarioInput>
  }

  export type CambioRolCreateManyUsuarioInputEnvelope = {
    data: CambioRolCreateManyUsuarioInput | CambioRolCreateManyUsuarioInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithoutUsuariosCreadosInput = {
    update: XOR<UsuarioUpdateWithoutUsuariosCreadosInput, UsuarioUncheckedUpdateWithoutUsuariosCreadosInput>
    create: XOR<UsuarioCreateWithoutUsuariosCreadosInput, UsuarioUncheckedCreateWithoutUsuariosCreadosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutUsuariosCreadosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutUsuariosCreadosInput, UsuarioUncheckedUpdateWithoutUsuariosCreadosInput>
  }

  export type UsuarioUpdateWithoutUsuariosCreadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPor?: UsuarioUpdateOneWithoutUsuariosCreadosNestedInput
    passwordHistorial?: PasswordHistorialUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutUsuariosCreadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    passwordHistorial?: PasswordHistorialUncheckedUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUncheckedUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUncheckedUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUncheckedUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUncheckedUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUncheckedUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUncheckedUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUncheckedUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUpsertWithWhereUniqueWithoutCreadoPorInput = {
    where: UsuarioWhereUniqueInput
    update: XOR<UsuarioUpdateWithoutCreadoPorInput, UsuarioUncheckedUpdateWithoutCreadoPorInput>
    create: XOR<UsuarioCreateWithoutCreadoPorInput, UsuarioUncheckedCreateWithoutCreadoPorInput>
  }

  export type UsuarioUpdateWithWhereUniqueWithoutCreadoPorInput = {
    where: UsuarioWhereUniqueInput
    data: XOR<UsuarioUpdateWithoutCreadoPorInput, UsuarioUncheckedUpdateWithoutCreadoPorInput>
  }

  export type UsuarioUpdateManyWithWhereWithoutCreadoPorInput = {
    where: UsuarioScalarWhereInput
    data: XOR<UsuarioUpdateManyMutationInput, UsuarioUncheckedUpdateManyWithoutCreadoPorInput>
  }

  export type UsuarioScalarWhereInput = {
    AND?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    OR?: UsuarioScalarWhereInput[]
    NOT?: UsuarioScalarWhereInput | UsuarioScalarWhereInput[]
    id?: StringFilter<"Usuario"> | string
    cedula?: StringFilter<"Usuario"> | string
    email?: StringFilter<"Usuario"> | string
    nombreCompleto?: StringFilter<"Usuario"> | string
    passwordHash?: StringFilter<"Usuario"> | string
    rol?: EnumRolFilter<"Usuario"> | $Enums.Rol
    estado?: EnumEstadoUsuarioFilter<"Usuario"> | $Enums.EstadoUsuario
    mfaSecret?: StringNullableFilter<"Usuario"> | string | null
    mfaHabilitado?: BoolFilter<"Usuario"> | boolean
    intentosFallidos?: IntFilter<"Usuario"> | number
    bloqueadoHasta?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    ultimoAcceso?: DateTimeNullableFilter<"Usuario"> | Date | string | null
    creadoEn?: DateTimeFilter<"Usuario"> | Date | string
    actualizadoEn?: DateTimeFilter<"Usuario"> | Date | string
    creadoPorId?: StringNullableFilter<"Usuario"> | string | null
  }

  export type PasswordHistorialUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: PasswordHistorialWhereUniqueInput
    update: XOR<PasswordHistorialUpdateWithoutUsuarioInput, PasswordHistorialUncheckedUpdateWithoutUsuarioInput>
    create: XOR<PasswordHistorialCreateWithoutUsuarioInput, PasswordHistorialUncheckedCreateWithoutUsuarioInput>
  }

  export type PasswordHistorialUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: PasswordHistorialWhereUniqueInput
    data: XOR<PasswordHistorialUpdateWithoutUsuarioInput, PasswordHistorialUncheckedUpdateWithoutUsuarioInput>
  }

  export type PasswordHistorialUpdateManyWithWhereWithoutUsuarioInput = {
    where: PasswordHistorialScalarWhereInput
    data: XOR<PasswordHistorialUpdateManyMutationInput, PasswordHistorialUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type PasswordHistorialScalarWhereInput = {
    AND?: PasswordHistorialScalarWhereInput | PasswordHistorialScalarWhereInput[]
    OR?: PasswordHistorialScalarWhereInput[]
    NOT?: PasswordHistorialScalarWhereInput | PasswordHistorialScalarWhereInput[]
    id?: StringFilter<"PasswordHistorial"> | string
    usuarioId?: StringFilter<"PasswordHistorial"> | string
    passwordHash?: StringFilter<"PasswordHistorial"> | string
    creadoEn?: DateTimeFilter<"PasswordHistorial"> | Date | string
  }

  export type SesionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: SesionWhereUniqueInput
    update: XOR<SesionUpdateWithoutUsuarioInput, SesionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<SesionCreateWithoutUsuarioInput, SesionUncheckedCreateWithoutUsuarioInput>
  }

  export type SesionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: SesionWhereUniqueInput
    data: XOR<SesionUpdateWithoutUsuarioInput, SesionUncheckedUpdateWithoutUsuarioInput>
  }

  export type SesionUpdateManyWithWhereWithoutUsuarioInput = {
    where: SesionScalarWhereInput
    data: XOR<SesionUpdateManyMutationInput, SesionUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type SesionScalarWhereInput = {
    AND?: SesionScalarWhereInput | SesionScalarWhereInput[]
    OR?: SesionScalarWhereInput[]
    NOT?: SesionScalarWhereInput | SesionScalarWhereInput[]
    id?: StringFilter<"Sesion"> | string
    usuarioId?: StringFilter<"Sesion"> | string
    tokenHash?: StringFilter<"Sesion"> | string
    ipAddress?: StringFilter<"Sesion"> | string
    userAgent?: StringFilter<"Sesion"> | string
    expiraEn?: DateTimeFilter<"Sesion"> | Date | string
    creadoEn?: DateTimeFilter<"Sesion"> | Date | string
    ultimaActividad?: DateTimeFilter<"Sesion"> | Date | string
  }

  export type ProcesoUpsertWithWhereUniqueWithoutBeneficiarioInput = {
    where: ProcesoWhereUniqueInput
    update: XOR<ProcesoUpdateWithoutBeneficiarioInput, ProcesoUncheckedUpdateWithoutBeneficiarioInput>
    create: XOR<ProcesoCreateWithoutBeneficiarioInput, ProcesoUncheckedCreateWithoutBeneficiarioInput>
  }

  export type ProcesoUpdateWithWhereUniqueWithoutBeneficiarioInput = {
    where: ProcesoWhereUniqueInput
    data: XOR<ProcesoUpdateWithoutBeneficiarioInput, ProcesoUncheckedUpdateWithoutBeneficiarioInput>
  }

  export type ProcesoUpdateManyWithWhereWithoutBeneficiarioInput = {
    where: ProcesoScalarWhereInput
    data: XOR<ProcesoUpdateManyMutationInput, ProcesoUncheckedUpdateManyWithoutBeneficiarioInput>
  }

  export type ProcesoScalarWhereInput = {
    AND?: ProcesoScalarWhereInput | ProcesoScalarWhereInput[]
    OR?: ProcesoScalarWhereInput[]
    NOT?: ProcesoScalarWhereInput | ProcesoScalarWhereInput[]
    id?: StringFilter<"Proceso"> | string
    codigo?: StringFilter<"Proceso"> | string
    beneficiarioId?: StringFilter<"Proceso"> | string
    arrendadorId?: StringNullableFilter<"Proceso"> | string | null
    estado?: EnumEstadoProcesoFilter<"Proceso"> | $Enums.EstadoProceso
    formulario?: JsonNullableFilter<"Proceso">
    pdfPath?: StringNullableFilter<"Proceso"> | string | null
    pdfHash?: StringNullableFilter<"Proceso"> | string | null
    pdfVersion?: IntFilter<"Proceso"> | number
    firmado?: BoolFilter<"Proceso"> | boolean
    firmadoEn?: DateTimeNullableFilter<"Proceso"> | Date | string | null
    firmadoPorId?: StringNullableFilter<"Proceso"> | string | null
    firmaHash?: StringNullableFilter<"Proceso"> | string | null
    firmaIp?: StringNullableFilter<"Proceso"> | string | null
    firmaUserAgent?: StringNullableFilter<"Proceso"> | string | null
    cerradoEn?: DateTimeNullableFilter<"Proceso"> | Date | string | null
    cerradoPorId?: StringNullableFilter<"Proceso"> | string | null
    creadoEn?: DateTimeFilter<"Proceso"> | Date | string
    actualizadoEn?: DateTimeFilter<"Proceso"> | Date | string
    enviadoEn?: DateTimeNullableFilter<"Proceso"> | Date | string | null
  }

  export type ProcesoUpsertWithWhereUniqueWithoutArrendadorInput = {
    where: ProcesoWhereUniqueInput
    update: XOR<ProcesoUpdateWithoutArrendadorInput, ProcesoUncheckedUpdateWithoutArrendadorInput>
    create: XOR<ProcesoCreateWithoutArrendadorInput, ProcesoUncheckedCreateWithoutArrendadorInput>
  }

  export type ProcesoUpdateWithWhereUniqueWithoutArrendadorInput = {
    where: ProcesoWhereUniqueInput
    data: XOR<ProcesoUpdateWithoutArrendadorInput, ProcesoUncheckedUpdateWithoutArrendadorInput>
  }

  export type ProcesoUpdateManyWithWhereWithoutArrendadorInput = {
    where: ProcesoScalarWhereInput
    data: XOR<ProcesoUpdateManyMutationInput, ProcesoUncheckedUpdateManyWithoutArrendadorInput>
  }

  export type DocumentoUpsertWithWhereUniqueWithoutCargadoPorInput = {
    where: DocumentoWhereUniqueInput
    update: XOR<DocumentoUpdateWithoutCargadoPorInput, DocumentoUncheckedUpdateWithoutCargadoPorInput>
    create: XOR<DocumentoCreateWithoutCargadoPorInput, DocumentoUncheckedCreateWithoutCargadoPorInput>
  }

  export type DocumentoUpdateWithWhereUniqueWithoutCargadoPorInput = {
    where: DocumentoWhereUniqueInput
    data: XOR<DocumentoUpdateWithoutCargadoPorInput, DocumentoUncheckedUpdateWithoutCargadoPorInput>
  }

  export type DocumentoUpdateManyWithWhereWithoutCargadoPorInput = {
    where: DocumentoScalarWhereInput
    data: XOR<DocumentoUpdateManyMutationInput, DocumentoUncheckedUpdateManyWithoutCargadoPorInput>
  }

  export type DocumentoScalarWhereInput = {
    AND?: DocumentoScalarWhereInput | DocumentoScalarWhereInput[]
    OR?: DocumentoScalarWhereInput[]
    NOT?: DocumentoScalarWhereInput | DocumentoScalarWhereInput[]
    id?: StringFilter<"Documento"> | string
    procesoId?: StringFilter<"Documento"> | string
    catalogoId?: StringFilter<"Documento"> | string
    nombreOriginal?: StringFilter<"Documento"> | string
    nombreAlmacenado?: StringFilter<"Documento"> | string
    rutaArchivo?: StringFilter<"Documento"> | string
    mimeType?: StringFilter<"Documento"> | string
    tamanoBytes?: IntFilter<"Documento"> | number
    hashArchivo?: StringFilter<"Documento"> | string
    estado?: EnumEstadoDocumentoFilter<"Documento"> | $Enums.EstadoDocumento
    validadoPorId?: StringNullableFilter<"Documento"> | string | null
    validadoEn?: DateTimeNullableFilter<"Documento"> | Date | string | null
    motivoRechazo?: StringNullableFilter<"Documento"> | string | null
    version?: IntFilter<"Documento"> | number
    esActivo?: BoolFilter<"Documento"> | boolean
    creadoEn?: DateTimeFilter<"Documento"> | Date | string
    cargadoPorId?: StringFilter<"Documento"> | string
  }

  export type DocumentoUpsertWithWhereUniqueWithoutValidadoPorInput = {
    where: DocumentoWhereUniqueInput
    update: XOR<DocumentoUpdateWithoutValidadoPorInput, DocumentoUncheckedUpdateWithoutValidadoPorInput>
    create: XOR<DocumentoCreateWithoutValidadoPorInput, DocumentoUncheckedCreateWithoutValidadoPorInput>
  }

  export type DocumentoUpdateWithWhereUniqueWithoutValidadoPorInput = {
    where: DocumentoWhereUniqueInput
    data: XOR<DocumentoUpdateWithoutValidadoPorInput, DocumentoUncheckedUpdateWithoutValidadoPorInput>
  }

  export type DocumentoUpdateManyWithWhereWithoutValidadoPorInput = {
    where: DocumentoScalarWhereInput
    data: XOR<DocumentoUpdateManyMutationInput, DocumentoUncheckedUpdateManyWithoutValidadoPorInput>
  }

  export type EventoAuditoriaUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: EventoAuditoriaWhereUniqueInput
    update: XOR<EventoAuditoriaUpdateWithoutUsuarioInput, EventoAuditoriaUncheckedUpdateWithoutUsuarioInput>
    create: XOR<EventoAuditoriaCreateWithoutUsuarioInput, EventoAuditoriaUncheckedCreateWithoutUsuarioInput>
  }

  export type EventoAuditoriaUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: EventoAuditoriaWhereUniqueInput
    data: XOR<EventoAuditoriaUpdateWithoutUsuarioInput, EventoAuditoriaUncheckedUpdateWithoutUsuarioInput>
  }

  export type EventoAuditoriaUpdateManyWithWhereWithoutUsuarioInput = {
    where: EventoAuditoriaScalarWhereInput
    data: XOR<EventoAuditoriaUpdateManyMutationInput, EventoAuditoriaUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type EventoAuditoriaScalarWhereInput = {
    AND?: EventoAuditoriaScalarWhereInput | EventoAuditoriaScalarWhereInput[]
    OR?: EventoAuditoriaScalarWhereInput[]
    NOT?: EventoAuditoriaScalarWhereInput | EventoAuditoriaScalarWhereInput[]
    id?: StringFilter<"EventoAuditoria"> | string
    procesoId?: StringNullableFilter<"EventoAuditoria"> | string | null
    usuarioId?: StringNullableFilter<"EventoAuditoria"> | string | null
    tipo?: EnumTipoEventoFilter<"EventoAuditoria"> | $Enums.TipoEvento
    descripcion?: StringFilter<"EventoAuditoria"> | string
    detalles?: JsonNullableFilter<"EventoAuditoria">
    ipAddress?: StringFilter<"EventoAuditoria"> | string
    userAgent?: StringFilter<"EventoAuditoria"> | string
    creadoEn?: DateTimeFilter<"EventoAuditoria"> | Date | string
  }

  export type DecisionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: DecisionWhereUniqueInput
    update: XOR<DecisionUpdateWithoutUsuarioInput, DecisionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<DecisionCreateWithoutUsuarioInput, DecisionUncheckedCreateWithoutUsuarioInput>
  }

  export type DecisionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: DecisionWhereUniqueInput
    data: XOR<DecisionUpdateWithoutUsuarioInput, DecisionUncheckedUpdateWithoutUsuarioInput>
  }

  export type DecisionUpdateManyWithWhereWithoutUsuarioInput = {
    where: DecisionScalarWhereInput
    data: XOR<DecisionUpdateManyMutationInput, DecisionUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type DecisionScalarWhereInput = {
    AND?: DecisionScalarWhereInput | DecisionScalarWhereInput[]
    OR?: DecisionScalarWhereInput[]
    NOT?: DecisionScalarWhereInput | DecisionScalarWhereInput[]
    id?: StringFilter<"Decision"> | string
    procesoId?: StringFilter<"Decision"> | string
    estadoAnterior?: EnumEstadoProcesoFilter<"Decision"> | $Enums.EstadoProceso
    estadoNuevo?: EnumEstadoProcesoFilter<"Decision"> | $Enums.EstadoProceso
    aprobado?: BoolFilter<"Decision"> | boolean
    motivo?: StringFilter<"Decision"> | string
    usuarioId?: StringFilter<"Decision"> | string
    rol?: EnumRolFilter<"Decision"> | $Enums.Rol
    ipAddress?: StringFilter<"Decision"> | string
    userAgent?: StringFilter<"Decision"> | string
    creadoEn?: DateTimeFilter<"Decision"> | Date | string
  }

  export type TokenRecuperacionUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: TokenRecuperacionWhereUniqueInput
    update: XOR<TokenRecuperacionUpdateWithoutUsuarioInput, TokenRecuperacionUncheckedUpdateWithoutUsuarioInput>
    create: XOR<TokenRecuperacionCreateWithoutUsuarioInput, TokenRecuperacionUncheckedCreateWithoutUsuarioInput>
  }

  export type TokenRecuperacionUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: TokenRecuperacionWhereUniqueInput
    data: XOR<TokenRecuperacionUpdateWithoutUsuarioInput, TokenRecuperacionUncheckedUpdateWithoutUsuarioInput>
  }

  export type TokenRecuperacionUpdateManyWithWhereWithoutUsuarioInput = {
    where: TokenRecuperacionScalarWhereInput
    data: XOR<TokenRecuperacionUpdateManyMutationInput, TokenRecuperacionUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type TokenRecuperacionScalarWhereInput = {
    AND?: TokenRecuperacionScalarWhereInput | TokenRecuperacionScalarWhereInput[]
    OR?: TokenRecuperacionScalarWhereInput[]
    NOT?: TokenRecuperacionScalarWhereInput | TokenRecuperacionScalarWhereInput[]
    id?: StringFilter<"TokenRecuperacion"> | string
    usuarioId?: StringFilter<"TokenRecuperacion"> | string
    token?: StringFilter<"TokenRecuperacion"> | string
    expiraEn?: DateTimeFilter<"TokenRecuperacion"> | Date | string
    usado?: BoolFilter<"TokenRecuperacion"> | boolean
    creadoEn?: DateTimeFilter<"TokenRecuperacion"> | Date | string
  }

  export type CambioRolUpsertWithWhereUniqueWithoutUsuarioInput = {
    where: CambioRolWhereUniqueInput
    update: XOR<CambioRolUpdateWithoutUsuarioInput, CambioRolUncheckedUpdateWithoutUsuarioInput>
    create: XOR<CambioRolCreateWithoutUsuarioInput, CambioRolUncheckedCreateWithoutUsuarioInput>
  }

  export type CambioRolUpdateWithWhereUniqueWithoutUsuarioInput = {
    where: CambioRolWhereUniqueInput
    data: XOR<CambioRolUpdateWithoutUsuarioInput, CambioRolUncheckedUpdateWithoutUsuarioInput>
  }

  export type CambioRolUpdateManyWithWhereWithoutUsuarioInput = {
    where: CambioRolScalarWhereInput
    data: XOR<CambioRolUpdateManyMutationInput, CambioRolUncheckedUpdateManyWithoutUsuarioInput>
  }

  export type CambioRolScalarWhereInput = {
    AND?: CambioRolScalarWhereInput | CambioRolScalarWhereInput[]
    OR?: CambioRolScalarWhereInput[]
    NOT?: CambioRolScalarWhereInput | CambioRolScalarWhereInput[]
    id?: StringFilter<"CambioRol"> | string
    usuarioId?: StringFilter<"CambioRol"> | string
    rolAnterior?: EnumRolFilter<"CambioRol"> | $Enums.Rol
    rolNuevo?: EnumRolFilter<"CambioRol"> | $Enums.Rol
    motivo?: StringNullableFilter<"CambioRol"> | string | null
    cambiadoPorId?: StringFilter<"CambioRol"> | string
    creadoEn?: DateTimeFilter<"CambioRol"> | Date | string
  }

  export type UsuarioCreateWithoutPasswordHistorialInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPor?: UsuarioCreateNestedOneWithoutUsuariosCreadosInput
    usuariosCreados?: UsuarioCreateNestedManyWithoutCreadoPorInput
    sesiones?: SesionCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutPasswordHistorialInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPorId?: string | null
    usuariosCreados?: UsuarioUncheckedCreateNestedManyWithoutCreadoPorInput
    sesiones?: SesionUncheckedCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoUncheckedCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoUncheckedCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoUncheckedCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoUncheckedCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionUncheckedCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionUncheckedCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutPasswordHistorialInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutPasswordHistorialInput, UsuarioUncheckedCreateWithoutPasswordHistorialInput>
  }

  export type UsuarioUpsertWithoutPasswordHistorialInput = {
    update: XOR<UsuarioUpdateWithoutPasswordHistorialInput, UsuarioUncheckedUpdateWithoutPasswordHistorialInput>
    create: XOR<UsuarioCreateWithoutPasswordHistorialInput, UsuarioUncheckedCreateWithoutPasswordHistorialInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutPasswordHistorialInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutPasswordHistorialInput, UsuarioUncheckedUpdateWithoutPasswordHistorialInput>
  }

  export type UsuarioUpdateWithoutPasswordHistorialInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPor?: UsuarioUpdateOneWithoutUsuariosCreadosNestedInput
    usuariosCreados?: UsuarioUpdateManyWithoutCreadoPorNestedInput
    sesiones?: SesionUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutPasswordHistorialInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosCreados?: UsuarioUncheckedUpdateManyWithoutCreadoPorNestedInput
    sesiones?: SesionUncheckedUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUncheckedUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUncheckedUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUncheckedUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUncheckedUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUncheckedUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUncheckedUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateWithoutTokenRecuperacionInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPor?: UsuarioCreateNestedOneWithoutUsuariosCreadosInput
    usuariosCreados?: UsuarioCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutTokenRecuperacionInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPorId?: string | null
    usuariosCreados?: UsuarioUncheckedCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialUncheckedCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionUncheckedCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoUncheckedCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoUncheckedCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoUncheckedCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoUncheckedCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionUncheckedCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutTokenRecuperacionInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutTokenRecuperacionInput, UsuarioUncheckedCreateWithoutTokenRecuperacionInput>
  }

  export type UsuarioUpsertWithoutTokenRecuperacionInput = {
    update: XOR<UsuarioUpdateWithoutTokenRecuperacionInput, UsuarioUncheckedUpdateWithoutTokenRecuperacionInput>
    create: XOR<UsuarioCreateWithoutTokenRecuperacionInput, UsuarioUncheckedCreateWithoutTokenRecuperacionInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutTokenRecuperacionInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutTokenRecuperacionInput, UsuarioUncheckedUpdateWithoutTokenRecuperacionInput>
  }

  export type UsuarioUpdateWithoutTokenRecuperacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPor?: UsuarioUpdateOneWithoutUsuariosCreadosNestedInput
    usuariosCreados?: UsuarioUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutTokenRecuperacionInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosCreados?: UsuarioUncheckedUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUncheckedUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUncheckedUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUncheckedUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUncheckedUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUncheckedUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUncheckedUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUncheckedUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateWithoutSesionesInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPor?: UsuarioCreateNestedOneWithoutUsuariosCreadosInput
    usuariosCreados?: UsuarioCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutSesionesInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPorId?: string | null
    usuariosCreados?: UsuarioUncheckedCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialUncheckedCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoUncheckedCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoUncheckedCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoUncheckedCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoUncheckedCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionUncheckedCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionUncheckedCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutSesionesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutSesionesInput, UsuarioUncheckedCreateWithoutSesionesInput>
  }

  export type UsuarioUpsertWithoutSesionesInput = {
    update: XOR<UsuarioUpdateWithoutSesionesInput, UsuarioUncheckedUpdateWithoutSesionesInput>
    create: XOR<UsuarioCreateWithoutSesionesInput, UsuarioUncheckedCreateWithoutSesionesInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutSesionesInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutSesionesInput, UsuarioUncheckedUpdateWithoutSesionesInput>
  }

  export type UsuarioUpdateWithoutSesionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPor?: UsuarioUpdateOneWithoutUsuariosCreadosNestedInput
    usuariosCreados?: UsuarioUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutSesionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosCreados?: UsuarioUncheckedUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUncheckedUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUncheckedUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUncheckedUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUncheckedUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUncheckedUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUncheckedUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUncheckedUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateWithoutCambiosRolInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPor?: UsuarioCreateNestedOneWithoutUsuariosCreadosInput
    usuariosCreados?: UsuarioCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutCambiosRolInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPorId?: string | null
    usuariosCreados?: UsuarioUncheckedCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialUncheckedCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionUncheckedCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoUncheckedCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoUncheckedCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoUncheckedCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoUncheckedCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionUncheckedCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutCambiosRolInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutCambiosRolInput, UsuarioUncheckedCreateWithoutCambiosRolInput>
  }

  export type UsuarioUpsertWithoutCambiosRolInput = {
    update: XOR<UsuarioUpdateWithoutCambiosRolInput, UsuarioUncheckedUpdateWithoutCambiosRolInput>
    create: XOR<UsuarioCreateWithoutCambiosRolInput, UsuarioUncheckedCreateWithoutCambiosRolInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutCambiosRolInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutCambiosRolInput, UsuarioUncheckedUpdateWithoutCambiosRolInput>
  }

  export type UsuarioUpdateWithoutCambiosRolInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPor?: UsuarioUpdateOneWithoutUsuariosCreadosNestedInput
    usuariosCreados?: UsuarioUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutCambiosRolInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosCreados?: UsuarioUncheckedUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUncheckedUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUncheckedUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUncheckedUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUncheckedUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUncheckedUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUncheckedUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUncheckedUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type DocumentoCreateWithoutCatalogoInput = {
    id?: string
    nombreOriginal: string
    nombreAlmacenado: string
    rutaArchivo: string
    mimeType: string
    tamanoBytes: number
    hashArchivo: string
    estado?: $Enums.EstadoDocumento
    validadoEn?: Date | string | null
    motivoRechazo?: string | null
    version?: number
    esActivo?: boolean
    creadoEn?: Date | string
    proceso: ProcesoCreateNestedOneWithoutDocumentosInput
    cargadoPor: UsuarioCreateNestedOneWithoutDocumentosCargadosInput
    validadoPor?: UsuarioCreateNestedOneWithoutDocumentosValidadosInput
    descargas?: RegistroDescargaCreateNestedManyWithoutDocumentoInput
  }

  export type DocumentoUncheckedCreateWithoutCatalogoInput = {
    id?: string
    procesoId: string
    nombreOriginal: string
    nombreAlmacenado: string
    rutaArchivo: string
    mimeType: string
    tamanoBytes: number
    hashArchivo: string
    estado?: $Enums.EstadoDocumento
    validadoPorId?: string | null
    validadoEn?: Date | string | null
    motivoRechazo?: string | null
    version?: number
    esActivo?: boolean
    creadoEn?: Date | string
    cargadoPorId: string
    descargas?: RegistroDescargaUncheckedCreateNestedManyWithoutDocumentoInput
  }

  export type DocumentoCreateOrConnectWithoutCatalogoInput = {
    where: DocumentoWhereUniqueInput
    create: XOR<DocumentoCreateWithoutCatalogoInput, DocumentoUncheckedCreateWithoutCatalogoInput>
  }

  export type DocumentoCreateManyCatalogoInputEnvelope = {
    data: DocumentoCreateManyCatalogoInput | DocumentoCreateManyCatalogoInput[]
    skipDuplicates?: boolean
  }

  export type DocumentoUpsertWithWhereUniqueWithoutCatalogoInput = {
    where: DocumentoWhereUniqueInput
    update: XOR<DocumentoUpdateWithoutCatalogoInput, DocumentoUncheckedUpdateWithoutCatalogoInput>
    create: XOR<DocumentoCreateWithoutCatalogoInput, DocumentoUncheckedCreateWithoutCatalogoInput>
  }

  export type DocumentoUpdateWithWhereUniqueWithoutCatalogoInput = {
    where: DocumentoWhereUniqueInput
    data: XOR<DocumentoUpdateWithoutCatalogoInput, DocumentoUncheckedUpdateWithoutCatalogoInput>
  }

  export type DocumentoUpdateManyWithWhereWithoutCatalogoInput = {
    where: DocumentoScalarWhereInput
    data: XOR<DocumentoUpdateManyMutationInput, DocumentoUncheckedUpdateManyWithoutCatalogoInput>
  }

  export type UsuarioCreateWithoutProcesosBeneficiarioInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPor?: UsuarioCreateNestedOneWithoutUsuariosCreadosInput
    usuariosCreados?: UsuarioCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionCreateNestedManyWithoutUsuarioInput
    procesosArrendador?: ProcesoCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutProcesosBeneficiarioInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPorId?: string | null
    usuariosCreados?: UsuarioUncheckedCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialUncheckedCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionUncheckedCreateNestedManyWithoutUsuarioInput
    procesosArrendador?: ProcesoUncheckedCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoUncheckedCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoUncheckedCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionUncheckedCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionUncheckedCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutProcesosBeneficiarioInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutProcesosBeneficiarioInput, UsuarioUncheckedCreateWithoutProcesosBeneficiarioInput>
  }

  export type UsuarioCreateWithoutProcesosArrendadorInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPor?: UsuarioCreateNestedOneWithoutUsuariosCreadosInput
    usuariosCreados?: UsuarioCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoCreateNestedManyWithoutBeneficiarioInput
    documentosCargados?: DocumentoCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutProcesosArrendadorInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPorId?: string | null
    usuariosCreados?: UsuarioUncheckedCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialUncheckedCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionUncheckedCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoUncheckedCreateNestedManyWithoutBeneficiarioInput
    documentosCargados?: DocumentoUncheckedCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoUncheckedCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionUncheckedCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionUncheckedCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutProcesosArrendadorInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutProcesosArrendadorInput, UsuarioUncheckedCreateWithoutProcesosArrendadorInput>
  }

  export type DocumentoCreateWithoutProcesoInput = {
    id?: string
    nombreOriginal: string
    nombreAlmacenado: string
    rutaArchivo: string
    mimeType: string
    tamanoBytes: number
    hashArchivo: string
    estado?: $Enums.EstadoDocumento
    validadoEn?: Date | string | null
    motivoRechazo?: string | null
    version?: number
    esActivo?: boolean
    creadoEn?: Date | string
    catalogo: CatalogoDocumentoCreateNestedOneWithoutDocumentosInput
    cargadoPor: UsuarioCreateNestedOneWithoutDocumentosCargadosInput
    validadoPor?: UsuarioCreateNestedOneWithoutDocumentosValidadosInput
    descargas?: RegistroDescargaCreateNestedManyWithoutDocumentoInput
  }

  export type DocumentoUncheckedCreateWithoutProcesoInput = {
    id?: string
    catalogoId: string
    nombreOriginal: string
    nombreAlmacenado: string
    rutaArchivo: string
    mimeType: string
    tamanoBytes: number
    hashArchivo: string
    estado?: $Enums.EstadoDocumento
    validadoPorId?: string | null
    validadoEn?: Date | string | null
    motivoRechazo?: string | null
    version?: number
    esActivo?: boolean
    creadoEn?: Date | string
    cargadoPorId: string
    descargas?: RegistroDescargaUncheckedCreateNestedManyWithoutDocumentoInput
  }

  export type DocumentoCreateOrConnectWithoutProcesoInput = {
    where: DocumentoWhereUniqueInput
    create: XOR<DocumentoCreateWithoutProcesoInput, DocumentoUncheckedCreateWithoutProcesoInput>
  }

  export type DocumentoCreateManyProcesoInputEnvelope = {
    data: DocumentoCreateManyProcesoInput | DocumentoCreateManyProcesoInput[]
    skipDuplicates?: boolean
  }

  export type EventoAuditoriaCreateWithoutProcesoInput = {
    id?: string
    tipo: $Enums.TipoEvento
    descripcion: string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
    usuario?: UsuarioCreateNestedOneWithoutEventosAuditoriaInput
  }

  export type EventoAuditoriaUncheckedCreateWithoutProcesoInput = {
    id?: string
    usuarioId?: string | null
    tipo: $Enums.TipoEvento
    descripcion: string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
  }

  export type EventoAuditoriaCreateOrConnectWithoutProcesoInput = {
    where: EventoAuditoriaWhereUniqueInput
    create: XOR<EventoAuditoriaCreateWithoutProcesoInput, EventoAuditoriaUncheckedCreateWithoutProcesoInput>
  }

  export type EventoAuditoriaCreateManyProcesoInputEnvelope = {
    data: EventoAuditoriaCreateManyProcesoInput | EventoAuditoriaCreateManyProcesoInput[]
    skipDuplicates?: boolean
  }

  export type DecisionCreateWithoutProcesoInput = {
    id?: string
    estadoAnterior: $Enums.EstadoProceso
    estadoNuevo: $Enums.EstadoProceso
    aprobado: boolean
    motivo: string
    rol: $Enums.Rol
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
    usuario: UsuarioCreateNestedOneWithoutDecisionesInput
  }

  export type DecisionUncheckedCreateWithoutProcesoInput = {
    id?: string
    estadoAnterior: $Enums.EstadoProceso
    estadoNuevo: $Enums.EstadoProceso
    aprobado: boolean
    motivo: string
    usuarioId: string
    rol: $Enums.Rol
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
  }

  export type DecisionCreateOrConnectWithoutProcesoInput = {
    where: DecisionWhereUniqueInput
    create: XOR<DecisionCreateWithoutProcesoInput, DecisionUncheckedCreateWithoutProcesoInput>
  }

  export type DecisionCreateManyProcesoInputEnvelope = {
    data: DecisionCreateManyProcesoInput | DecisionCreateManyProcesoInput[]
    skipDuplicates?: boolean
  }

  export type HistorialPdfCreateWithoutProcesoInput = {
    id?: string
    version: number
    pdfPath: string
    pdfHash: string
    creadoEn?: Date | string
  }

  export type HistorialPdfUncheckedCreateWithoutProcesoInput = {
    id?: string
    version: number
    pdfPath: string
    pdfHash: string
    creadoEn?: Date | string
  }

  export type HistorialPdfCreateOrConnectWithoutProcesoInput = {
    where: HistorialPdfWhereUniqueInput
    create: XOR<HistorialPdfCreateWithoutProcesoInput, HistorialPdfUncheckedCreateWithoutProcesoInput>
  }

  export type HistorialPdfCreateManyProcesoInputEnvelope = {
    data: HistorialPdfCreateManyProcesoInput | HistorialPdfCreateManyProcesoInput[]
    skipDuplicates?: boolean
  }

  export type UsuarioUpsertWithoutProcesosBeneficiarioInput = {
    update: XOR<UsuarioUpdateWithoutProcesosBeneficiarioInput, UsuarioUncheckedUpdateWithoutProcesosBeneficiarioInput>
    create: XOR<UsuarioCreateWithoutProcesosBeneficiarioInput, UsuarioUncheckedCreateWithoutProcesosBeneficiarioInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutProcesosBeneficiarioInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutProcesosBeneficiarioInput, UsuarioUncheckedUpdateWithoutProcesosBeneficiarioInput>
  }

  export type UsuarioUpdateWithoutProcesosBeneficiarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPor?: UsuarioUpdateOneWithoutUsuariosCreadosNestedInput
    usuariosCreados?: UsuarioUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUpdateManyWithoutUsuarioNestedInput
    procesosArrendador?: ProcesoUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutProcesosBeneficiarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosCreados?: UsuarioUncheckedUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUncheckedUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUncheckedUpdateManyWithoutUsuarioNestedInput
    procesosArrendador?: ProcesoUncheckedUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUncheckedUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUncheckedUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUncheckedUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUncheckedUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUpsertWithoutProcesosArrendadorInput = {
    update: XOR<UsuarioUpdateWithoutProcesosArrendadorInput, UsuarioUncheckedUpdateWithoutProcesosArrendadorInput>
    create: XOR<UsuarioCreateWithoutProcesosArrendadorInput, UsuarioUncheckedCreateWithoutProcesosArrendadorInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutProcesosArrendadorInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutProcesosArrendadorInput, UsuarioUncheckedUpdateWithoutProcesosArrendadorInput>
  }

  export type UsuarioUpdateWithoutProcesosArrendadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPor?: UsuarioUpdateOneWithoutUsuariosCreadosNestedInput
    usuariosCreados?: UsuarioUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUpdateManyWithoutBeneficiarioNestedInput
    documentosCargados?: DocumentoUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutProcesosArrendadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosCreados?: UsuarioUncheckedUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUncheckedUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUncheckedUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUncheckedUpdateManyWithoutBeneficiarioNestedInput
    documentosCargados?: DocumentoUncheckedUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUncheckedUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUncheckedUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUncheckedUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type DocumentoUpsertWithWhereUniqueWithoutProcesoInput = {
    where: DocumentoWhereUniqueInput
    update: XOR<DocumentoUpdateWithoutProcesoInput, DocumentoUncheckedUpdateWithoutProcesoInput>
    create: XOR<DocumentoCreateWithoutProcesoInput, DocumentoUncheckedCreateWithoutProcesoInput>
  }

  export type DocumentoUpdateWithWhereUniqueWithoutProcesoInput = {
    where: DocumentoWhereUniqueInput
    data: XOR<DocumentoUpdateWithoutProcesoInput, DocumentoUncheckedUpdateWithoutProcesoInput>
  }

  export type DocumentoUpdateManyWithWhereWithoutProcesoInput = {
    where: DocumentoScalarWhereInput
    data: XOR<DocumentoUpdateManyMutationInput, DocumentoUncheckedUpdateManyWithoutProcesoInput>
  }

  export type EventoAuditoriaUpsertWithWhereUniqueWithoutProcesoInput = {
    where: EventoAuditoriaWhereUniqueInput
    update: XOR<EventoAuditoriaUpdateWithoutProcesoInput, EventoAuditoriaUncheckedUpdateWithoutProcesoInput>
    create: XOR<EventoAuditoriaCreateWithoutProcesoInput, EventoAuditoriaUncheckedCreateWithoutProcesoInput>
  }

  export type EventoAuditoriaUpdateWithWhereUniqueWithoutProcesoInput = {
    where: EventoAuditoriaWhereUniqueInput
    data: XOR<EventoAuditoriaUpdateWithoutProcesoInput, EventoAuditoriaUncheckedUpdateWithoutProcesoInput>
  }

  export type EventoAuditoriaUpdateManyWithWhereWithoutProcesoInput = {
    where: EventoAuditoriaScalarWhereInput
    data: XOR<EventoAuditoriaUpdateManyMutationInput, EventoAuditoriaUncheckedUpdateManyWithoutProcesoInput>
  }

  export type DecisionUpsertWithWhereUniqueWithoutProcesoInput = {
    where: DecisionWhereUniqueInput
    update: XOR<DecisionUpdateWithoutProcesoInput, DecisionUncheckedUpdateWithoutProcesoInput>
    create: XOR<DecisionCreateWithoutProcesoInput, DecisionUncheckedCreateWithoutProcesoInput>
  }

  export type DecisionUpdateWithWhereUniqueWithoutProcesoInput = {
    where: DecisionWhereUniqueInput
    data: XOR<DecisionUpdateWithoutProcesoInput, DecisionUncheckedUpdateWithoutProcesoInput>
  }

  export type DecisionUpdateManyWithWhereWithoutProcesoInput = {
    where: DecisionScalarWhereInput
    data: XOR<DecisionUpdateManyMutationInput, DecisionUncheckedUpdateManyWithoutProcesoInput>
  }

  export type HistorialPdfUpsertWithWhereUniqueWithoutProcesoInput = {
    where: HistorialPdfWhereUniqueInput
    update: XOR<HistorialPdfUpdateWithoutProcesoInput, HistorialPdfUncheckedUpdateWithoutProcesoInput>
    create: XOR<HistorialPdfCreateWithoutProcesoInput, HistorialPdfUncheckedCreateWithoutProcesoInput>
  }

  export type HistorialPdfUpdateWithWhereUniqueWithoutProcesoInput = {
    where: HistorialPdfWhereUniqueInput
    data: XOR<HistorialPdfUpdateWithoutProcesoInput, HistorialPdfUncheckedUpdateWithoutProcesoInput>
  }

  export type HistorialPdfUpdateManyWithWhereWithoutProcesoInput = {
    where: HistorialPdfScalarWhereInput
    data: XOR<HistorialPdfUpdateManyMutationInput, HistorialPdfUncheckedUpdateManyWithoutProcesoInput>
  }

  export type HistorialPdfScalarWhereInput = {
    AND?: HistorialPdfScalarWhereInput | HistorialPdfScalarWhereInput[]
    OR?: HistorialPdfScalarWhereInput[]
    NOT?: HistorialPdfScalarWhereInput | HistorialPdfScalarWhereInput[]
    id?: StringFilter<"HistorialPdf"> | string
    procesoId?: StringFilter<"HistorialPdf"> | string
    version?: IntFilter<"HistorialPdf"> | number
    pdfPath?: StringFilter<"HistorialPdf"> | string
    pdfHash?: StringFilter<"HistorialPdf"> | string
    creadoEn?: DateTimeFilter<"HistorialPdf"> | Date | string
  }

  export type ProcesoCreateWithoutDocumentosInput = {
    id?: string
    codigo: string
    estado?: $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: string | null
    pdfHash?: string | null
    pdfVersion?: number
    firmado?: boolean
    firmadoEn?: Date | string | null
    firmadoPorId?: string | null
    firmaHash?: string | null
    firmaIp?: string | null
    firmaUserAgent?: string | null
    cerradoEn?: Date | string | null
    cerradoPorId?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    enviadoEn?: Date | string | null
    beneficiario: UsuarioCreateNestedOneWithoutProcesosBeneficiarioInput
    arrendador?: UsuarioCreateNestedOneWithoutProcesosArrendadorInput
    eventos?: EventoAuditoriaCreateNestedManyWithoutProcesoInput
    decisiones?: DecisionCreateNestedManyWithoutProcesoInput
    historialPdf?: HistorialPdfCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoUncheckedCreateWithoutDocumentosInput = {
    id?: string
    codigo: string
    beneficiarioId: string
    arrendadorId?: string | null
    estado?: $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: string | null
    pdfHash?: string | null
    pdfVersion?: number
    firmado?: boolean
    firmadoEn?: Date | string | null
    firmadoPorId?: string | null
    firmaHash?: string | null
    firmaIp?: string | null
    firmaUserAgent?: string | null
    cerradoEn?: Date | string | null
    cerradoPorId?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    enviadoEn?: Date | string | null
    eventos?: EventoAuditoriaUncheckedCreateNestedManyWithoutProcesoInput
    decisiones?: DecisionUncheckedCreateNestedManyWithoutProcesoInput
    historialPdf?: HistorialPdfUncheckedCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoCreateOrConnectWithoutDocumentosInput = {
    where: ProcesoWhereUniqueInput
    create: XOR<ProcesoCreateWithoutDocumentosInput, ProcesoUncheckedCreateWithoutDocumentosInput>
  }

  export type CatalogoDocumentoCreateWithoutDocumentosInput = {
    id?: string
    tipo: $Enums.TipoDocumento
    nombre: string
    descripcion?: string | null
    obligatorio?: boolean
    formatosPermitidos?: CatalogoDocumentoCreateformatosPermitidosInput | string[]
    tamanoMaximoMb?: number
    vigenciaDias?: number | null
    activo?: boolean
    orden?: number
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type CatalogoDocumentoUncheckedCreateWithoutDocumentosInput = {
    id?: string
    tipo: $Enums.TipoDocumento
    nombre: string
    descripcion?: string | null
    obligatorio?: boolean
    formatosPermitidos?: CatalogoDocumentoCreateformatosPermitidosInput | string[]
    tamanoMaximoMb?: number
    vigenciaDias?: number | null
    activo?: boolean
    orden?: number
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type CatalogoDocumentoCreateOrConnectWithoutDocumentosInput = {
    where: CatalogoDocumentoWhereUniqueInput
    create: XOR<CatalogoDocumentoCreateWithoutDocumentosInput, CatalogoDocumentoUncheckedCreateWithoutDocumentosInput>
  }

  export type UsuarioCreateWithoutDocumentosCargadosInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPor?: UsuarioCreateNestedOneWithoutUsuariosCreadosInput
    usuariosCreados?: UsuarioCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoCreateNestedManyWithoutArrendadorInput
    documentosValidados?: DocumentoCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutDocumentosCargadosInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPorId?: string | null
    usuariosCreados?: UsuarioUncheckedCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialUncheckedCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionUncheckedCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoUncheckedCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoUncheckedCreateNestedManyWithoutArrendadorInput
    documentosValidados?: DocumentoUncheckedCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionUncheckedCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionUncheckedCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutDocumentosCargadosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutDocumentosCargadosInput, UsuarioUncheckedCreateWithoutDocumentosCargadosInput>
  }

  export type UsuarioCreateWithoutDocumentosValidadosInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPor?: UsuarioCreateNestedOneWithoutUsuariosCreadosInput
    usuariosCreados?: UsuarioCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoCreateNestedManyWithoutCargadoPorInput
    eventosAuditoria?: EventoAuditoriaCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutDocumentosValidadosInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPorId?: string | null
    usuariosCreados?: UsuarioUncheckedCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialUncheckedCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionUncheckedCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoUncheckedCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoUncheckedCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoUncheckedCreateNestedManyWithoutCargadoPorInput
    eventosAuditoria?: EventoAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    decisiones?: DecisionUncheckedCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionUncheckedCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutDocumentosValidadosInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutDocumentosValidadosInput, UsuarioUncheckedCreateWithoutDocumentosValidadosInput>
  }

  export type RegistroDescargaCreateWithoutDocumentoInput = {
    id?: string
    usuarioId: string
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
  }

  export type RegistroDescargaUncheckedCreateWithoutDocumentoInput = {
    id?: string
    usuarioId: string
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
  }

  export type RegistroDescargaCreateOrConnectWithoutDocumentoInput = {
    where: RegistroDescargaWhereUniqueInput
    create: XOR<RegistroDescargaCreateWithoutDocumentoInput, RegistroDescargaUncheckedCreateWithoutDocumentoInput>
  }

  export type RegistroDescargaCreateManyDocumentoInputEnvelope = {
    data: RegistroDescargaCreateManyDocumentoInput | RegistroDescargaCreateManyDocumentoInput[]
    skipDuplicates?: boolean
  }

  export type ProcesoUpsertWithoutDocumentosInput = {
    update: XOR<ProcesoUpdateWithoutDocumentosInput, ProcesoUncheckedUpdateWithoutDocumentosInput>
    create: XOR<ProcesoCreateWithoutDocumentosInput, ProcesoUncheckedCreateWithoutDocumentosInput>
    where?: ProcesoWhereInput
  }

  export type ProcesoUpdateToOneWithWhereWithoutDocumentosInput = {
    where?: ProcesoWhereInput
    data: XOR<ProcesoUpdateWithoutDocumentosInput, ProcesoUncheckedUpdateWithoutDocumentosInput>
  }

  export type ProcesoUpdateWithoutDocumentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    pdfHash?: NullableStringFieldUpdateOperationsInput | string | null
    pdfVersion?: IntFieldUpdateOperationsInput | number
    firmado?: BoolFieldUpdateOperationsInput | boolean
    firmadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    firmaHash?: NullableStringFieldUpdateOperationsInput | string | null
    firmaIp?: NullableStringFieldUpdateOperationsInput | string | null
    firmaUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cerradoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cerradoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beneficiario?: UsuarioUpdateOneRequiredWithoutProcesosBeneficiarioNestedInput
    arrendador?: UsuarioUpdateOneWithoutProcesosArrendadorNestedInput
    eventos?: EventoAuditoriaUpdateManyWithoutProcesoNestedInput
    decisiones?: DecisionUpdateManyWithoutProcesoNestedInput
    historialPdf?: HistorialPdfUpdateManyWithoutProcesoNestedInput
  }

  export type ProcesoUncheckedUpdateWithoutDocumentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiarioId?: StringFieldUpdateOperationsInput | string
    arrendadorId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    pdfHash?: NullableStringFieldUpdateOperationsInput | string | null
    pdfVersion?: IntFieldUpdateOperationsInput | number
    firmado?: BoolFieldUpdateOperationsInput | boolean
    firmadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    firmaHash?: NullableStringFieldUpdateOperationsInput | string | null
    firmaIp?: NullableStringFieldUpdateOperationsInput | string | null
    firmaUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cerradoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cerradoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventos?: EventoAuditoriaUncheckedUpdateManyWithoutProcesoNestedInput
    decisiones?: DecisionUncheckedUpdateManyWithoutProcesoNestedInput
    historialPdf?: HistorialPdfUncheckedUpdateManyWithoutProcesoNestedInput
  }

  export type CatalogoDocumentoUpsertWithoutDocumentosInput = {
    update: XOR<CatalogoDocumentoUpdateWithoutDocumentosInput, CatalogoDocumentoUncheckedUpdateWithoutDocumentosInput>
    create: XOR<CatalogoDocumentoCreateWithoutDocumentosInput, CatalogoDocumentoUncheckedCreateWithoutDocumentosInput>
    where?: CatalogoDocumentoWhereInput
  }

  export type CatalogoDocumentoUpdateToOneWithWhereWithoutDocumentosInput = {
    where?: CatalogoDocumentoWhereInput
    data: XOR<CatalogoDocumentoUpdateWithoutDocumentosInput, CatalogoDocumentoUncheckedUpdateWithoutDocumentosInput>
  }

  export type CatalogoDocumentoUpdateWithoutDocumentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    obligatorio?: BoolFieldUpdateOperationsInput | boolean
    formatosPermitidos?: CatalogoDocumentoUpdateformatosPermitidosInput | string[]
    tamanoMaximoMb?: IntFieldUpdateOperationsInput | number
    vigenciaDias?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CatalogoDocumentoUncheckedUpdateWithoutDocumentosInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoDocumentoFieldUpdateOperationsInput | $Enums.TipoDocumento
    nombre?: StringFieldUpdateOperationsInput | string
    descripcion?: NullableStringFieldUpdateOperationsInput | string | null
    obligatorio?: BoolFieldUpdateOperationsInput | boolean
    formatosPermitidos?: CatalogoDocumentoUpdateformatosPermitidosInput | string[]
    tamanoMaximoMb?: IntFieldUpdateOperationsInput | number
    vigenciaDias?: NullableIntFieldUpdateOperationsInput | number | null
    activo?: BoolFieldUpdateOperationsInput | boolean
    orden?: IntFieldUpdateOperationsInput | number
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UsuarioUpsertWithoutDocumentosCargadosInput = {
    update: XOR<UsuarioUpdateWithoutDocumentosCargadosInput, UsuarioUncheckedUpdateWithoutDocumentosCargadosInput>
    create: XOR<UsuarioCreateWithoutDocumentosCargadosInput, UsuarioUncheckedCreateWithoutDocumentosCargadosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutDocumentosCargadosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutDocumentosCargadosInput, UsuarioUncheckedUpdateWithoutDocumentosCargadosInput>
  }

  export type UsuarioUpdateWithoutDocumentosCargadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPor?: UsuarioUpdateOneWithoutUsuariosCreadosNestedInput
    usuariosCreados?: UsuarioUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUpdateManyWithoutArrendadorNestedInput
    documentosValidados?: DocumentoUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutDocumentosCargadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosCreados?: UsuarioUncheckedUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUncheckedUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUncheckedUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUncheckedUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUncheckedUpdateManyWithoutArrendadorNestedInput
    documentosValidados?: DocumentoUncheckedUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUncheckedUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUncheckedUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUpsertWithoutDocumentosValidadosInput = {
    update: XOR<UsuarioUpdateWithoutDocumentosValidadosInput, UsuarioUncheckedUpdateWithoutDocumentosValidadosInput>
    create: XOR<UsuarioCreateWithoutDocumentosValidadosInput, UsuarioUncheckedCreateWithoutDocumentosValidadosInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutDocumentosValidadosInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutDocumentosValidadosInput, UsuarioUncheckedUpdateWithoutDocumentosValidadosInput>
  }

  export type UsuarioUpdateWithoutDocumentosValidadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPor?: UsuarioUpdateOneWithoutUsuariosCreadosNestedInput
    usuariosCreados?: UsuarioUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUpdateManyWithoutCargadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutDocumentosValidadosInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosCreados?: UsuarioUncheckedUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUncheckedUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUncheckedUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUncheckedUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUncheckedUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUncheckedUpdateManyWithoutCargadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUncheckedUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUncheckedUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type RegistroDescargaUpsertWithWhereUniqueWithoutDocumentoInput = {
    where: RegistroDescargaWhereUniqueInput
    update: XOR<RegistroDescargaUpdateWithoutDocumentoInput, RegistroDescargaUncheckedUpdateWithoutDocumentoInput>
    create: XOR<RegistroDescargaCreateWithoutDocumentoInput, RegistroDescargaUncheckedCreateWithoutDocumentoInput>
  }

  export type RegistroDescargaUpdateWithWhereUniqueWithoutDocumentoInput = {
    where: RegistroDescargaWhereUniqueInput
    data: XOR<RegistroDescargaUpdateWithoutDocumentoInput, RegistroDescargaUncheckedUpdateWithoutDocumentoInput>
  }

  export type RegistroDescargaUpdateManyWithWhereWithoutDocumentoInput = {
    where: RegistroDescargaScalarWhereInput
    data: XOR<RegistroDescargaUpdateManyMutationInput, RegistroDescargaUncheckedUpdateManyWithoutDocumentoInput>
  }

  export type RegistroDescargaScalarWhereInput = {
    AND?: RegistroDescargaScalarWhereInput | RegistroDescargaScalarWhereInput[]
    OR?: RegistroDescargaScalarWhereInput[]
    NOT?: RegistroDescargaScalarWhereInput | RegistroDescargaScalarWhereInput[]
    id?: StringFilter<"RegistroDescarga"> | string
    documentoId?: StringFilter<"RegistroDescarga"> | string
    usuarioId?: StringFilter<"RegistroDescarga"> | string
    ipAddress?: StringFilter<"RegistroDescarga"> | string
    userAgent?: StringFilter<"RegistroDescarga"> | string
    creadoEn?: DateTimeFilter<"RegistroDescarga"> | Date | string
  }

  export type DocumentoCreateWithoutDescargasInput = {
    id?: string
    nombreOriginal: string
    nombreAlmacenado: string
    rutaArchivo: string
    mimeType: string
    tamanoBytes: number
    hashArchivo: string
    estado?: $Enums.EstadoDocumento
    validadoEn?: Date | string | null
    motivoRechazo?: string | null
    version?: number
    esActivo?: boolean
    creadoEn?: Date | string
    proceso: ProcesoCreateNestedOneWithoutDocumentosInput
    catalogo: CatalogoDocumentoCreateNestedOneWithoutDocumentosInput
    cargadoPor: UsuarioCreateNestedOneWithoutDocumentosCargadosInput
    validadoPor?: UsuarioCreateNestedOneWithoutDocumentosValidadosInput
  }

  export type DocumentoUncheckedCreateWithoutDescargasInput = {
    id?: string
    procesoId: string
    catalogoId: string
    nombreOriginal: string
    nombreAlmacenado: string
    rutaArchivo: string
    mimeType: string
    tamanoBytes: number
    hashArchivo: string
    estado?: $Enums.EstadoDocumento
    validadoPorId?: string | null
    validadoEn?: Date | string | null
    motivoRechazo?: string | null
    version?: number
    esActivo?: boolean
    creadoEn?: Date | string
    cargadoPorId: string
  }

  export type DocumentoCreateOrConnectWithoutDescargasInput = {
    where: DocumentoWhereUniqueInput
    create: XOR<DocumentoCreateWithoutDescargasInput, DocumentoUncheckedCreateWithoutDescargasInput>
  }

  export type DocumentoUpsertWithoutDescargasInput = {
    update: XOR<DocumentoUpdateWithoutDescargasInput, DocumentoUncheckedUpdateWithoutDescargasInput>
    create: XOR<DocumentoCreateWithoutDescargasInput, DocumentoUncheckedCreateWithoutDescargasInput>
    where?: DocumentoWhereInput
  }

  export type DocumentoUpdateToOneWithWhereWithoutDescargasInput = {
    where?: DocumentoWhereInput
    data: XOR<DocumentoUpdateWithoutDescargasInput, DocumentoUncheckedUpdateWithoutDescargasInput>
  }

  export type DocumentoUpdateWithoutDescargasInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreOriginal?: StringFieldUpdateOperationsInput | string
    nombreAlmacenado?: StringFieldUpdateOperationsInput | string
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    hashArchivo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDocumentoFieldUpdateOperationsInput | $Enums.EstadoDocumento
    validadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    proceso?: ProcesoUpdateOneRequiredWithoutDocumentosNestedInput
    catalogo?: CatalogoDocumentoUpdateOneRequiredWithoutDocumentosNestedInput
    cargadoPor?: UsuarioUpdateOneRequiredWithoutDocumentosCargadosNestedInput
    validadoPor?: UsuarioUpdateOneWithoutDocumentosValidadosNestedInput
  }

  export type DocumentoUncheckedUpdateWithoutDescargasInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    catalogoId?: StringFieldUpdateOperationsInput | string
    nombreOriginal?: StringFieldUpdateOperationsInput | string
    nombreAlmacenado?: StringFieldUpdateOperationsInput | string
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    hashArchivo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDocumentoFieldUpdateOperationsInput | $Enums.EstadoDocumento
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    validadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    cargadoPorId?: StringFieldUpdateOperationsInput | string
  }

  export type ProcesoCreateWithoutHistorialPdfInput = {
    id?: string
    codigo: string
    estado?: $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: string | null
    pdfHash?: string | null
    pdfVersion?: number
    firmado?: boolean
    firmadoEn?: Date | string | null
    firmadoPorId?: string | null
    firmaHash?: string | null
    firmaIp?: string | null
    firmaUserAgent?: string | null
    cerradoEn?: Date | string | null
    cerradoPorId?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    enviadoEn?: Date | string | null
    beneficiario: UsuarioCreateNestedOneWithoutProcesosBeneficiarioInput
    arrendador?: UsuarioCreateNestedOneWithoutProcesosArrendadorInput
    documentos?: DocumentoCreateNestedManyWithoutProcesoInput
    eventos?: EventoAuditoriaCreateNestedManyWithoutProcesoInput
    decisiones?: DecisionCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoUncheckedCreateWithoutHistorialPdfInput = {
    id?: string
    codigo: string
    beneficiarioId: string
    arrendadorId?: string | null
    estado?: $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: string | null
    pdfHash?: string | null
    pdfVersion?: number
    firmado?: boolean
    firmadoEn?: Date | string | null
    firmadoPorId?: string | null
    firmaHash?: string | null
    firmaIp?: string | null
    firmaUserAgent?: string | null
    cerradoEn?: Date | string | null
    cerradoPorId?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    enviadoEn?: Date | string | null
    documentos?: DocumentoUncheckedCreateNestedManyWithoutProcesoInput
    eventos?: EventoAuditoriaUncheckedCreateNestedManyWithoutProcesoInput
    decisiones?: DecisionUncheckedCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoCreateOrConnectWithoutHistorialPdfInput = {
    where: ProcesoWhereUniqueInput
    create: XOR<ProcesoCreateWithoutHistorialPdfInput, ProcesoUncheckedCreateWithoutHistorialPdfInput>
  }

  export type ProcesoUpsertWithoutHistorialPdfInput = {
    update: XOR<ProcesoUpdateWithoutHistorialPdfInput, ProcesoUncheckedUpdateWithoutHistorialPdfInput>
    create: XOR<ProcesoCreateWithoutHistorialPdfInput, ProcesoUncheckedCreateWithoutHistorialPdfInput>
    where?: ProcesoWhereInput
  }

  export type ProcesoUpdateToOneWithWhereWithoutHistorialPdfInput = {
    where?: ProcesoWhereInput
    data: XOR<ProcesoUpdateWithoutHistorialPdfInput, ProcesoUncheckedUpdateWithoutHistorialPdfInput>
  }

  export type ProcesoUpdateWithoutHistorialPdfInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    pdfHash?: NullableStringFieldUpdateOperationsInput | string | null
    pdfVersion?: IntFieldUpdateOperationsInput | number
    firmado?: BoolFieldUpdateOperationsInput | boolean
    firmadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    firmaHash?: NullableStringFieldUpdateOperationsInput | string | null
    firmaIp?: NullableStringFieldUpdateOperationsInput | string | null
    firmaUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cerradoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cerradoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beneficiario?: UsuarioUpdateOneRequiredWithoutProcesosBeneficiarioNestedInput
    arrendador?: UsuarioUpdateOneWithoutProcesosArrendadorNestedInput
    documentos?: DocumentoUpdateManyWithoutProcesoNestedInput
    eventos?: EventoAuditoriaUpdateManyWithoutProcesoNestedInput
    decisiones?: DecisionUpdateManyWithoutProcesoNestedInput
  }

  export type ProcesoUncheckedUpdateWithoutHistorialPdfInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiarioId?: StringFieldUpdateOperationsInput | string
    arrendadorId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    pdfHash?: NullableStringFieldUpdateOperationsInput | string | null
    pdfVersion?: IntFieldUpdateOperationsInput | number
    firmado?: BoolFieldUpdateOperationsInput | boolean
    firmadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    firmaHash?: NullableStringFieldUpdateOperationsInput | string | null
    firmaIp?: NullableStringFieldUpdateOperationsInput | string | null
    firmaUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cerradoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cerradoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentos?: DocumentoUncheckedUpdateManyWithoutProcesoNestedInput
    eventos?: EventoAuditoriaUncheckedUpdateManyWithoutProcesoNestedInput
    decisiones?: DecisionUncheckedUpdateManyWithoutProcesoNestedInput
  }

  export type ProcesoCreateWithoutDecisionesInput = {
    id?: string
    codigo: string
    estado?: $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: string | null
    pdfHash?: string | null
    pdfVersion?: number
    firmado?: boolean
    firmadoEn?: Date | string | null
    firmadoPorId?: string | null
    firmaHash?: string | null
    firmaIp?: string | null
    firmaUserAgent?: string | null
    cerradoEn?: Date | string | null
    cerradoPorId?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    enviadoEn?: Date | string | null
    beneficiario: UsuarioCreateNestedOneWithoutProcesosBeneficiarioInput
    arrendador?: UsuarioCreateNestedOneWithoutProcesosArrendadorInput
    documentos?: DocumentoCreateNestedManyWithoutProcesoInput
    eventos?: EventoAuditoriaCreateNestedManyWithoutProcesoInput
    historialPdf?: HistorialPdfCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoUncheckedCreateWithoutDecisionesInput = {
    id?: string
    codigo: string
    beneficiarioId: string
    arrendadorId?: string | null
    estado?: $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: string | null
    pdfHash?: string | null
    pdfVersion?: number
    firmado?: boolean
    firmadoEn?: Date | string | null
    firmadoPorId?: string | null
    firmaHash?: string | null
    firmaIp?: string | null
    firmaUserAgent?: string | null
    cerradoEn?: Date | string | null
    cerradoPorId?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    enviadoEn?: Date | string | null
    documentos?: DocumentoUncheckedCreateNestedManyWithoutProcesoInput
    eventos?: EventoAuditoriaUncheckedCreateNestedManyWithoutProcesoInput
    historialPdf?: HistorialPdfUncheckedCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoCreateOrConnectWithoutDecisionesInput = {
    where: ProcesoWhereUniqueInput
    create: XOR<ProcesoCreateWithoutDecisionesInput, ProcesoUncheckedCreateWithoutDecisionesInput>
  }

  export type UsuarioCreateWithoutDecisionesInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPor?: UsuarioCreateNestedOneWithoutUsuariosCreadosInput
    usuariosCreados?: UsuarioCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutDecisionesInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPorId?: string | null
    usuariosCreados?: UsuarioUncheckedCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialUncheckedCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionUncheckedCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoUncheckedCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoUncheckedCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoUncheckedCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoUncheckedCreateNestedManyWithoutValidadoPorInput
    eventosAuditoria?: EventoAuditoriaUncheckedCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionUncheckedCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutDecisionesInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutDecisionesInput, UsuarioUncheckedCreateWithoutDecisionesInput>
  }

  export type ProcesoUpsertWithoutDecisionesInput = {
    update: XOR<ProcesoUpdateWithoutDecisionesInput, ProcesoUncheckedUpdateWithoutDecisionesInput>
    create: XOR<ProcesoCreateWithoutDecisionesInput, ProcesoUncheckedCreateWithoutDecisionesInput>
    where?: ProcesoWhereInput
  }

  export type ProcesoUpdateToOneWithWhereWithoutDecisionesInput = {
    where?: ProcesoWhereInput
    data: XOR<ProcesoUpdateWithoutDecisionesInput, ProcesoUncheckedUpdateWithoutDecisionesInput>
  }

  export type ProcesoUpdateWithoutDecisionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    pdfHash?: NullableStringFieldUpdateOperationsInput | string | null
    pdfVersion?: IntFieldUpdateOperationsInput | number
    firmado?: BoolFieldUpdateOperationsInput | boolean
    firmadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    firmaHash?: NullableStringFieldUpdateOperationsInput | string | null
    firmaIp?: NullableStringFieldUpdateOperationsInput | string | null
    firmaUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cerradoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cerradoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beneficiario?: UsuarioUpdateOneRequiredWithoutProcesosBeneficiarioNestedInput
    arrendador?: UsuarioUpdateOneWithoutProcesosArrendadorNestedInput
    documentos?: DocumentoUpdateManyWithoutProcesoNestedInput
    eventos?: EventoAuditoriaUpdateManyWithoutProcesoNestedInput
    historialPdf?: HistorialPdfUpdateManyWithoutProcesoNestedInput
  }

  export type ProcesoUncheckedUpdateWithoutDecisionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiarioId?: StringFieldUpdateOperationsInput | string
    arrendadorId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    pdfHash?: NullableStringFieldUpdateOperationsInput | string | null
    pdfVersion?: IntFieldUpdateOperationsInput | number
    firmado?: BoolFieldUpdateOperationsInput | boolean
    firmadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    firmaHash?: NullableStringFieldUpdateOperationsInput | string | null
    firmaIp?: NullableStringFieldUpdateOperationsInput | string | null
    firmaUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cerradoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cerradoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentos?: DocumentoUncheckedUpdateManyWithoutProcesoNestedInput
    eventos?: EventoAuditoriaUncheckedUpdateManyWithoutProcesoNestedInput
    historialPdf?: HistorialPdfUncheckedUpdateManyWithoutProcesoNestedInput
  }

  export type UsuarioUpsertWithoutDecisionesInput = {
    update: XOR<UsuarioUpdateWithoutDecisionesInput, UsuarioUncheckedUpdateWithoutDecisionesInput>
    create: XOR<UsuarioCreateWithoutDecisionesInput, UsuarioUncheckedCreateWithoutDecisionesInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutDecisionesInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutDecisionesInput, UsuarioUncheckedUpdateWithoutDecisionesInput>
  }

  export type UsuarioUpdateWithoutDecisionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPor?: UsuarioUpdateOneWithoutUsuariosCreadosNestedInput
    usuariosCreados?: UsuarioUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutDecisionesInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosCreados?: UsuarioUncheckedUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUncheckedUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUncheckedUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUncheckedUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUncheckedUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUncheckedUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUncheckedUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUncheckedUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type ProcesoCreateWithoutEventosInput = {
    id?: string
    codigo: string
    estado?: $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: string | null
    pdfHash?: string | null
    pdfVersion?: number
    firmado?: boolean
    firmadoEn?: Date | string | null
    firmadoPorId?: string | null
    firmaHash?: string | null
    firmaIp?: string | null
    firmaUserAgent?: string | null
    cerradoEn?: Date | string | null
    cerradoPorId?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    enviadoEn?: Date | string | null
    beneficiario: UsuarioCreateNestedOneWithoutProcesosBeneficiarioInput
    arrendador?: UsuarioCreateNestedOneWithoutProcesosArrendadorInput
    documentos?: DocumentoCreateNestedManyWithoutProcesoInput
    decisiones?: DecisionCreateNestedManyWithoutProcesoInput
    historialPdf?: HistorialPdfCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoUncheckedCreateWithoutEventosInput = {
    id?: string
    codigo: string
    beneficiarioId: string
    arrendadorId?: string | null
    estado?: $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: string | null
    pdfHash?: string | null
    pdfVersion?: number
    firmado?: boolean
    firmadoEn?: Date | string | null
    firmadoPorId?: string | null
    firmaHash?: string | null
    firmaIp?: string | null
    firmaUserAgent?: string | null
    cerradoEn?: Date | string | null
    cerradoPorId?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    enviadoEn?: Date | string | null
    documentos?: DocumentoUncheckedCreateNestedManyWithoutProcesoInput
    decisiones?: DecisionUncheckedCreateNestedManyWithoutProcesoInput
    historialPdf?: HistorialPdfUncheckedCreateNestedManyWithoutProcesoInput
  }

  export type ProcesoCreateOrConnectWithoutEventosInput = {
    where: ProcesoWhereUniqueInput
    create: XOR<ProcesoCreateWithoutEventosInput, ProcesoUncheckedCreateWithoutEventosInput>
  }

  export type UsuarioCreateWithoutEventosAuditoriaInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPor?: UsuarioCreateNestedOneWithoutUsuariosCreadosInput
    usuariosCreados?: UsuarioCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoCreateNestedManyWithoutValidadoPorInput
    decisiones?: DecisionCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioUncheckedCreateWithoutEventosAuditoriaInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    creadoPorId?: string | null
    usuariosCreados?: UsuarioUncheckedCreateNestedManyWithoutCreadoPorInput
    passwordHistorial?: PasswordHistorialUncheckedCreateNestedManyWithoutUsuarioInput
    sesiones?: SesionUncheckedCreateNestedManyWithoutUsuarioInput
    procesosBeneficiario?: ProcesoUncheckedCreateNestedManyWithoutBeneficiarioInput
    procesosArrendador?: ProcesoUncheckedCreateNestedManyWithoutArrendadorInput
    documentosCargados?: DocumentoUncheckedCreateNestedManyWithoutCargadoPorInput
    documentosValidados?: DocumentoUncheckedCreateNestedManyWithoutValidadoPorInput
    decisiones?: DecisionUncheckedCreateNestedManyWithoutUsuarioInput
    tokenRecuperacion?: TokenRecuperacionUncheckedCreateNestedManyWithoutUsuarioInput
    cambiosRol?: CambioRolUncheckedCreateNestedManyWithoutUsuarioInput
  }

  export type UsuarioCreateOrConnectWithoutEventosAuditoriaInput = {
    where: UsuarioWhereUniqueInput
    create: XOR<UsuarioCreateWithoutEventosAuditoriaInput, UsuarioUncheckedCreateWithoutEventosAuditoriaInput>
  }

  export type ProcesoUpsertWithoutEventosInput = {
    update: XOR<ProcesoUpdateWithoutEventosInput, ProcesoUncheckedUpdateWithoutEventosInput>
    create: XOR<ProcesoCreateWithoutEventosInput, ProcesoUncheckedCreateWithoutEventosInput>
    where?: ProcesoWhereInput
  }

  export type ProcesoUpdateToOneWithWhereWithoutEventosInput = {
    where?: ProcesoWhereInput
    data: XOR<ProcesoUpdateWithoutEventosInput, ProcesoUncheckedUpdateWithoutEventosInput>
  }

  export type ProcesoUpdateWithoutEventosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    pdfHash?: NullableStringFieldUpdateOperationsInput | string | null
    pdfVersion?: IntFieldUpdateOperationsInput | number
    firmado?: BoolFieldUpdateOperationsInput | boolean
    firmadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    firmaHash?: NullableStringFieldUpdateOperationsInput | string | null
    firmaIp?: NullableStringFieldUpdateOperationsInput | string | null
    firmaUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cerradoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cerradoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beneficiario?: UsuarioUpdateOneRequiredWithoutProcesosBeneficiarioNestedInput
    arrendador?: UsuarioUpdateOneWithoutProcesosArrendadorNestedInput
    documentos?: DocumentoUpdateManyWithoutProcesoNestedInput
    decisiones?: DecisionUpdateManyWithoutProcesoNestedInput
    historialPdf?: HistorialPdfUpdateManyWithoutProcesoNestedInput
  }

  export type ProcesoUncheckedUpdateWithoutEventosInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiarioId?: StringFieldUpdateOperationsInput | string
    arrendadorId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    pdfHash?: NullableStringFieldUpdateOperationsInput | string | null
    pdfVersion?: IntFieldUpdateOperationsInput | number
    firmado?: BoolFieldUpdateOperationsInput | boolean
    firmadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    firmaHash?: NullableStringFieldUpdateOperationsInput | string | null
    firmaIp?: NullableStringFieldUpdateOperationsInput | string | null
    firmaUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cerradoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cerradoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentos?: DocumentoUncheckedUpdateManyWithoutProcesoNestedInput
    decisiones?: DecisionUncheckedUpdateManyWithoutProcesoNestedInput
    historialPdf?: HistorialPdfUncheckedUpdateManyWithoutProcesoNestedInput
  }

  export type UsuarioUpsertWithoutEventosAuditoriaInput = {
    update: XOR<UsuarioUpdateWithoutEventosAuditoriaInput, UsuarioUncheckedUpdateWithoutEventosAuditoriaInput>
    create: XOR<UsuarioCreateWithoutEventosAuditoriaInput, UsuarioUncheckedCreateWithoutEventosAuditoriaInput>
    where?: UsuarioWhereInput
  }

  export type UsuarioUpdateToOneWithWhereWithoutEventosAuditoriaInput = {
    where?: UsuarioWhereInput
    data: XOR<UsuarioUpdateWithoutEventosAuditoriaInput, UsuarioUncheckedUpdateWithoutEventosAuditoriaInput>
  }

  export type UsuarioUpdateWithoutEventosAuditoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPor?: UsuarioUpdateOneWithoutUsuariosCreadosNestedInput
    usuariosCreados?: UsuarioUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUpdateManyWithoutValidadoPorNestedInput
    decisiones?: DecisionUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutEventosAuditoriaInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    usuariosCreados?: UsuarioUncheckedUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUncheckedUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUncheckedUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUncheckedUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUncheckedUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUncheckedUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUncheckedUpdateManyWithoutValidadoPorNestedInput
    decisiones?: DecisionUncheckedUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUncheckedUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioCreateManyCreadoPorInput = {
    id?: string
    cedula: string
    email: string
    nombreCompleto: string
    passwordHash: string
    rol: $Enums.Rol
    estado?: $Enums.EstadoUsuario
    mfaSecret?: string | null
    mfaHabilitado?: boolean
    intentosFallidos?: number
    bloqueadoHasta?: Date | string | null
    ultimoAcceso?: Date | string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
  }

  export type PasswordHistorialCreateManyUsuarioInput = {
    id?: string
    passwordHash: string
    creadoEn?: Date | string
  }

  export type SesionCreateManyUsuarioInput = {
    id?: string
    tokenHash: string
    ipAddress: string
    userAgent: string
    expiraEn: Date | string
    creadoEn?: Date | string
    ultimaActividad?: Date | string
  }

  export type ProcesoCreateManyBeneficiarioInput = {
    id?: string
    codigo: string
    arrendadorId?: string | null
    estado?: $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: string | null
    pdfHash?: string | null
    pdfVersion?: number
    firmado?: boolean
    firmadoEn?: Date | string | null
    firmadoPorId?: string | null
    firmaHash?: string | null
    firmaIp?: string | null
    firmaUserAgent?: string | null
    cerradoEn?: Date | string | null
    cerradoPorId?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    enviadoEn?: Date | string | null
  }

  export type ProcesoCreateManyArrendadorInput = {
    id?: string
    codigo: string
    beneficiarioId: string
    estado?: $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: string | null
    pdfHash?: string | null
    pdfVersion?: number
    firmado?: boolean
    firmadoEn?: Date | string | null
    firmadoPorId?: string | null
    firmaHash?: string | null
    firmaIp?: string | null
    firmaUserAgent?: string | null
    cerradoEn?: Date | string | null
    cerradoPorId?: string | null
    creadoEn?: Date | string
    actualizadoEn?: Date | string
    enviadoEn?: Date | string | null
  }

  export type DocumentoCreateManyCargadoPorInput = {
    id?: string
    procesoId: string
    catalogoId: string
    nombreOriginal: string
    nombreAlmacenado: string
    rutaArchivo: string
    mimeType: string
    tamanoBytes: number
    hashArchivo: string
    estado?: $Enums.EstadoDocumento
    validadoPorId?: string | null
    validadoEn?: Date | string | null
    motivoRechazo?: string | null
    version?: number
    esActivo?: boolean
    creadoEn?: Date | string
  }

  export type DocumentoCreateManyValidadoPorInput = {
    id?: string
    procesoId: string
    catalogoId: string
    nombreOriginal: string
    nombreAlmacenado: string
    rutaArchivo: string
    mimeType: string
    tamanoBytes: number
    hashArchivo: string
    estado?: $Enums.EstadoDocumento
    validadoEn?: Date | string | null
    motivoRechazo?: string | null
    version?: number
    esActivo?: boolean
    creadoEn?: Date | string
    cargadoPorId: string
  }

  export type EventoAuditoriaCreateManyUsuarioInput = {
    id?: string
    procesoId?: string | null
    tipo: $Enums.TipoEvento
    descripcion: string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
  }

  export type DecisionCreateManyUsuarioInput = {
    id?: string
    procesoId: string
    estadoAnterior: $Enums.EstadoProceso
    estadoNuevo: $Enums.EstadoProceso
    aprobado: boolean
    motivo: string
    rol: $Enums.Rol
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
  }

  export type TokenRecuperacionCreateManyUsuarioInput = {
    id?: string
    token: string
    expiraEn: Date | string
    usado?: boolean
    creadoEn?: Date | string
  }

  export type CambioRolCreateManyUsuarioInput = {
    id?: string
    rolAnterior: $Enums.Rol
    rolNuevo: $Enums.Rol
    motivo?: string | null
    cambiadoPorId: string
    creadoEn?: Date | string
  }

  export type UsuarioUpdateWithoutCreadoPorInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosCreados?: UsuarioUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateWithoutCreadoPorInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuariosCreados?: UsuarioUncheckedUpdateManyWithoutCreadoPorNestedInput
    passwordHistorial?: PasswordHistorialUncheckedUpdateManyWithoutUsuarioNestedInput
    sesiones?: SesionUncheckedUpdateManyWithoutUsuarioNestedInput
    procesosBeneficiario?: ProcesoUncheckedUpdateManyWithoutBeneficiarioNestedInput
    procesosArrendador?: ProcesoUncheckedUpdateManyWithoutArrendadorNestedInput
    documentosCargados?: DocumentoUncheckedUpdateManyWithoutCargadoPorNestedInput
    documentosValidados?: DocumentoUncheckedUpdateManyWithoutValidadoPorNestedInput
    eventosAuditoria?: EventoAuditoriaUncheckedUpdateManyWithoutUsuarioNestedInput
    decisiones?: DecisionUncheckedUpdateManyWithoutUsuarioNestedInput
    tokenRecuperacion?: TokenRecuperacionUncheckedUpdateManyWithoutUsuarioNestedInput
    cambiosRol?: CambioRolUncheckedUpdateManyWithoutUsuarioNestedInput
  }

  export type UsuarioUncheckedUpdateManyWithoutCreadoPorInput = {
    id?: StringFieldUpdateOperationsInput | string
    cedula?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    nombreCompleto?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    estado?: EnumEstadoUsuarioFieldUpdateOperationsInput | $Enums.EstadoUsuario
    mfaSecret?: NullableStringFieldUpdateOperationsInput | string | null
    mfaHabilitado?: BoolFieldUpdateOperationsInput | boolean
    intentosFallidos?: IntFieldUpdateOperationsInput | number
    bloqueadoHasta?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    ultimoAcceso?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistorialUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistorialUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PasswordHistorialUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    passwordHash?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SesionUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    ultimaActividad?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SesionUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    ultimaActividad?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SesionUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    tokenHash?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    ultimaActividad?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ProcesoUpdateWithoutBeneficiarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    pdfHash?: NullableStringFieldUpdateOperationsInput | string | null
    pdfVersion?: IntFieldUpdateOperationsInput | number
    firmado?: BoolFieldUpdateOperationsInput | boolean
    firmadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    firmaHash?: NullableStringFieldUpdateOperationsInput | string | null
    firmaIp?: NullableStringFieldUpdateOperationsInput | string | null
    firmaUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cerradoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cerradoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    arrendador?: UsuarioUpdateOneWithoutProcesosArrendadorNestedInput
    documentos?: DocumentoUpdateManyWithoutProcesoNestedInput
    eventos?: EventoAuditoriaUpdateManyWithoutProcesoNestedInput
    decisiones?: DecisionUpdateManyWithoutProcesoNestedInput
    historialPdf?: HistorialPdfUpdateManyWithoutProcesoNestedInput
  }

  export type ProcesoUncheckedUpdateWithoutBeneficiarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    arrendadorId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    pdfHash?: NullableStringFieldUpdateOperationsInput | string | null
    pdfVersion?: IntFieldUpdateOperationsInput | number
    firmado?: BoolFieldUpdateOperationsInput | boolean
    firmadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    firmaHash?: NullableStringFieldUpdateOperationsInput | string | null
    firmaIp?: NullableStringFieldUpdateOperationsInput | string | null
    firmaUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cerradoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cerradoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentos?: DocumentoUncheckedUpdateManyWithoutProcesoNestedInput
    eventos?: EventoAuditoriaUncheckedUpdateManyWithoutProcesoNestedInput
    decisiones?: DecisionUncheckedUpdateManyWithoutProcesoNestedInput
    historialPdf?: HistorialPdfUncheckedUpdateManyWithoutProcesoNestedInput
  }

  export type ProcesoUncheckedUpdateManyWithoutBeneficiarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    arrendadorId?: NullableStringFieldUpdateOperationsInput | string | null
    estado?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    pdfHash?: NullableStringFieldUpdateOperationsInput | string | null
    pdfVersion?: IntFieldUpdateOperationsInput | number
    firmado?: BoolFieldUpdateOperationsInput | boolean
    firmadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    firmaHash?: NullableStringFieldUpdateOperationsInput | string | null
    firmaIp?: NullableStringFieldUpdateOperationsInput | string | null
    firmaUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cerradoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cerradoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ProcesoUpdateWithoutArrendadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    pdfHash?: NullableStringFieldUpdateOperationsInput | string | null
    pdfVersion?: IntFieldUpdateOperationsInput | number
    firmado?: BoolFieldUpdateOperationsInput | boolean
    firmadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    firmaHash?: NullableStringFieldUpdateOperationsInput | string | null
    firmaIp?: NullableStringFieldUpdateOperationsInput | string | null
    firmaUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cerradoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cerradoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    beneficiario?: UsuarioUpdateOneRequiredWithoutProcesosBeneficiarioNestedInput
    documentos?: DocumentoUpdateManyWithoutProcesoNestedInput
    eventos?: EventoAuditoriaUpdateManyWithoutProcesoNestedInput
    decisiones?: DecisionUpdateManyWithoutProcesoNestedInput
    historialPdf?: HistorialPdfUpdateManyWithoutProcesoNestedInput
  }

  export type ProcesoUncheckedUpdateWithoutArrendadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiarioId?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    pdfHash?: NullableStringFieldUpdateOperationsInput | string | null
    pdfVersion?: IntFieldUpdateOperationsInput | number
    firmado?: BoolFieldUpdateOperationsInput | boolean
    firmadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    firmaHash?: NullableStringFieldUpdateOperationsInput | string | null
    firmaIp?: NullableStringFieldUpdateOperationsInput | string | null
    firmaUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cerradoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cerradoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    documentos?: DocumentoUncheckedUpdateManyWithoutProcesoNestedInput
    eventos?: EventoAuditoriaUncheckedUpdateManyWithoutProcesoNestedInput
    decisiones?: DecisionUncheckedUpdateManyWithoutProcesoNestedInput
    historialPdf?: HistorialPdfUncheckedUpdateManyWithoutProcesoNestedInput
  }

  export type ProcesoUncheckedUpdateManyWithoutArrendadorInput = {
    id?: StringFieldUpdateOperationsInput | string
    codigo?: StringFieldUpdateOperationsInput | string
    beneficiarioId?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    formulario?: NullableJsonNullValueInput | InputJsonValue
    pdfPath?: NullableStringFieldUpdateOperationsInput | string | null
    pdfHash?: NullableStringFieldUpdateOperationsInput | string | null
    pdfVersion?: IntFieldUpdateOperationsInput | number
    firmado?: BoolFieldUpdateOperationsInput | boolean
    firmadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    firmadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    firmaHash?: NullableStringFieldUpdateOperationsInput | string | null
    firmaIp?: NullableStringFieldUpdateOperationsInput | string | null
    firmaUserAgent?: NullableStringFieldUpdateOperationsInput | string | null
    cerradoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    cerradoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    actualizadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    enviadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type DocumentoUpdateWithoutCargadoPorInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreOriginal?: StringFieldUpdateOperationsInput | string
    nombreAlmacenado?: StringFieldUpdateOperationsInput | string
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    hashArchivo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDocumentoFieldUpdateOperationsInput | $Enums.EstadoDocumento
    validadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    proceso?: ProcesoUpdateOneRequiredWithoutDocumentosNestedInput
    catalogo?: CatalogoDocumentoUpdateOneRequiredWithoutDocumentosNestedInput
    validadoPor?: UsuarioUpdateOneWithoutDocumentosValidadosNestedInput
    descargas?: RegistroDescargaUpdateManyWithoutDocumentoNestedInput
  }

  export type DocumentoUncheckedUpdateWithoutCargadoPorInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    catalogoId?: StringFieldUpdateOperationsInput | string
    nombreOriginal?: StringFieldUpdateOperationsInput | string
    nombreAlmacenado?: StringFieldUpdateOperationsInput | string
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    hashArchivo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDocumentoFieldUpdateOperationsInput | $Enums.EstadoDocumento
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    validadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    descargas?: RegistroDescargaUncheckedUpdateManyWithoutDocumentoNestedInput
  }

  export type DocumentoUncheckedUpdateManyWithoutCargadoPorInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    catalogoId?: StringFieldUpdateOperationsInput | string
    nombreOriginal?: StringFieldUpdateOperationsInput | string
    nombreAlmacenado?: StringFieldUpdateOperationsInput | string
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    hashArchivo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDocumentoFieldUpdateOperationsInput | $Enums.EstadoDocumento
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    validadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentoUpdateWithoutValidadoPorInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreOriginal?: StringFieldUpdateOperationsInput | string
    nombreAlmacenado?: StringFieldUpdateOperationsInput | string
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    hashArchivo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDocumentoFieldUpdateOperationsInput | $Enums.EstadoDocumento
    validadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    proceso?: ProcesoUpdateOneRequiredWithoutDocumentosNestedInput
    catalogo?: CatalogoDocumentoUpdateOneRequiredWithoutDocumentosNestedInput
    cargadoPor?: UsuarioUpdateOneRequiredWithoutDocumentosCargadosNestedInput
    descargas?: RegistroDescargaUpdateManyWithoutDocumentoNestedInput
  }

  export type DocumentoUncheckedUpdateWithoutValidadoPorInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    catalogoId?: StringFieldUpdateOperationsInput | string
    nombreOriginal?: StringFieldUpdateOperationsInput | string
    nombreAlmacenado?: StringFieldUpdateOperationsInput | string
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    hashArchivo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDocumentoFieldUpdateOperationsInput | $Enums.EstadoDocumento
    validadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    cargadoPorId?: StringFieldUpdateOperationsInput | string
    descargas?: RegistroDescargaUncheckedUpdateManyWithoutDocumentoNestedInput
  }

  export type DocumentoUncheckedUpdateManyWithoutValidadoPorInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    catalogoId?: StringFieldUpdateOperationsInput | string
    nombreOriginal?: StringFieldUpdateOperationsInput | string
    nombreAlmacenado?: StringFieldUpdateOperationsInput | string
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    hashArchivo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDocumentoFieldUpdateOperationsInput | $Enums.EstadoDocumento
    validadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    cargadoPorId?: StringFieldUpdateOperationsInput | string
  }

  export type EventoAuditoriaUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoEventoFieldUpdateOperationsInput | $Enums.TipoEvento
    descripcion?: StringFieldUpdateOperationsInput | string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    proceso?: ProcesoUpdateOneWithoutEventosNestedInput
  }

  export type EventoAuditoriaUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoEventoFieldUpdateOperationsInput | $Enums.TipoEvento
    descripcion?: StringFieldUpdateOperationsInput | string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoAuditoriaUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoEventoFieldUpdateOperationsInput | $Enums.TipoEvento
    descripcion?: StringFieldUpdateOperationsInput | string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    estadoAnterior?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    estadoNuevo?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    motivo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    proceso?: ProcesoUpdateOneRequiredWithoutDecisionesNestedInput
  }

  export type DecisionUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    estadoAnterior?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    estadoNuevo?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    motivo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    estadoAnterior?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    estadoNuevo?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    motivo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenRecuperacionUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenRecuperacionUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TokenRecuperacionUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    token?: StringFieldUpdateOperationsInput | string
    expiraEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usado?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CambioRolUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    rolAnterior?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    rolNuevo?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    cambiadoPorId?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CambioRolUncheckedUpdateWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    rolAnterior?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    rolNuevo?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    cambiadoPorId?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CambioRolUncheckedUpdateManyWithoutUsuarioInput = {
    id?: StringFieldUpdateOperationsInput | string
    rolAnterior?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    rolNuevo?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    motivo?: NullableStringFieldUpdateOperationsInput | string | null
    cambiadoPorId?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DocumentoCreateManyCatalogoInput = {
    id?: string
    procesoId: string
    nombreOriginal: string
    nombreAlmacenado: string
    rutaArchivo: string
    mimeType: string
    tamanoBytes: number
    hashArchivo: string
    estado?: $Enums.EstadoDocumento
    validadoPorId?: string | null
    validadoEn?: Date | string | null
    motivoRechazo?: string | null
    version?: number
    esActivo?: boolean
    creadoEn?: Date | string
    cargadoPorId: string
  }

  export type DocumentoUpdateWithoutCatalogoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreOriginal?: StringFieldUpdateOperationsInput | string
    nombreAlmacenado?: StringFieldUpdateOperationsInput | string
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    hashArchivo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDocumentoFieldUpdateOperationsInput | $Enums.EstadoDocumento
    validadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    proceso?: ProcesoUpdateOneRequiredWithoutDocumentosNestedInput
    cargadoPor?: UsuarioUpdateOneRequiredWithoutDocumentosCargadosNestedInput
    validadoPor?: UsuarioUpdateOneWithoutDocumentosValidadosNestedInput
    descargas?: RegistroDescargaUpdateManyWithoutDocumentoNestedInput
  }

  export type DocumentoUncheckedUpdateWithoutCatalogoInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    nombreOriginal?: StringFieldUpdateOperationsInput | string
    nombreAlmacenado?: StringFieldUpdateOperationsInput | string
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    hashArchivo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDocumentoFieldUpdateOperationsInput | $Enums.EstadoDocumento
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    validadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    cargadoPorId?: StringFieldUpdateOperationsInput | string
    descargas?: RegistroDescargaUncheckedUpdateManyWithoutDocumentoNestedInput
  }

  export type DocumentoUncheckedUpdateManyWithoutCatalogoInput = {
    id?: StringFieldUpdateOperationsInput | string
    procesoId?: StringFieldUpdateOperationsInput | string
    nombreOriginal?: StringFieldUpdateOperationsInput | string
    nombreAlmacenado?: StringFieldUpdateOperationsInput | string
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    hashArchivo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDocumentoFieldUpdateOperationsInput | $Enums.EstadoDocumento
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    validadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    cargadoPorId?: StringFieldUpdateOperationsInput | string
  }

  export type DocumentoCreateManyProcesoInput = {
    id?: string
    catalogoId: string
    nombreOriginal: string
    nombreAlmacenado: string
    rutaArchivo: string
    mimeType: string
    tamanoBytes: number
    hashArchivo: string
    estado?: $Enums.EstadoDocumento
    validadoPorId?: string | null
    validadoEn?: Date | string | null
    motivoRechazo?: string | null
    version?: number
    esActivo?: boolean
    creadoEn?: Date | string
    cargadoPorId: string
  }

  export type EventoAuditoriaCreateManyProcesoInput = {
    id?: string
    usuarioId?: string | null
    tipo: $Enums.TipoEvento
    descripcion: string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
  }

  export type DecisionCreateManyProcesoInput = {
    id?: string
    estadoAnterior: $Enums.EstadoProceso
    estadoNuevo: $Enums.EstadoProceso
    aprobado: boolean
    motivo: string
    usuarioId: string
    rol: $Enums.Rol
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
  }

  export type HistorialPdfCreateManyProcesoInput = {
    id?: string
    version: number
    pdfPath: string
    pdfHash: string
    creadoEn?: Date | string
  }

  export type DocumentoUpdateWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    nombreOriginal?: StringFieldUpdateOperationsInput | string
    nombreAlmacenado?: StringFieldUpdateOperationsInput | string
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    hashArchivo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDocumentoFieldUpdateOperationsInput | $Enums.EstadoDocumento
    validadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    catalogo?: CatalogoDocumentoUpdateOneRequiredWithoutDocumentosNestedInput
    cargadoPor?: UsuarioUpdateOneRequiredWithoutDocumentosCargadosNestedInput
    validadoPor?: UsuarioUpdateOneWithoutDocumentosValidadosNestedInput
    descargas?: RegistroDescargaUpdateManyWithoutDocumentoNestedInput
  }

  export type DocumentoUncheckedUpdateWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    catalogoId?: StringFieldUpdateOperationsInput | string
    nombreOriginal?: StringFieldUpdateOperationsInput | string
    nombreAlmacenado?: StringFieldUpdateOperationsInput | string
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    hashArchivo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDocumentoFieldUpdateOperationsInput | $Enums.EstadoDocumento
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    validadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    cargadoPorId?: StringFieldUpdateOperationsInput | string
    descargas?: RegistroDescargaUncheckedUpdateManyWithoutDocumentoNestedInput
  }

  export type DocumentoUncheckedUpdateManyWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    catalogoId?: StringFieldUpdateOperationsInput | string
    nombreOriginal?: StringFieldUpdateOperationsInput | string
    nombreAlmacenado?: StringFieldUpdateOperationsInput | string
    rutaArchivo?: StringFieldUpdateOperationsInput | string
    mimeType?: StringFieldUpdateOperationsInput | string
    tamanoBytes?: IntFieldUpdateOperationsInput | number
    hashArchivo?: StringFieldUpdateOperationsInput | string
    estado?: EnumEstadoDocumentoFieldUpdateOperationsInput | $Enums.EstadoDocumento
    validadoPorId?: NullableStringFieldUpdateOperationsInput | string | null
    validadoEn?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    motivoRechazo?: NullableStringFieldUpdateOperationsInput | string | null
    version?: IntFieldUpdateOperationsInput | number
    esActivo?: BoolFieldUpdateOperationsInput | boolean
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    cargadoPorId?: StringFieldUpdateOperationsInput | string
  }

  export type EventoAuditoriaUpdateWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    tipo?: EnumTipoEventoFieldUpdateOperationsInput | $Enums.TipoEvento
    descripcion?: StringFieldUpdateOperationsInput | string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneWithoutEventosAuditoriaNestedInput
  }

  export type EventoAuditoriaUncheckedUpdateWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoEventoFieldUpdateOperationsInput | $Enums.TipoEvento
    descripcion?: StringFieldUpdateOperationsInput | string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventoAuditoriaUncheckedUpdateManyWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: NullableStringFieldUpdateOperationsInput | string | null
    tipo?: EnumTipoEventoFieldUpdateOperationsInput | $Enums.TipoEvento
    descripcion?: StringFieldUpdateOperationsInput | string
    detalles?: NullableJsonNullValueInput | InputJsonValue
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionUpdateWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    estadoAnterior?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    estadoNuevo?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    motivo?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
    usuario?: UsuarioUpdateOneRequiredWithoutDecisionesNestedInput
  }

  export type DecisionUncheckedUpdateWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    estadoAnterior?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    estadoNuevo?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    motivo?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DecisionUncheckedUpdateManyWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    estadoAnterior?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    estadoNuevo?: EnumEstadoProcesoFieldUpdateOperationsInput | $Enums.EstadoProceso
    aprobado?: BoolFieldUpdateOperationsInput | boolean
    motivo?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    rol?: EnumRolFieldUpdateOperationsInput | $Enums.Rol
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistorialPdfUpdateWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    pdfPath?: StringFieldUpdateOperationsInput | string
    pdfHash?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistorialPdfUncheckedUpdateWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    pdfPath?: StringFieldUpdateOperationsInput | string
    pdfHash?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type HistorialPdfUncheckedUpdateManyWithoutProcesoInput = {
    id?: StringFieldUpdateOperationsInput | string
    version?: IntFieldUpdateOperationsInput | number
    pdfPath?: StringFieldUpdateOperationsInput | string
    pdfHash?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegistroDescargaCreateManyDocumentoInput = {
    id?: string
    usuarioId: string
    ipAddress: string
    userAgent: string
    creadoEn?: Date | string
  }

  export type RegistroDescargaUpdateWithoutDocumentoInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegistroDescargaUncheckedUpdateWithoutDocumentoInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RegistroDescargaUncheckedUpdateManyWithoutDocumentoInput = {
    id?: StringFieldUpdateOperationsInput | string
    usuarioId?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    userAgent?: StringFieldUpdateOperationsInput | string
    creadoEn?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UsuarioCountOutputTypeDefaultArgs instead
     */
    export type UsuarioCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogoDocumentoCountOutputTypeDefaultArgs instead
     */
    export type CatalogoDocumentoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogoDocumentoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcesoCountOutputTypeDefaultArgs instead
     */
    export type ProcesoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcesoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentoCountOutputTypeDefaultArgs instead
     */
    export type DocumentoCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentoCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UsuarioDefaultArgs instead
     */
    export type UsuarioArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UsuarioDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PasswordHistorialDefaultArgs instead
     */
    export type PasswordHistorialArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PasswordHistorialDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TokenRecuperacionDefaultArgs instead
     */
    export type TokenRecuperacionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TokenRecuperacionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SesionDefaultArgs instead
     */
    export type SesionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SesionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CambioRolDefaultArgs instead
     */
    export type CambioRolArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CambioRolDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CatalogoDocumentoDefaultArgs instead
     */
    export type CatalogoDocumentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CatalogoDocumentoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ProcesoDefaultArgs instead
     */
    export type ProcesoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ProcesoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DocumentoDefaultArgs instead
     */
    export type DocumentoArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DocumentoDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RegistroDescargaDefaultArgs instead
     */
    export type RegistroDescargaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RegistroDescargaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use HistorialPdfDefaultArgs instead
     */
    export type HistorialPdfArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = HistorialPdfDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DecisionDefaultArgs instead
     */
    export type DecisionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DecisionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventoAuditoriaDefaultArgs instead
     */
    export type EventoAuditoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventoAuditoriaDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConfiguracionDefaultArgs instead
     */
    export type ConfiguracionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConfiguracionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ConvocatoriaDefaultArgs instead
     */
    export type ConvocatoriaArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ConvocatoriaDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}